// This file is generated by "./lib/proto/generate"

package proto

import "encoding/json"

// Version of cdp protocol
const Version = "v1.3"

// AccessibilityAXNodeID Unique accessibility node identifier.
type AccessibilityAXNodeID string

// AccessibilityAXValueType Enum of possible property types.
type AccessibilityAXValueType string

const (
	// AccessibilityAXValueTypeBoolean enum const
	AccessibilityAXValueTypeBoolean AccessibilityAXValueType = "boolean"

	// AccessibilityAXValueTypeTristate enum const
	AccessibilityAXValueTypeTristate AccessibilityAXValueType = "tristate"

	// AccessibilityAXValueTypeBooleanOrUndefined enum const
	AccessibilityAXValueTypeBooleanOrUndefined AccessibilityAXValueType = "booleanOrUndefined"

	// AccessibilityAXValueTypeIdref enum const
	AccessibilityAXValueTypeIdref AccessibilityAXValueType = "idref"

	// AccessibilityAXValueTypeIdrefList enum const
	AccessibilityAXValueTypeIdrefList AccessibilityAXValueType = "idrefList"

	// AccessibilityAXValueTypeInteger enum const
	AccessibilityAXValueTypeInteger AccessibilityAXValueType = "integer"

	// AccessibilityAXValueTypeNode enum const
	AccessibilityAXValueTypeNode AccessibilityAXValueType = "node"

	// AccessibilityAXValueTypeNodeList enum const
	AccessibilityAXValueTypeNodeList AccessibilityAXValueType = "nodeList"

	// AccessibilityAXValueTypeNumber enum const
	AccessibilityAXValueTypeNumber AccessibilityAXValueType = "number"

	// AccessibilityAXValueTypeString enum const
	AccessibilityAXValueTypeString AccessibilityAXValueType = "string"

	// AccessibilityAXValueTypeComputedString enum const
	AccessibilityAXValueTypeComputedString AccessibilityAXValueType = "computedString"

	// AccessibilityAXValueTypeToken enum const
	AccessibilityAXValueTypeToken AccessibilityAXValueType = "token"

	// AccessibilityAXValueTypeTokenList enum const
	AccessibilityAXValueTypeTokenList AccessibilityAXValueType = "tokenList"

	// AccessibilityAXValueTypeDomRelation enum const
	AccessibilityAXValueTypeDomRelation AccessibilityAXValueType = "domRelation"

	// AccessibilityAXValueTypeRole enum const
	AccessibilityAXValueTypeRole AccessibilityAXValueType = "role"

	// AccessibilityAXValueTypeInternalRole enum const
	AccessibilityAXValueTypeInternalRole AccessibilityAXValueType = "internalRole"

	// AccessibilityAXValueTypeValueUndefined enum const
	AccessibilityAXValueTypeValueUndefined AccessibilityAXValueType = "valueUndefined"
)

// AccessibilityAXValueSourceType Enum of possible property sources.
type AccessibilityAXValueSourceType string

const (
	// AccessibilityAXValueSourceTypeAttribute enum const
	AccessibilityAXValueSourceTypeAttribute AccessibilityAXValueSourceType = "attribute"

	// AccessibilityAXValueSourceTypeImplicit enum const
	AccessibilityAXValueSourceTypeImplicit AccessibilityAXValueSourceType = "implicit"

	// AccessibilityAXValueSourceTypeStyle enum const
	AccessibilityAXValueSourceTypeStyle AccessibilityAXValueSourceType = "style"

	// AccessibilityAXValueSourceTypeContents enum const
	AccessibilityAXValueSourceTypeContents AccessibilityAXValueSourceType = "contents"

	// AccessibilityAXValueSourceTypePlaceholder enum const
	AccessibilityAXValueSourceTypePlaceholder AccessibilityAXValueSourceType = "placeholder"

	// AccessibilityAXValueSourceTypeRelatedElement enum const
	AccessibilityAXValueSourceTypeRelatedElement AccessibilityAXValueSourceType = "relatedElement"
)

// AccessibilityAXValueNativeSourceType Enum of possible native property sources (as a subtype of a particular AXValueSourceType).
type AccessibilityAXValueNativeSourceType string

const (
	// AccessibilityAXValueNativeSourceTypeFigcaption enum const
	AccessibilityAXValueNativeSourceTypeFigcaption AccessibilityAXValueNativeSourceType = "figcaption"

	// AccessibilityAXValueNativeSourceTypeLabel enum const
	AccessibilityAXValueNativeSourceTypeLabel AccessibilityAXValueNativeSourceType = "label"

	// AccessibilityAXValueNativeSourceTypeLabelfor enum const
	AccessibilityAXValueNativeSourceTypeLabelfor AccessibilityAXValueNativeSourceType = "labelfor"

	// AccessibilityAXValueNativeSourceTypeLabelwrapped enum const
	AccessibilityAXValueNativeSourceTypeLabelwrapped AccessibilityAXValueNativeSourceType = "labelwrapped"

	// AccessibilityAXValueNativeSourceTypeLegend enum const
	AccessibilityAXValueNativeSourceTypeLegend AccessibilityAXValueNativeSourceType = "legend"

	// AccessibilityAXValueNativeSourceTypeTablecaption enum const
	AccessibilityAXValueNativeSourceTypeTablecaption AccessibilityAXValueNativeSourceType = "tablecaption"

	// AccessibilityAXValueNativeSourceTypeTitle enum const
	AccessibilityAXValueNativeSourceTypeTitle AccessibilityAXValueNativeSourceType = "title"

	// AccessibilityAXValueNativeSourceTypeOther enum const
	AccessibilityAXValueNativeSourceTypeOther AccessibilityAXValueNativeSourceType = "other"
)

// AccessibilityAXValueSource A single source for a computed AX property.
type AccessibilityAXValueSource struct {

	// Type What type of source this is.
	Type AccessibilityAXValueSourceType `json:"type"`

	// Value (optional) The value of this property source.
	Value *AccessibilityAXValue `json:"value,omitempty"`

	// Attribute (optional) The name of the relevant attribute, if any.
	Attribute string `json:"attribute,omitempty"`

	// AttributeValue (optional) The value of the relevant attribute, if any.
	AttributeValue *AccessibilityAXValue `json:"attributeValue,omitempty"`

	// Superseded (optional) Whether this source is superseded by a higher priority source.
	Superseded bool `json:"superseded,omitempty"`

	// NativeSource (optional) The native markup source for this value, e.g. a <label> element.
	NativeSource AccessibilityAXValueNativeSourceType `json:"nativeSource,omitempty"`

	// NativeSourceValue (optional) The value, such as a node or node list, of the native source.
	NativeSourceValue *AccessibilityAXValue `json:"nativeSourceValue,omitempty"`

	// Invalid (optional) Whether the value for this property is invalid.
	Invalid bool `json:"invalid,omitempty"`

	// InvalidReason (optional) Reason for the value being invalid, if it is.
	InvalidReason string `json:"invalidReason,omitempty"`
}

// AccessibilityAXRelatedNode ...
type AccessibilityAXRelatedNode struct {

	// BackendDOMNodeID The BackendNodeId of the related DOM node.
	BackendDOMNodeID DOMBackendNodeID `json:"backendDOMNodeId"`

	// Idref (optional) The IDRef value provided, if any.
	Idref string `json:"idref,omitempty"`

	// Text (optional) The text alternative of this node in the current context.
	Text string `json:"text,omitempty"`
}

// AccessibilityAXProperty ...
type AccessibilityAXProperty struct {

	// Name The name of this property.
	Name AccessibilityAXPropertyName `json:"name"`

	// Value The value of this property.
	Value *AccessibilityAXValue `json:"value"`
}

// AccessibilityAXValue A single computed AX property.
type AccessibilityAXValue struct {

	// Type The type of this value.
	Type AccessibilityAXValueType `json:"type"`

	// Value (optional) The computed value of this property.
	Value JSON `json:"value,omitempty"`

	// RelatedNodes (optional) One or more related nodes, if applicable.
	RelatedNodes []*AccessibilityAXRelatedNode `json:"relatedNodes,omitempty"`

	// Sources (optional) The sources which contributed to the computation of this property.
	Sources []*AccessibilityAXValueSource `json:"sources,omitempty"`
}

// AccessibilityAXPropertyName Values of AXProperty name:
// - from 'busy' to 'roledescription': states which apply to every AX node
// - from 'live' to 'root': attributes which apply to nodes in live regions
// - from 'autocomplete' to 'valuetext': attributes which apply to widgets
// - from 'checked' to 'selected': states which apply to widgets
// - from 'activedescendant' to 'owns' - relationships between elements other than parent/child/sibling.
type AccessibilityAXPropertyName string

const (
	// AccessibilityAXPropertyNameBusy enum const
	AccessibilityAXPropertyNameBusy AccessibilityAXPropertyName = "busy"

	// AccessibilityAXPropertyNameDisabled enum const
	AccessibilityAXPropertyNameDisabled AccessibilityAXPropertyName = "disabled"

	// AccessibilityAXPropertyNameEditable enum const
	AccessibilityAXPropertyNameEditable AccessibilityAXPropertyName = "editable"

	// AccessibilityAXPropertyNameFocusable enum const
	AccessibilityAXPropertyNameFocusable AccessibilityAXPropertyName = "focusable"

	// AccessibilityAXPropertyNameFocused enum const
	AccessibilityAXPropertyNameFocused AccessibilityAXPropertyName = "focused"

	// AccessibilityAXPropertyNameHidden enum const
	AccessibilityAXPropertyNameHidden AccessibilityAXPropertyName = "hidden"

	// AccessibilityAXPropertyNameHiddenRoot enum const
	AccessibilityAXPropertyNameHiddenRoot AccessibilityAXPropertyName = "hiddenRoot"

	// AccessibilityAXPropertyNameInvalid enum const
	AccessibilityAXPropertyNameInvalid AccessibilityAXPropertyName = "invalid"

	// AccessibilityAXPropertyNameKeyshortcuts enum const
	AccessibilityAXPropertyNameKeyshortcuts AccessibilityAXPropertyName = "keyshortcuts"

	// AccessibilityAXPropertyNameSettable enum const
	AccessibilityAXPropertyNameSettable AccessibilityAXPropertyName = "settable"

	// AccessibilityAXPropertyNameRoledescription enum const
	AccessibilityAXPropertyNameRoledescription AccessibilityAXPropertyName = "roledescription"

	// AccessibilityAXPropertyNameLive enum const
	AccessibilityAXPropertyNameLive AccessibilityAXPropertyName = "live"

	// AccessibilityAXPropertyNameAtomic enum const
	AccessibilityAXPropertyNameAtomic AccessibilityAXPropertyName = "atomic"

	// AccessibilityAXPropertyNameRelevant enum const
	AccessibilityAXPropertyNameRelevant AccessibilityAXPropertyName = "relevant"

	// AccessibilityAXPropertyNameRoot enum const
	AccessibilityAXPropertyNameRoot AccessibilityAXPropertyName = "root"

	// AccessibilityAXPropertyNameAutocomplete enum const
	AccessibilityAXPropertyNameAutocomplete AccessibilityAXPropertyName = "autocomplete"

	// AccessibilityAXPropertyNameHasPopup enum const
	AccessibilityAXPropertyNameHasPopup AccessibilityAXPropertyName = "hasPopup"

	// AccessibilityAXPropertyNameLevel enum const
	AccessibilityAXPropertyNameLevel AccessibilityAXPropertyName = "level"

	// AccessibilityAXPropertyNameMultiselectable enum const
	AccessibilityAXPropertyNameMultiselectable AccessibilityAXPropertyName = "multiselectable"

	// AccessibilityAXPropertyNameOrientation enum const
	AccessibilityAXPropertyNameOrientation AccessibilityAXPropertyName = "orientation"

	// AccessibilityAXPropertyNameMultiline enum const
	AccessibilityAXPropertyNameMultiline AccessibilityAXPropertyName = "multiline"

	// AccessibilityAXPropertyNameReadonly enum const
	AccessibilityAXPropertyNameReadonly AccessibilityAXPropertyName = "readonly"

	// AccessibilityAXPropertyNameRequired enum const
	AccessibilityAXPropertyNameRequired AccessibilityAXPropertyName = "required"

	// AccessibilityAXPropertyNameValuemin enum const
	AccessibilityAXPropertyNameValuemin AccessibilityAXPropertyName = "valuemin"

	// AccessibilityAXPropertyNameValuemax enum const
	AccessibilityAXPropertyNameValuemax AccessibilityAXPropertyName = "valuemax"

	// AccessibilityAXPropertyNameValuetext enum const
	AccessibilityAXPropertyNameValuetext AccessibilityAXPropertyName = "valuetext"

	// AccessibilityAXPropertyNameChecked enum const
	AccessibilityAXPropertyNameChecked AccessibilityAXPropertyName = "checked"

	// AccessibilityAXPropertyNameExpanded enum const
	AccessibilityAXPropertyNameExpanded AccessibilityAXPropertyName = "expanded"

	// AccessibilityAXPropertyNameModal enum const
	AccessibilityAXPropertyNameModal AccessibilityAXPropertyName = "modal"

	// AccessibilityAXPropertyNamePressed enum const
	AccessibilityAXPropertyNamePressed AccessibilityAXPropertyName = "pressed"

	// AccessibilityAXPropertyNameSelected enum const
	AccessibilityAXPropertyNameSelected AccessibilityAXPropertyName = "selected"

	// AccessibilityAXPropertyNameActivedescendant enum const
	AccessibilityAXPropertyNameActivedescendant AccessibilityAXPropertyName = "activedescendant"

	// AccessibilityAXPropertyNameControls enum const
	AccessibilityAXPropertyNameControls AccessibilityAXPropertyName = "controls"

	// AccessibilityAXPropertyNameDescribedby enum const
	AccessibilityAXPropertyNameDescribedby AccessibilityAXPropertyName = "describedby"

	// AccessibilityAXPropertyNameDetails enum const
	AccessibilityAXPropertyNameDetails AccessibilityAXPropertyName = "details"

	// AccessibilityAXPropertyNameErrormessage enum const
	AccessibilityAXPropertyNameErrormessage AccessibilityAXPropertyName = "errormessage"

	// AccessibilityAXPropertyNameFlowto enum const
	AccessibilityAXPropertyNameFlowto AccessibilityAXPropertyName = "flowto"

	// AccessibilityAXPropertyNameLabelledby enum const
	AccessibilityAXPropertyNameLabelledby AccessibilityAXPropertyName = "labelledby"

	// AccessibilityAXPropertyNameOwns enum const
	AccessibilityAXPropertyNameOwns AccessibilityAXPropertyName = "owns"
)

// AccessibilityAXNode A node in the accessibility tree.
type AccessibilityAXNode struct {

	// NodeID Unique identifier for this node.
	NodeID AccessibilityAXNodeID `json:"nodeId"`

	// Ignored Whether this node is ignored for accessibility
	Ignored bool `json:"ignored"`

	// IgnoredReasons (optional) Collection of reasons why this node is hidden.
	IgnoredReasons []*AccessibilityAXProperty `json:"ignoredReasons,omitempty"`

	// Role (optional) This `Node`'s role, whether explicit or implicit.
	Role *AccessibilityAXValue `json:"role,omitempty"`

	// Name (optional) The accessible name for this `Node`.
	Name *AccessibilityAXValue `json:"name,omitempty"`

	// Description (optional) The accessible description for this `Node`.
	Description *AccessibilityAXValue `json:"description,omitempty"`

	// Value (optional) The value for this `Node`.
	Value *AccessibilityAXValue `json:"value,omitempty"`

	// Properties (optional) All other properties
	Properties []*AccessibilityAXProperty `json:"properties,omitempty"`

	// ChildIds (optional) IDs for each of this node's child nodes.
	ChildIds []AccessibilityAXNodeID `json:"childIds,omitempty"`

	// BackendDOMNodeID (optional) The backend ID for the associated DOM node, if any.
	BackendDOMNodeID DOMBackendNodeID `json:"backendDOMNodeId,omitempty"`
}

// AccessibilityDisable Disables the accessibility domain.
type AccessibilityDisable struct {
}

// Call of the command, sessionID is optional.
func (m AccessibilityDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Accessibility.disable", m)
	return err
}

// AccessibilityEnable Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.
// This turns on accessibility for the page, which can impact performance until accessibility is disabled.
type AccessibilityEnable struct {
}

// Call of the command, sessionID is optional.
func (m AccessibilityEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Accessibility.enable", m)
	return err
}

// AccessibilityGetPartialAXTree (experimental) Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.
type AccessibilityGetPartialAXTree struct {

	// NodeID (optional) Identifier of the node to get the partial accessibility tree for.
	NodeID DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID (optional) Identifier of the backend node to get the partial accessibility tree for.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectID (optional) JavaScript object id of the node wrapper to get the partial accessibility tree for.
	ObjectID RuntimeRemoteObjectID `json:"objectId,omitempty"`

	// FetchRelatives (optional) Whether to fetch this nodes ancestors, siblings and children. Defaults to true.
	FetchRelatives bool `json:"fetchRelatives,omitempty"`
}

// Call of the command, sessionID is optional.
func (m AccessibilityGetPartialAXTree) Call(caller Caller) (*AccessibilityGetPartialAXTreeResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Accessibility.getPartialAXTree", m)
	if err != nil {
		return nil, err
	}

	var res AccessibilityGetPartialAXTreeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// AccessibilityGetPartialAXTreeResult (experimental) Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.
type AccessibilityGetPartialAXTreeResult struct {

	// Nodes The `Accessibility.AXNode` for this DOM node, if it exists, plus its ancestors, siblings and
	// children, if requested.
	Nodes []*AccessibilityAXNode `json:"nodes"`
}

// AccessibilityGetFullAXTree (experimental) Fetches the entire accessibility tree
type AccessibilityGetFullAXTree struct {
}

// Call of the command, sessionID is optional.
func (m AccessibilityGetFullAXTree) Call(caller Caller) (*AccessibilityGetFullAXTreeResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Accessibility.getFullAXTree", m)
	if err != nil {
		return nil, err
	}

	var res AccessibilityGetFullAXTreeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// AccessibilityGetFullAXTreeResult (experimental) Fetches the entire accessibility tree
type AccessibilityGetFullAXTreeResult struct {

	// Nodes ...
	Nodes []*AccessibilityAXNode `json:"nodes"`
}

// AnimationAnimationType enum
type AnimationAnimationType string

const (
	// AnimationAnimationTypeCSSTransition enum const
	AnimationAnimationTypeCSSTransition AnimationAnimationType = "CSSTransition"

	// AnimationAnimationTypeCSSAnimation enum const
	AnimationAnimationTypeCSSAnimation AnimationAnimationType = "CSSAnimation"

	// AnimationAnimationTypeWebAnimation enum const
	AnimationAnimationTypeWebAnimation AnimationAnimationType = "WebAnimation"
)

// AnimationAnimation Animation instance.
type AnimationAnimation struct {

	// ID `Animation`'s id.
	ID string `json:"id"`

	// Name `Animation`'s name.
	Name string `json:"name"`

	// PausedState `Animation`'s internal paused state.
	PausedState bool `json:"pausedState"`

	// PlayState `Animation`'s play state.
	PlayState string `json:"playState"`

	// PlaybackRate `Animation`'s playback rate.
	PlaybackRate float64 `json:"playbackRate"`

	// StartTime `Animation`'s start time.
	StartTime float64 `json:"startTime"`

	// CurrentTime `Animation`'s current time.
	CurrentTime float64 `json:"currentTime"`

	// Type Animation type of `Animation`.
	Type AnimationAnimationType `json:"type"`

	// Source (optional) `Animation`'s source animation node.
	Source *AnimationAnimationEffect `json:"source,omitempty"`

	// CSSID (optional) A unique ID for `Animation` representing the sources that triggered this CSS
	// animation/transition.
	CSSID string `json:"cssId,omitempty"`
}

// AnimationAnimationEffect AnimationEffect instance
type AnimationAnimationEffect struct {

	// Delay `AnimationEffect`'s delay.
	Delay float64 `json:"delay"`

	// EndDelay `AnimationEffect`'s end delay.
	EndDelay float64 `json:"endDelay"`

	// IterationStart `AnimationEffect`'s iteration start.
	IterationStart float64 `json:"iterationStart"`

	// Iterations `AnimationEffect`'s iterations.
	Iterations float64 `json:"iterations"`

	// Duration `AnimationEffect`'s iteration duration.
	Duration float64 `json:"duration"`

	// Direction `AnimationEffect`'s playback direction.
	Direction string `json:"direction"`

	// Fill `AnimationEffect`'s fill mode.
	Fill string `json:"fill"`

	// BackendNodeID (optional) `AnimationEffect`'s target node.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// KeyframesRule (optional) `AnimationEffect`'s keyframes.
	KeyframesRule *AnimationKeyframesRule `json:"keyframesRule,omitempty"`

	// Easing `AnimationEffect`'s timing function.
	Easing string `json:"easing"`
}

// AnimationKeyframesRule Keyframes Rule
type AnimationKeyframesRule struct {

	// Name (optional) CSS keyframed animation's name.
	Name string `json:"name,omitempty"`

	// Keyframes List of animation keyframes.
	Keyframes []*AnimationKeyframeStyle `json:"keyframes"`
}

// AnimationKeyframeStyle Keyframe Style
type AnimationKeyframeStyle struct {

	// Offset Keyframe's time offset.
	Offset string `json:"offset"`

	// Easing `AnimationEffect`'s timing function.
	Easing string `json:"easing"`
}

// AnimationDisable Disables animation domain notifications.
type AnimationDisable struct {
}

// Call of the command, sessionID is optional.
func (m AnimationDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Animation.disable", m)
	return err
}

// AnimationEnable Enables animation domain notifications.
type AnimationEnable struct {
}

// Call of the command, sessionID is optional.
func (m AnimationEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Animation.enable", m)
	return err
}

// AnimationGetCurrentTime Returns the current time of the an animation.
type AnimationGetCurrentTime struct {

	// ID Id of animation.
	ID string `json:"id"`
}

// Call of the command, sessionID is optional.
func (m AnimationGetCurrentTime) Call(caller Caller) (*AnimationGetCurrentTimeResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Animation.getCurrentTime", m)
	if err != nil {
		return nil, err
	}

	var res AnimationGetCurrentTimeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// AnimationGetCurrentTimeResult Returns the current time of the an animation.
type AnimationGetCurrentTimeResult struct {

	// CurrentTime Current time of the page.
	CurrentTime float64 `json:"currentTime"`
}

// AnimationGetPlaybackRate Gets the playback rate of the document timeline.
type AnimationGetPlaybackRate struct {
}

// Call of the command, sessionID is optional.
func (m AnimationGetPlaybackRate) Call(caller Caller) (*AnimationGetPlaybackRateResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Animation.getPlaybackRate", m)
	if err != nil {
		return nil, err
	}

	var res AnimationGetPlaybackRateResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// AnimationGetPlaybackRateResult Gets the playback rate of the document timeline.
type AnimationGetPlaybackRateResult struct {

	// PlaybackRate Playback rate for animations on page.
	PlaybackRate float64 `json:"playbackRate"`
}

// AnimationReleaseAnimations Releases a set of animations to no longer be manipulated.
type AnimationReleaseAnimations struct {

	// Animations List of animation ids to seek.
	Animations []string `json:"animations"`
}

// Call of the command, sessionID is optional.
func (m AnimationReleaseAnimations) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Animation.releaseAnimations", m)
	return err
}

// AnimationResolveAnimation Gets the remote object of the Animation.
type AnimationResolveAnimation struct {

	// AnimationID Animation id.
	AnimationID string `json:"animationId"`
}

// Call of the command, sessionID is optional.
func (m AnimationResolveAnimation) Call(caller Caller) (*AnimationResolveAnimationResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Animation.resolveAnimation", m)
	if err != nil {
		return nil, err
	}

	var res AnimationResolveAnimationResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// AnimationResolveAnimationResult Gets the remote object of the Animation.
type AnimationResolveAnimationResult struct {

	// RemoteObject Corresponding remote object.
	RemoteObject *RuntimeRemoteObject `json:"remoteObject"`
}

// AnimationSeekAnimations Seek a set of animations to a particular time within each animation.
type AnimationSeekAnimations struct {

	// Animations List of animation ids to seek.
	Animations []string `json:"animations"`

	// CurrentTime Set the current time of each animation.
	CurrentTime float64 `json:"currentTime"`
}

// Call of the command, sessionID is optional.
func (m AnimationSeekAnimations) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Animation.seekAnimations", m)
	return err
}

// AnimationSetPaused Sets the paused state of a set of animations.
type AnimationSetPaused struct {

	// Animations Animations to set the pause state of.
	Animations []string `json:"animations"`

	// Paused Paused state to set to.
	Paused bool `json:"paused"`
}

// Call of the command, sessionID is optional.
func (m AnimationSetPaused) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Animation.setPaused", m)
	return err
}

// AnimationSetPlaybackRate Sets the playback rate of the document timeline.
type AnimationSetPlaybackRate struct {

	// PlaybackRate Playback rate for animations on page
	PlaybackRate float64 `json:"playbackRate"`
}

// Call of the command, sessionID is optional.
func (m AnimationSetPlaybackRate) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Animation.setPlaybackRate", m)
	return err
}

// AnimationSetTiming Sets the timing of an animation node.
type AnimationSetTiming struct {

	// AnimationID Animation id.
	AnimationID string `json:"animationId"`

	// Duration Duration of the animation.
	Duration float64 `json:"duration"`

	// Delay Delay of the animation.
	Delay float64 `json:"delay"`
}

// Call of the command, sessionID is optional.
func (m AnimationSetTiming) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Animation.setTiming", m)
	return err
}

// AnimationAnimationCanceled Event for when an animation has been cancelled.
type AnimationAnimationCanceled struct {

	// ID Id of the animation that was cancelled.
	ID string `json:"id"`
}

// MethodName interface
func (evt AnimationAnimationCanceled) MethodName() string {
	return "Animation.animationCanceled"
}

// AnimationAnimationCreated Event for each animation that has been created.
type AnimationAnimationCreated struct {

	// ID Id of the animation that was created.
	ID string `json:"id"`
}

// MethodName interface
func (evt AnimationAnimationCreated) MethodName() string {
	return "Animation.animationCreated"
}

// AnimationAnimationStarted Event for animation that has been started.
type AnimationAnimationStarted struct {

	// Animation Animation that was started.
	Animation *AnimationAnimation `json:"animation"`
}

// MethodName interface
func (evt AnimationAnimationStarted) MethodName() string {
	return "Animation.animationStarted"
}

// ApplicationCacheApplicationCacheResource Detailed application cache resource information.
type ApplicationCacheApplicationCacheResource struct {

	// URL Resource url.
	URL string `json:"url"`

	// Size Resource size.
	Size int64 `json:"size"`

	// Type Resource type.
	Type string `json:"type"`
}

// ApplicationCacheApplicationCache Detailed application cache information.
type ApplicationCacheApplicationCache struct {

	// ManifestURL Manifest URL.
	ManifestURL string `json:"manifestURL"`

	// Size Application cache size.
	Size float64 `json:"size"`

	// CreationTime Application cache creation time.
	CreationTime float64 `json:"creationTime"`

	// UpdateTime Application cache update time.
	UpdateTime float64 `json:"updateTime"`

	// Resources Application cache resources.
	Resources []*ApplicationCacheApplicationCacheResource `json:"resources"`
}

// ApplicationCacheFrameWithManifest Frame identifier - manifest URL pair.
type ApplicationCacheFrameWithManifest struct {

	// FrameID Frame identifier.
	FrameID PageFrameID `json:"frameId"`

	// ManifestURL Manifest URL.
	ManifestURL string `json:"manifestURL"`

	// Status Application cache status.
	Status int64 `json:"status"`
}

// ApplicationCacheEnable Enables application cache domain notifications.
type ApplicationCacheEnable struct {
}

// Call of the command, sessionID is optional.
func (m ApplicationCacheEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "ApplicationCache.enable", m)
	return err
}

// ApplicationCacheGetApplicationCacheForFrame Returns relevant application cache data for the document in given frame.
type ApplicationCacheGetApplicationCacheForFrame struct {

	// FrameID Identifier of the frame containing document whose application cache is retrieved.
	FrameID PageFrameID `json:"frameId"`
}

// Call of the command, sessionID is optional.
func (m ApplicationCacheGetApplicationCacheForFrame) Call(caller Caller) (*ApplicationCacheGetApplicationCacheForFrameResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "ApplicationCache.getApplicationCacheForFrame", m)
	if err != nil {
		return nil, err
	}

	var res ApplicationCacheGetApplicationCacheForFrameResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ApplicationCacheGetApplicationCacheForFrameResult Returns relevant application cache data for the document in given frame.
type ApplicationCacheGetApplicationCacheForFrameResult struct {

	// ApplicationCache Relevant application cache data for the document in given frame.
	ApplicationCache *ApplicationCacheApplicationCache `json:"applicationCache"`
}

// ApplicationCacheGetFramesWithManifests Returns array of frame identifiers with manifest urls for each frame containing a document
// associated with some application cache.
type ApplicationCacheGetFramesWithManifests struct {
}

// Call of the command, sessionID is optional.
func (m ApplicationCacheGetFramesWithManifests) Call(caller Caller) (*ApplicationCacheGetFramesWithManifestsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "ApplicationCache.getFramesWithManifests", m)
	if err != nil {
		return nil, err
	}

	var res ApplicationCacheGetFramesWithManifestsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ApplicationCacheGetFramesWithManifestsResult Returns array of frame identifiers with manifest urls for each frame containing a document
// associated with some application cache.
type ApplicationCacheGetFramesWithManifestsResult struct {

	// FrameIds Array of frame identifiers with manifest urls for each frame containing a document
	// associated with some application cache.
	FrameIds []*ApplicationCacheFrameWithManifest `json:"frameIds"`
}

// ApplicationCacheGetManifestForFrame Returns manifest URL for document in the given frame.
type ApplicationCacheGetManifestForFrame struct {

	// FrameID Identifier of the frame containing document whose manifest is retrieved.
	FrameID PageFrameID `json:"frameId"`
}

// Call of the command, sessionID is optional.
func (m ApplicationCacheGetManifestForFrame) Call(caller Caller) (*ApplicationCacheGetManifestForFrameResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "ApplicationCache.getManifestForFrame", m)
	if err != nil {
		return nil, err
	}

	var res ApplicationCacheGetManifestForFrameResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ApplicationCacheGetManifestForFrameResult Returns manifest URL for document in the given frame.
type ApplicationCacheGetManifestForFrameResult struct {

	// ManifestURL Manifest URL for document in the given frame.
	ManifestURL string `json:"manifestURL"`
}

// ApplicationCacheApplicationCacheStatusUpdated ...
type ApplicationCacheApplicationCacheStatusUpdated struct {

	// FrameID Identifier of the frame containing document whose application cache updated status.
	FrameID PageFrameID `json:"frameId"`

	// ManifestURL Manifest URL.
	ManifestURL string `json:"manifestURL"`

	// Status Updated application cache status.
	Status int64 `json:"status"`
}

// MethodName interface
func (evt ApplicationCacheApplicationCacheStatusUpdated) MethodName() string {
	return "ApplicationCache.applicationCacheStatusUpdated"
}

// ApplicationCacheNetworkStateUpdated ...
type ApplicationCacheNetworkStateUpdated struct {

	// IsNowOnline ...
	IsNowOnline bool `json:"isNowOnline"`
}

// MethodName interface
func (evt ApplicationCacheNetworkStateUpdated) MethodName() string {
	return "ApplicationCache.networkStateUpdated"
}

// AuditsGetEncodedResponseEncoding enum
type AuditsGetEncodedResponseEncoding string

const (
	// AuditsGetEncodedResponseEncodingWebp enum const
	AuditsGetEncodedResponseEncodingWebp AuditsGetEncodedResponseEncoding = "webp"

	// AuditsGetEncodedResponseEncodingJpeg enum const
	AuditsGetEncodedResponseEncodingJpeg AuditsGetEncodedResponseEncoding = "jpeg"

	// AuditsGetEncodedResponseEncodingPng enum const
	AuditsGetEncodedResponseEncodingPng AuditsGetEncodedResponseEncoding = "png"
)

// AuditsGetEncodedResponse Returns the response body and size if it were re-encoded with the specified settings. Only
// applies to images.
type AuditsGetEncodedResponse struct {

	// RequestID Identifier of the network request to get content for.
	RequestID NetworkRequestID `json:"requestId"`

	// Encoding The encoding to use.
	Encoding AuditsGetEncodedResponseEncoding `json:"encoding"`

	// Quality (optional) The quality of the encoding (0-1). (defaults to 1)
	Quality float64 `json:"quality,omitempty"`

	// SizeOnly (optional) Whether to only return the size information (defaults to false).
	SizeOnly bool `json:"sizeOnly,omitempty"`
}

// Call of the command, sessionID is optional.
func (m AuditsGetEncodedResponse) Call(caller Caller) (*AuditsGetEncodedResponseResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Audits.getEncodedResponse", m)
	if err != nil {
		return nil, err
	}

	var res AuditsGetEncodedResponseResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// AuditsGetEncodedResponseResult Returns the response body and size if it were re-encoded with the specified settings. Only
// applies to images.
type AuditsGetEncodedResponseResult struct {

	// Body (optional) The encoded body as a base64 string. Omitted if sizeOnly is true.
	Body []byte `json:"body,omitempty"`

	// OriginalSize Size before re-encoding.
	OriginalSize int64 `json:"originalSize"`

	// EncodedSize Size after re-encoding.
	EncodedSize int64 `json:"encodedSize"`
}

// BackgroundServiceServiceName The Background Service that will be associated with the commands/events.
// Every Background Service operates independently, but they share the same
// API.
type BackgroundServiceServiceName string

const (
	// BackgroundServiceServiceNameBackgroundFetch enum const
	BackgroundServiceServiceNameBackgroundFetch BackgroundServiceServiceName = "backgroundFetch"

	// BackgroundServiceServiceNameBackgroundSync enum const
	BackgroundServiceServiceNameBackgroundSync BackgroundServiceServiceName = "backgroundSync"

	// BackgroundServiceServiceNamePushMessaging enum const
	BackgroundServiceServiceNamePushMessaging BackgroundServiceServiceName = "pushMessaging"

	// BackgroundServiceServiceNameNotifications enum const
	BackgroundServiceServiceNameNotifications BackgroundServiceServiceName = "notifications"

	// BackgroundServiceServiceNamePaymentHandler enum const
	BackgroundServiceServiceNamePaymentHandler BackgroundServiceServiceName = "paymentHandler"

	// BackgroundServiceServiceNamePeriodicBackgroundSync enum const
	BackgroundServiceServiceNamePeriodicBackgroundSync BackgroundServiceServiceName = "periodicBackgroundSync"
)

// BackgroundServiceEventMetadata A key-value pair for additional event information to pass along.
type BackgroundServiceEventMetadata struct {

	// Key ...
	Key string `json:"key"`

	// Value ...
	Value string `json:"value"`
}

// BackgroundServiceBackgroundServiceEvent ...
type BackgroundServiceBackgroundServiceEvent struct {

	// Timestamp Timestamp of the event (in seconds).
	Timestamp NetworkTimeSinceEpoch `json:"timestamp"`

	// Origin The origin this event belongs to.
	Origin string `json:"origin"`

	// ServiceWorkerRegistrationID The Service Worker ID that initiated the event.
	ServiceWorkerRegistrationID ServiceWorkerRegistrationID `json:"serviceWorkerRegistrationId"`

	// Service The Background Service this event belongs to.
	Service BackgroundServiceServiceName `json:"service"`

	// EventName A description of the event.
	EventName string `json:"eventName"`

	// InstanceID An identifier that groups related events together.
	InstanceID string `json:"instanceId"`

	// EventMetadata A list of event-specific information.
	EventMetadata []*BackgroundServiceEventMetadata `json:"eventMetadata"`
}

// BackgroundServiceStartObserving Enables event updates for the service.
type BackgroundServiceStartObserving struct {

	// Service ...
	Service BackgroundServiceServiceName `json:"service"`
}

// Call of the command, sessionID is optional.
func (m BackgroundServiceStartObserving) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "BackgroundService.startObserving", m)
	return err
}

// BackgroundServiceStopObserving Disables event updates for the service.
type BackgroundServiceStopObserving struct {

	// Service ...
	Service BackgroundServiceServiceName `json:"service"`
}

// Call of the command, sessionID is optional.
func (m BackgroundServiceStopObserving) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "BackgroundService.stopObserving", m)
	return err
}

// BackgroundServiceSetRecording Set the recording state for the service.
type BackgroundServiceSetRecording struct {

	// ShouldRecord ...
	ShouldRecord bool `json:"shouldRecord"`

	// Service ...
	Service BackgroundServiceServiceName `json:"service"`
}

// Call of the command, sessionID is optional.
func (m BackgroundServiceSetRecording) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "BackgroundService.setRecording", m)
	return err
}

// BackgroundServiceClearEvents Clears all stored data for the service.
type BackgroundServiceClearEvents struct {

	// Service ...
	Service BackgroundServiceServiceName `json:"service"`
}

// Call of the command, sessionID is optional.
func (m BackgroundServiceClearEvents) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "BackgroundService.clearEvents", m)
	return err
}

// BackgroundServiceRecordingStateChanged Called when the recording state for the service has been updated.
type BackgroundServiceRecordingStateChanged struct {

	// IsRecording ...
	IsRecording bool `json:"isRecording"`

	// Service ...
	Service BackgroundServiceServiceName `json:"service"`
}

// MethodName interface
func (evt BackgroundServiceRecordingStateChanged) MethodName() string {
	return "BackgroundService.recordingStateChanged"
}

// BackgroundServiceBackgroundServiceEventReceived Called with all existing backgroundServiceEvents when enabled, and all new
// events afterwards if enabled and recording.
type BackgroundServiceBackgroundServiceEventReceived struct {

	// BackgroundServiceEvent ...
	BackgroundServiceEvent *BackgroundServiceBackgroundServiceEvent `json:"backgroundServiceEvent"`
}

// MethodName interface
func (evt BackgroundServiceBackgroundServiceEventReceived) MethodName() string {
	return "BackgroundService.backgroundServiceEventReceived"
}

// BrowserBrowserContextID (experimental) ...
type BrowserBrowserContextID string

// BrowserWindowID (experimental) ...
type BrowserWindowID int64

// BrowserWindowState (experimental) The state of the browser window.
type BrowserWindowState string

const (
	// BrowserWindowStateNormal enum const
	BrowserWindowStateNormal BrowserWindowState = "normal"

	// BrowserWindowStateMinimized enum const
	BrowserWindowStateMinimized BrowserWindowState = "minimized"

	// BrowserWindowStateMaximized enum const
	BrowserWindowStateMaximized BrowserWindowState = "maximized"

	// BrowserWindowStateFullscreen enum const
	BrowserWindowStateFullscreen BrowserWindowState = "fullscreen"
)

// BrowserBounds (experimental) Browser window bounds information
type BrowserBounds struct {

	// Left (optional) The offset from the left edge of the screen to the window in pixels.
	Left int64 `json:"left,omitempty"`

	// Top (optional) The offset from the top edge of the screen to the window in pixels.
	Top int64 `json:"top,omitempty"`

	// Width (optional) The window width in pixels.
	Width int64 `json:"width,omitempty"`

	// Height (optional) The window height in pixels.
	Height int64 `json:"height,omitempty"`

	// WindowState (optional) The window state. Default to normal.
	WindowState BrowserWindowState `json:"windowState,omitempty"`
}

// BrowserPermissionType (experimental) ...
type BrowserPermissionType string

const (
	// BrowserPermissionTypeAccessibilityEvents enum const
	BrowserPermissionTypeAccessibilityEvents BrowserPermissionType = "accessibilityEvents"

	// BrowserPermissionTypeAudioCapture enum const
	BrowserPermissionTypeAudioCapture BrowserPermissionType = "audioCapture"

	// BrowserPermissionTypeBackgroundSync enum const
	BrowserPermissionTypeBackgroundSync BrowserPermissionType = "backgroundSync"

	// BrowserPermissionTypeBackgroundFetch enum const
	BrowserPermissionTypeBackgroundFetch BrowserPermissionType = "backgroundFetch"

	// BrowserPermissionTypeClipboardReadWrite enum const
	BrowserPermissionTypeClipboardReadWrite BrowserPermissionType = "clipboardReadWrite"

	// BrowserPermissionTypeClipboardSanitizedWrite enum const
	BrowserPermissionTypeClipboardSanitizedWrite BrowserPermissionType = "clipboardSanitizedWrite"

	// BrowserPermissionTypeDurableStorage enum const
	BrowserPermissionTypeDurableStorage BrowserPermissionType = "durableStorage"

	// BrowserPermissionTypeFlash enum const
	BrowserPermissionTypeFlash BrowserPermissionType = "flash"

	// BrowserPermissionTypeGeolocation enum const
	BrowserPermissionTypeGeolocation BrowserPermissionType = "geolocation"

	// BrowserPermissionTypeMidi enum const
	BrowserPermissionTypeMidi BrowserPermissionType = "midi"

	// BrowserPermissionTypeMidiSysex enum const
	BrowserPermissionTypeMidiSysex BrowserPermissionType = "midiSysex"

	// BrowserPermissionTypeNfc enum const
	BrowserPermissionTypeNfc BrowserPermissionType = "nfc"

	// BrowserPermissionTypeNotifications enum const
	BrowserPermissionTypeNotifications BrowserPermissionType = "notifications"

	// BrowserPermissionTypePaymentHandler enum const
	BrowserPermissionTypePaymentHandler BrowserPermissionType = "paymentHandler"

	// BrowserPermissionTypePeriodicBackgroundSync enum const
	BrowserPermissionTypePeriodicBackgroundSync BrowserPermissionType = "periodicBackgroundSync"

	// BrowserPermissionTypeProtectedMediaIdentifier enum const
	BrowserPermissionTypeProtectedMediaIdentifier BrowserPermissionType = "protectedMediaIdentifier"

	// BrowserPermissionTypeSensors enum const
	BrowserPermissionTypeSensors BrowserPermissionType = "sensors"

	// BrowserPermissionTypeVideoCapture enum const
	BrowserPermissionTypeVideoCapture BrowserPermissionType = "videoCapture"

	// BrowserPermissionTypeIdleDetection enum const
	BrowserPermissionTypeIdleDetection BrowserPermissionType = "idleDetection"

	// BrowserPermissionTypeWakeLockScreen enum const
	BrowserPermissionTypeWakeLockScreen BrowserPermissionType = "wakeLockScreen"

	// BrowserPermissionTypeWakeLockSystem enum const
	BrowserPermissionTypeWakeLockSystem BrowserPermissionType = "wakeLockSystem"
)

// BrowserPermissionSetting (experimental) ...
type BrowserPermissionSetting string

const (
	// BrowserPermissionSettingGranted enum const
	BrowserPermissionSettingGranted BrowserPermissionSetting = "granted"

	// BrowserPermissionSettingDenied enum const
	BrowserPermissionSettingDenied BrowserPermissionSetting = "denied"

	// BrowserPermissionSettingPrompt enum const
	BrowserPermissionSettingPrompt BrowserPermissionSetting = "prompt"
)

// BrowserPermissionDescriptor (experimental) Definition of PermissionDescriptor defined in the Permissions API:
// https://w3c.github.io/permissions/#dictdef-permissiondescriptor.
type BrowserPermissionDescriptor struct {

	// Name Name of permission.
	// See https://cs.chromium.org/chromium/src/third_party/blink/renderer/modules/permissions/permission_descriptor.idl for valid permission names.
	Name string `json:"name"`

	// Sysex (optional) For "midi" permission, may also specify sysex control.
	Sysex bool `json:"sysex,omitempty"`

	// UserVisibleOnly (optional) For "push" permission, may specify userVisibleOnly.
	// Note that userVisibleOnly = true is the only currently supported type.
	UserVisibleOnly bool `json:"userVisibleOnly,omitempty"`

	// Type (optional) For "wake-lock" permission, must specify type as either "screen" or "system".
	Type string `json:"type,omitempty"`

	// AllowWithoutSanitization (optional) For "clipboard" permission, may specify allowWithoutSanitization.
	AllowWithoutSanitization bool `json:"allowWithoutSanitization,omitempty"`
}

// BrowserBucket (experimental) Chrome histogram bucket.
type BrowserBucket struct {

	// Low Minimum value (inclusive).
	Low int64 `json:"low"`

	// High Maximum value (exclusive).
	High int64 `json:"high"`

	// Count Number of samples.
	Count int64 `json:"count"`
}

// BrowserHistogram (experimental) Chrome histogram.
type BrowserHistogram struct {

	// Name Name.
	Name string `json:"name"`

	// Sum Sum of sample values.
	Sum int64 `json:"sum"`

	// Count Total number of samples.
	Count int64 `json:"count"`

	// Buckets Buckets.
	Buckets []*BrowserBucket `json:"buckets"`
}

// BrowserSetPermission (experimental) Set permission settings for given origin.
type BrowserSetPermission struct {

	// Origin Origin the permission applies to.
	Origin string `json:"origin"`

	// Permission Descriptor of permission to override.
	Permission *BrowserPermissionDescriptor `json:"permission"`

	// Setting Setting of the permission.
	Setting BrowserPermissionSetting `json:"setting"`

	// BrowserContextID (optional) Context to override. When omitted, default browser context is used.
	BrowserContextID BrowserBrowserContextID `json:"browserContextId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m BrowserSetPermission) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Browser.setPermission", m)
	return err
}

// BrowserGrantPermissions (experimental) Grant specific permissions to the given origin and reject all others.
type BrowserGrantPermissions struct {

	// Origin ...
	Origin string `json:"origin"`

	// Permissions ...
	Permissions []BrowserPermissionType `json:"permissions"`

	// BrowserContextID (optional) BrowserContext to override permissions. When omitted, default browser context is used.
	BrowserContextID BrowserBrowserContextID `json:"browserContextId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m BrowserGrantPermissions) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Browser.grantPermissions", m)
	return err
}

// BrowserResetPermissions (experimental) Reset all permission management for all origins.
type BrowserResetPermissions struct {

	// BrowserContextID (optional) BrowserContext to reset permissions. When omitted, default browser context is used.
	BrowserContextID BrowserBrowserContextID `json:"browserContextId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m BrowserResetPermissions) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Browser.resetPermissions", m)
	return err
}

// BrowserClose Close browser gracefully.
type BrowserClose struct {
}

// Call of the command, sessionID is optional.
func (m BrowserClose) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Browser.close", m)
	return err
}

// BrowserCrash (experimental) Crashes browser on the main thread.
type BrowserCrash struct {
}

// Call of the command, sessionID is optional.
func (m BrowserCrash) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Browser.crash", m)
	return err
}

// BrowserCrashGpuProcess (experimental) Crashes GPU process.
type BrowserCrashGpuProcess struct {
}

// Call of the command, sessionID is optional.
func (m BrowserCrashGpuProcess) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Browser.crashGpuProcess", m)
	return err
}

// BrowserGetVersion Returns version information.
type BrowserGetVersion struct {
}

// Call of the command, sessionID is optional.
func (m BrowserGetVersion) Call(caller Caller) (*BrowserGetVersionResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Browser.getVersion", m)
	if err != nil {
		return nil, err
	}

	var res BrowserGetVersionResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// BrowserGetVersionResult Returns version information.
type BrowserGetVersionResult struct {

	// ProtocolVersion Protocol version.
	ProtocolVersion string `json:"protocolVersion"`

	// Product Product name.
	Product string `json:"product"`

	// Revision Product revision.
	Revision string `json:"revision"`

	// UserAgent User-Agent.
	UserAgent string `json:"userAgent"`

	// JsVersion V8 version.
	JsVersion string `json:"jsVersion"`
}

// BrowserGetBrowserCommandLine (experimental) Returns the command line switches for the browser process if, and only if
// --enable-automation is on the commandline.
type BrowserGetBrowserCommandLine struct {
}

// Call of the command, sessionID is optional.
func (m BrowserGetBrowserCommandLine) Call(caller Caller) (*BrowserGetBrowserCommandLineResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Browser.getBrowserCommandLine", m)
	if err != nil {
		return nil, err
	}

	var res BrowserGetBrowserCommandLineResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// BrowserGetBrowserCommandLineResult (experimental) Returns the command line switches for the browser process if, and only if
// --enable-automation is on the commandline.
type BrowserGetBrowserCommandLineResult struct {

	// Arguments Commandline parameters
	Arguments []string `json:"arguments"`
}

// BrowserGetHistograms (experimental) Get Chrome histograms.
type BrowserGetHistograms struct {

	// Query (optional) Requested substring in name. Only histograms which have query as a
	// substring in their name are extracted. An empty or absent query returns
	// all histograms.
	Query string `json:"query,omitempty"`

	// Delta (optional) If true, retrieve delta since last call.
	Delta bool `json:"delta,omitempty"`
}

// Call of the command, sessionID is optional.
func (m BrowserGetHistograms) Call(caller Caller) (*BrowserGetHistogramsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Browser.getHistograms", m)
	if err != nil {
		return nil, err
	}

	var res BrowserGetHistogramsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// BrowserGetHistogramsResult (experimental) Get Chrome histograms.
type BrowserGetHistogramsResult struct {

	// Histograms Histograms.
	Histograms []*BrowserHistogram `json:"histograms"`
}

// BrowserGetHistogram (experimental) Get a Chrome histogram by name.
type BrowserGetHistogram struct {

	// Name Requested histogram name.
	Name string `json:"name"`

	// Delta (optional) If true, retrieve delta since last call.
	Delta bool `json:"delta,omitempty"`
}

// Call of the command, sessionID is optional.
func (m BrowserGetHistogram) Call(caller Caller) (*BrowserGetHistogramResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Browser.getHistogram", m)
	if err != nil {
		return nil, err
	}

	var res BrowserGetHistogramResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// BrowserGetHistogramResult (experimental) Get a Chrome histogram by name.
type BrowserGetHistogramResult struct {

	// Histogram Histogram.
	Histogram *BrowserHistogram `json:"histogram"`
}

// BrowserGetWindowBounds (experimental) Get position and size of the browser window.
type BrowserGetWindowBounds struct {

	// WindowID Browser window id.
	WindowID BrowserWindowID `json:"windowId"`
}

// Call of the command, sessionID is optional.
func (m BrowserGetWindowBounds) Call(caller Caller) (*BrowserGetWindowBoundsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Browser.getWindowBounds", m)
	if err != nil {
		return nil, err
	}

	var res BrowserGetWindowBoundsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// BrowserGetWindowBoundsResult (experimental) Get position and size of the browser window.
type BrowserGetWindowBoundsResult struct {

	// Bounds Bounds information of the window. When window state is 'minimized', the restored window
	// position and size are returned.
	Bounds *BrowserBounds `json:"bounds"`
}

// BrowserGetWindowForTarget (experimental) Get the browser window that contains the devtools target.
type BrowserGetWindowForTarget struct {

	// TargetID (optional) Devtools agent host id. If called as a part of the session, associated targetId is used.
	TargetID TargetTargetID `json:"targetId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m BrowserGetWindowForTarget) Call(caller Caller) (*BrowserGetWindowForTargetResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Browser.getWindowForTarget", m)
	if err != nil {
		return nil, err
	}

	var res BrowserGetWindowForTargetResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// BrowserGetWindowForTargetResult (experimental) Get the browser window that contains the devtools target.
type BrowserGetWindowForTargetResult struct {

	// WindowID Browser window id.
	WindowID BrowserWindowID `json:"windowId"`

	// Bounds Bounds information of the window. When window state is 'minimized', the restored window
	// position and size are returned.
	Bounds *BrowserBounds `json:"bounds"`
}

// BrowserSetWindowBounds (experimental) Set position and/or size of the browser window.
type BrowserSetWindowBounds struct {

	// WindowID Browser window id.
	WindowID BrowserWindowID `json:"windowId"`

	// Bounds New window bounds. The 'minimized', 'maximized' and 'fullscreen' states cannot be combined
	// with 'left', 'top', 'width' or 'height'. Leaves unspecified fields unchanged.
	Bounds *BrowserBounds `json:"bounds"`
}

// Call of the command, sessionID is optional.
func (m BrowserSetWindowBounds) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Browser.setWindowBounds", m)
	return err
}

// BrowserSetDockTile (experimental) Set dock tile details, platform-specific.
type BrowserSetDockTile struct {

	// BadgeLabel (optional) ...
	BadgeLabel string `json:"badgeLabel,omitempty"`

	// Image (optional) Png encoded image.
	Image []byte `json:"image,omitempty"`
}

// Call of the command, sessionID is optional.
func (m BrowserSetDockTile) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Browser.setDockTile", m)
	return err
}

// CSSStyleSheetID ...
type CSSStyleSheetID string

// CSSStyleSheetOrigin Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent
// stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via
// inspector" rules), "regular" for regular stylesheets.
type CSSStyleSheetOrigin string

const (
	// CSSStyleSheetOriginInjected enum const
	CSSStyleSheetOriginInjected CSSStyleSheetOrigin = "injected"

	// CSSStyleSheetOriginUserAgent enum const
	CSSStyleSheetOriginUserAgent CSSStyleSheetOrigin = "user-agent"

	// CSSStyleSheetOriginInspector enum const
	CSSStyleSheetOriginInspector CSSStyleSheetOrigin = "inspector"

	// CSSStyleSheetOriginRegular enum const
	CSSStyleSheetOriginRegular CSSStyleSheetOrigin = "regular"
)

// CSSPseudoElementMatches CSS rule collection for a single pseudo style.
type CSSPseudoElementMatches struct {

	// PseudoType Pseudo element type.
	PseudoType DOMPseudoType `json:"pseudoType"`

	// Matches Matches of CSS rules applicable to the pseudo style.
	Matches []*CSSRuleMatch `json:"matches"`
}

// CSSInheritedStyleEntry Inherited CSS rule collection from ancestor node.
type CSSInheritedStyleEntry struct {

	// InlineStyle (optional) The ancestor node's inline style, if any, in the style inheritance chain.
	InlineStyle *CSSCSSStyle `json:"inlineStyle,omitempty"`

	// MatchedCSSRules Matches of CSS rules matching the ancestor node in the style inheritance chain.
	MatchedCSSRules []*CSSRuleMatch `json:"matchedCSSRules"`
}

// CSSRuleMatch Match data for a CSS rule.
type CSSRuleMatch struct {

	// Rule CSS rule in the match.
	Rule *CSSCSSRule `json:"rule"`

	// MatchingSelectors Matching selector indices in the rule's selectorList selectors (0-based).
	MatchingSelectors []int64 `json:"matchingSelectors"`
}

// CSSValue Data for a simple selector (these are delimited by commas in a selector list).
type CSSValue struct {

	// Text Value text.
	Text string `json:"text"`

	// Range (optional) Value range in the underlying resource (if available).
	Range *CSSSourceRange `json:"range,omitempty"`
}

// CSSSelectorList Selector list data.
type CSSSelectorList struct {

	// Selectors Selectors in the list.
	Selectors []*CSSValue `json:"selectors"`

	// Text Rule selector text.
	Text string `json:"text"`
}

// CSSCSSStyleSheetHeader CSS stylesheet metainformation.
type CSSCSSStyleSheetHeader struct {

	// StyleSheetID The stylesheet identifier.
	StyleSheetID CSSStyleSheetID `json:"styleSheetId"`

	// FrameID Owner frame identifier.
	FrameID PageFrameID `json:"frameId"`

	// SourceURL Stylesheet resource URL.
	SourceURL string `json:"sourceURL"`

	// SourceMapURL (optional) URL of source map associated with the stylesheet (if any).
	SourceMapURL string `json:"sourceMapURL,omitempty"`

	// Origin Stylesheet origin.
	Origin CSSStyleSheetOrigin `json:"origin"`

	// Title Stylesheet title.
	Title string `json:"title"`

	// OwnerNode (optional) The backend id for the owner node of the stylesheet.
	OwnerNode DOMBackendNodeID `json:"ownerNode,omitempty"`

	// Disabled Denotes whether the stylesheet is disabled.
	Disabled bool `json:"disabled"`

	// HasSourceURL (optional) Whether the sourceURL field value comes from the sourceURL comment.
	HasSourceURL bool `json:"hasSourceURL,omitempty"`

	// IsInline Whether this stylesheet is created for STYLE tag by parser. This flag is not set for
	// document.written STYLE tags.
	IsInline bool `json:"isInline"`

	// StartLine Line offset of the stylesheet within the resource (zero based).
	StartLine float64 `json:"startLine"`

	// StartColumn Column offset of the stylesheet within the resource (zero based).
	StartColumn float64 `json:"startColumn"`

	// Length Size of the content (in characters).
	Length float64 `json:"length"`

	// EndLine Line offset of the end of the stylesheet within the resource (zero based).
	EndLine float64 `json:"endLine"`

	// EndColumn Column offset of the end of the stylesheet within the resource (zero based).
	EndColumn float64 `json:"endColumn"`
}

// CSSCSSRule CSS rule representation.
type CSSCSSRule struct {

	// StyleSheetID (optional) The css style sheet identifier (absent for user agent stylesheet and user-specified
	// stylesheet rules) this rule came from.
	StyleSheetID CSSStyleSheetID `json:"styleSheetId,omitempty"`

	// SelectorList Rule selector data.
	SelectorList *CSSSelectorList `json:"selectorList"`

	// Origin Parent stylesheet's origin.
	Origin CSSStyleSheetOrigin `json:"origin"`

	// Style Associated style declaration.
	Style *CSSCSSStyle `json:"style"`

	// Media (optional) Media list array (for rules involving media queries). The array enumerates media queries
	// starting with the innermost one, going outwards.
	Media []*CSSCSSMedia `json:"media,omitempty"`
}

// CSSRuleUsage CSS coverage information.
type CSSRuleUsage struct {

	// StyleSheetID The css style sheet identifier (absent for user agent stylesheet and user-specified
	// stylesheet rules) this rule came from.
	StyleSheetID CSSStyleSheetID `json:"styleSheetId"`

	// StartOffset Offset of the start of the rule (including selector) from the beginning of the stylesheet.
	StartOffset float64 `json:"startOffset"`

	// EndOffset Offset of the end of the rule body from the beginning of the stylesheet.
	EndOffset float64 `json:"endOffset"`

	// Used Indicates whether the rule was actually used by some element in the page.
	Used bool `json:"used"`
}

// CSSSourceRange Text range within a resource. All numbers are zero-based.
type CSSSourceRange struct {

	// StartLine Start line of range.
	StartLine int64 `json:"startLine"`

	// StartColumn Start column of range (inclusive).
	StartColumn int64 `json:"startColumn"`

	// EndLine End line of range
	EndLine int64 `json:"endLine"`

	// EndColumn End column of range (exclusive).
	EndColumn int64 `json:"endColumn"`
}

// CSSShorthandEntry ...
type CSSShorthandEntry struct {

	// Name Shorthand name.
	Name string `json:"name"`

	// Value Shorthand value.
	Value string `json:"value"`

	// Important (optional) Whether the property has "!important" annotation (implies `false` if absent).
	Important bool `json:"important,omitempty"`
}

// CSSCSSComputedStyleProperty ...
type CSSCSSComputedStyleProperty struct {

	// Name Computed style property name.
	Name string `json:"name"`

	// Value Computed style property value.
	Value string `json:"value"`
}

// CSSCSSStyle CSS style representation.
type CSSCSSStyle struct {

	// StyleSheetID (optional) The css style sheet identifier (absent for user agent stylesheet and user-specified
	// stylesheet rules) this rule came from.
	StyleSheetID CSSStyleSheetID `json:"styleSheetId,omitempty"`

	// CSSProperties CSS properties in the style.
	CSSProperties []*CSSCSSProperty `json:"cssProperties"`

	// ShorthandEntries Computed values for all shorthands found in the style.
	ShorthandEntries []*CSSShorthandEntry `json:"shorthandEntries"`

	// CSSText (optional) Style declaration text (if available).
	CSSText string `json:"cssText,omitempty"`

	// Range (optional) Style declaration range in the enclosing stylesheet (if available).
	Range *CSSSourceRange `json:"range,omitempty"`
}

// CSSCSSProperty CSS property declaration data.
type CSSCSSProperty struct {

	// Name The property name.
	Name string `json:"name"`

	// Value The property value.
	Value string `json:"value"`

	// Important (optional) Whether the property has "!important" annotation (implies `false` if absent).
	Important bool `json:"important,omitempty"`

	// Implicit (optional) Whether the property is implicit (implies `false` if absent).
	Implicit bool `json:"implicit,omitempty"`

	// Text (optional) The full property text as specified in the style.
	Text string `json:"text,omitempty"`

	// ParsedOk (optional) Whether the property is understood by the browser (implies `true` if absent).
	ParsedOk bool `json:"parsedOk,omitempty"`

	// Disabled (optional) Whether the property is disabled by the user (present for source-based properties only).
	Disabled bool `json:"disabled,omitempty"`

	// Range (optional) The entire property range in the enclosing style declaration (if available).
	Range *CSSSourceRange `json:"range,omitempty"`
}

// CSSCSSMediaSource enum
type CSSCSSMediaSource string

const (
	// CSSCSSMediaSourceMediaRule enum const
	CSSCSSMediaSourceMediaRule CSSCSSMediaSource = "mediaRule"

	// CSSCSSMediaSourceImportRule enum const
	CSSCSSMediaSourceImportRule CSSCSSMediaSource = "importRule"

	// CSSCSSMediaSourceLinkedSheet enum const
	CSSCSSMediaSourceLinkedSheet CSSCSSMediaSource = "linkedSheet"

	// CSSCSSMediaSourceInlineSheet enum const
	CSSCSSMediaSourceInlineSheet CSSCSSMediaSource = "inlineSheet"
)

// CSSCSSMedia CSS media rule descriptor.
type CSSCSSMedia struct {

	// Text Media query text.
	Text string `json:"text"`

	// Source Source of the media query: "mediaRule" if specified by a @media rule, "importRule" if
	// specified by an @import rule, "linkedSheet" if specified by a "media" attribute in a linked
	// stylesheet's LINK tag, "inlineSheet" if specified by a "media" attribute in an inline
	// stylesheet's STYLE tag.
	Source CSSCSSMediaSource `json:"source"`

	// SourceURL (optional) URL of the document containing the media query description.
	SourceURL string `json:"sourceURL,omitempty"`

	// Range (optional) The associated rule (@media or @import) header range in the enclosing stylesheet (if
	// available).
	Range *CSSSourceRange `json:"range,omitempty"`

	// StyleSheetID (optional) Identifier of the stylesheet containing this object (if exists).
	StyleSheetID CSSStyleSheetID `json:"styleSheetId,omitempty"`

	// MediaList (optional) Array of media queries.
	MediaList []*CSSMediaQuery `json:"mediaList,omitempty"`
}

// CSSMediaQuery Media query descriptor.
type CSSMediaQuery struct {

	// Expressions Array of media query expressions.
	Expressions []*CSSMediaQueryExpression `json:"expressions"`

	// Active Whether the media query condition is satisfied.
	Active bool `json:"active"`
}

// CSSMediaQueryExpression Media query expression descriptor.
type CSSMediaQueryExpression struct {

	// Value Media query expression value.
	Value float64 `json:"value"`

	// Unit Media query expression units.
	Unit string `json:"unit"`

	// Feature Media query expression feature.
	Feature string `json:"feature"`

	// ValueRange (optional) The associated range of the value text in the enclosing stylesheet (if available).
	ValueRange *CSSSourceRange `json:"valueRange,omitempty"`

	// ComputedLength (optional) Computed length of media query expression (if applicable).
	ComputedLength float64 `json:"computedLength,omitempty"`
}

// CSSPlatformFontUsage Information about amount of glyphs that were rendered with given font.
type CSSPlatformFontUsage struct {

	// FamilyName Font's family name reported by platform.
	FamilyName string `json:"familyName"`

	// IsCustomFont Indicates if the font was downloaded or resolved locally.
	IsCustomFont bool `json:"isCustomFont"`

	// GlyphCount Amount of glyphs that were rendered with this font.
	GlyphCount float64 `json:"glyphCount"`
}

// CSSFontFace Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions
type CSSFontFace struct {

	// FontFamily The font-family.
	FontFamily string `json:"fontFamily"`

	// FontStyle The font-style.
	FontStyle string `json:"fontStyle"`

	// FontVariant The font-variant.
	FontVariant string `json:"fontVariant"`

	// FontWeight The font-weight.
	FontWeight string `json:"fontWeight"`

	// FontStretch The font-stretch.
	FontStretch string `json:"fontStretch"`

	// UnicodeRange The unicode-range.
	UnicodeRange string `json:"unicodeRange"`

	// Src The src.
	Src string `json:"src"`

	// PlatformFontFamily The resolved platform font family
	PlatformFontFamily string `json:"platformFontFamily"`
}

// CSSCSSKeyframesRule CSS keyframes rule representation.
type CSSCSSKeyframesRule struct {

	// AnimationName Animation name.
	AnimationName *CSSValue `json:"animationName"`

	// Keyframes List of keyframes.
	Keyframes []*CSSCSSKeyframeRule `json:"keyframes"`
}

// CSSCSSKeyframeRule CSS keyframe rule representation.
type CSSCSSKeyframeRule struct {

	// StyleSheetID (optional) The css style sheet identifier (absent for user agent stylesheet and user-specified
	// stylesheet rules) this rule came from.
	StyleSheetID CSSStyleSheetID `json:"styleSheetId,omitempty"`

	// Origin Parent stylesheet's origin.
	Origin CSSStyleSheetOrigin `json:"origin"`

	// KeyText Associated key text.
	KeyText *CSSValue `json:"keyText"`

	// Style Associated style declaration.
	Style *CSSCSSStyle `json:"style"`
}

// CSSStyleDeclarationEdit A descriptor of operation to mutate style declaration text.
type CSSStyleDeclarationEdit struct {

	// StyleSheetID The css style sheet identifier.
	StyleSheetID CSSStyleSheetID `json:"styleSheetId"`

	// Range The range of the style text in the enclosing stylesheet.
	Range *CSSSourceRange `json:"range"`

	// Text New style text.
	Text string `json:"text"`
}

// CSSAddRule Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
// position specified by `location`.
type CSSAddRule struct {

	// StyleSheetID The css style sheet identifier where a new rule should be inserted.
	StyleSheetID CSSStyleSheetID `json:"styleSheetId"`

	// RuleText The text of a new rule.
	RuleText string `json:"ruleText"`

	// Location Text position of a new rule in the target style sheet.
	Location *CSSSourceRange `json:"location"`
}

// Call of the command, sessionID is optional.
func (m CSSAddRule) Call(caller Caller) (*CSSAddRuleResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.addRule", m)
	if err != nil {
		return nil, err
	}

	var res CSSAddRuleResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSAddRuleResult Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
// position specified by `location`.
type CSSAddRuleResult struct {

	// Rule The newly created rule.
	Rule *CSSCSSRule `json:"rule"`
}

// CSSCollectClassNames Returns all class names from specified stylesheet.
type CSSCollectClassNames struct {

	// StyleSheetID ...
	StyleSheetID CSSStyleSheetID `json:"styleSheetId"`
}

// Call of the command, sessionID is optional.
func (m CSSCollectClassNames) Call(caller Caller) (*CSSCollectClassNamesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.collectClassNames", m)
	if err != nil {
		return nil, err
	}

	var res CSSCollectClassNamesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSCollectClassNamesResult Returns all class names from specified stylesheet.
type CSSCollectClassNamesResult struct {

	// ClassNames Class name list.
	ClassNames []string `json:"classNames"`
}

// CSSCreateStyleSheet Creates a new special "via-inspector" stylesheet in the frame with given `frameId`.
type CSSCreateStyleSheet struct {

	// FrameID Identifier of the frame where "via-inspector" stylesheet should be created.
	FrameID PageFrameID `json:"frameId"`
}

// Call of the command, sessionID is optional.
func (m CSSCreateStyleSheet) Call(caller Caller) (*CSSCreateStyleSheetResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.createStyleSheet", m)
	if err != nil {
		return nil, err
	}

	var res CSSCreateStyleSheetResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSCreateStyleSheetResult Creates a new special "via-inspector" stylesheet in the frame with given `frameId`.
type CSSCreateStyleSheetResult struct {

	// StyleSheetID Identifier of the created "via-inspector" stylesheet.
	StyleSheetID CSSStyleSheetID `json:"styleSheetId"`
}

// CSSDisable Disables the CSS agent for the given page.
type CSSDisable struct {
}

// Call of the command, sessionID is optional.
func (m CSSDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "CSS.disable", m)
	return err
}

// CSSEnable Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
// enabled until the result of this command is received.
type CSSEnable struct {
}

// Call of the command, sessionID is optional.
func (m CSSEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "CSS.enable", m)
	return err
}

// CSSForcePseudoState Ensures that the given node will have specified pseudo-classes whenever its style is computed by
// the browser.
type CSSForcePseudoState struct {

	// NodeID The element id for which to force the pseudo state.
	NodeID DOMNodeID `json:"nodeId"`

	// ForcedPseudoClasses Element pseudo classes to force when computing the element's style.
	ForcedPseudoClasses []string `json:"forcedPseudoClasses"`
}

// Call of the command, sessionID is optional.
func (m CSSForcePseudoState) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "CSS.forcePseudoState", m)
	return err
}

// CSSGetBackgroundColors ...
type CSSGetBackgroundColors struct {

	// NodeID Id of the node to get background colors for.
	NodeID DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m CSSGetBackgroundColors) Call(caller Caller) (*CSSGetBackgroundColorsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.getBackgroundColors", m)
	if err != nil {
		return nil, err
	}

	var res CSSGetBackgroundColorsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSGetBackgroundColorsResult ...
type CSSGetBackgroundColorsResult struct {

	// BackgroundColors (optional) The range of background colors behind this element, if it contains any visible text. If no
	// visible text is present, this will be undefined. In the case of a flat background color,
	// this will consist of simply that color. In the case of a gradient, this will consist of each
	// of the color stops. For anything more complicated, this will be an empty array. Images will
	// be ignored (as if the image had failed to load).
	BackgroundColors []string `json:"backgroundColors,omitempty"`

	// ComputedFontSize (optional) The computed font size for this node, as a CSS computed value string (e.g. '12px').
	ComputedFontSize string `json:"computedFontSize,omitempty"`

	// ComputedFontWeight (optional) The computed font weight for this node, as a CSS computed value string (e.g. 'normal' or
	// '100').
	ComputedFontWeight string `json:"computedFontWeight,omitempty"`
}

// CSSGetComputedStyleForNode Returns the computed style for a DOM node identified by `nodeId`.
type CSSGetComputedStyleForNode struct {

	// NodeID ...
	NodeID DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m CSSGetComputedStyleForNode) Call(caller Caller) (*CSSGetComputedStyleForNodeResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.getComputedStyleForNode", m)
	if err != nil {
		return nil, err
	}

	var res CSSGetComputedStyleForNodeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSGetComputedStyleForNodeResult Returns the computed style for a DOM node identified by `nodeId`.
type CSSGetComputedStyleForNodeResult struct {

	// ComputedStyle Computed style for the specified DOM node.
	ComputedStyle []*CSSCSSComputedStyleProperty `json:"computedStyle"`
}

// CSSGetInlineStylesForNode Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
// attributes) for a DOM node identified by `nodeId`.
type CSSGetInlineStylesForNode struct {

	// NodeID ...
	NodeID DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m CSSGetInlineStylesForNode) Call(caller Caller) (*CSSGetInlineStylesForNodeResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.getInlineStylesForNode", m)
	if err != nil {
		return nil, err
	}

	var res CSSGetInlineStylesForNodeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSGetInlineStylesForNodeResult Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
// attributes) for a DOM node identified by `nodeId`.
type CSSGetInlineStylesForNodeResult struct {

	// InlineStyle (optional) Inline style for the specified DOM node.
	InlineStyle *CSSCSSStyle `json:"inlineStyle,omitempty"`

	// AttributesStyle (optional) Attribute-defined element style (e.g. resulting from "width=20 height=100%").
	AttributesStyle *CSSCSSStyle `json:"attributesStyle,omitempty"`
}

// CSSGetMatchedStylesForNode Returns requested styles for a DOM node identified by `nodeId`.
type CSSGetMatchedStylesForNode struct {

	// NodeID ...
	NodeID DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m CSSGetMatchedStylesForNode) Call(caller Caller) (*CSSGetMatchedStylesForNodeResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.getMatchedStylesForNode", m)
	if err != nil {
		return nil, err
	}

	var res CSSGetMatchedStylesForNodeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSGetMatchedStylesForNodeResult Returns requested styles for a DOM node identified by `nodeId`.
type CSSGetMatchedStylesForNodeResult struct {

	// InlineStyle (optional) Inline style for the specified DOM node.
	InlineStyle *CSSCSSStyle `json:"inlineStyle,omitempty"`

	// AttributesStyle (optional) Attribute-defined element style (e.g. resulting from "width=20 height=100%").
	AttributesStyle *CSSCSSStyle `json:"attributesStyle,omitempty"`

	// MatchedCSSRules (optional) CSS rules matching this node, from all applicable stylesheets.
	MatchedCSSRules []*CSSRuleMatch `json:"matchedCSSRules,omitempty"`

	// PseudoElements (optional) Pseudo style matches for this node.
	PseudoElements []*CSSPseudoElementMatches `json:"pseudoElements,omitempty"`

	// Inherited (optional) A chain of inherited styles (from the immediate node parent up to the DOM tree root).
	Inherited []*CSSInheritedStyleEntry `json:"inherited,omitempty"`

	// CSSKeyframesRules (optional) A list of CSS keyframed animations matching this node.
	CSSKeyframesRules []*CSSCSSKeyframesRule `json:"cssKeyframesRules,omitempty"`
}

// CSSGetMediaQueries Returns all media queries parsed by the rendering engine.
type CSSGetMediaQueries struct {
}

// Call of the command, sessionID is optional.
func (m CSSGetMediaQueries) Call(caller Caller) (*CSSGetMediaQueriesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.getMediaQueries", m)
	if err != nil {
		return nil, err
	}

	var res CSSGetMediaQueriesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSGetMediaQueriesResult Returns all media queries parsed by the rendering engine.
type CSSGetMediaQueriesResult struct {

	// Medias ...
	Medias []*CSSCSSMedia `json:"medias"`
}

// CSSGetPlatformFontsForNode Requests information about platform fonts which we used to render child TextNodes in the given
// node.
type CSSGetPlatformFontsForNode struct {

	// NodeID ...
	NodeID DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m CSSGetPlatformFontsForNode) Call(caller Caller) (*CSSGetPlatformFontsForNodeResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.getPlatformFontsForNode", m)
	if err != nil {
		return nil, err
	}

	var res CSSGetPlatformFontsForNodeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSGetPlatformFontsForNodeResult Requests information about platform fonts which we used to render child TextNodes in the given
// node.
type CSSGetPlatformFontsForNodeResult struct {

	// Fonts Usage statistics for every employed platform font.
	Fonts []*CSSPlatformFontUsage `json:"fonts"`
}

// CSSGetStyleSheetText Returns the current textual content for a stylesheet.
type CSSGetStyleSheetText struct {

	// StyleSheetID ...
	StyleSheetID CSSStyleSheetID `json:"styleSheetId"`
}

// Call of the command, sessionID is optional.
func (m CSSGetStyleSheetText) Call(caller Caller) (*CSSGetStyleSheetTextResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.getStyleSheetText", m)
	if err != nil {
		return nil, err
	}

	var res CSSGetStyleSheetTextResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSGetStyleSheetTextResult Returns the current textual content for a stylesheet.
type CSSGetStyleSheetTextResult struct {

	// Text The stylesheet text.
	Text string `json:"text"`
}

// CSSSetEffectivePropertyValueForNode Find a rule with the given active property for the given node and set the new value for this
// property
type CSSSetEffectivePropertyValueForNode struct {

	// NodeID The element id for which to set property.
	NodeID DOMNodeID `json:"nodeId"`

	// PropertyName ...
	PropertyName string `json:"propertyName"`

	// Value ...
	Value string `json:"value"`
}

// Call of the command, sessionID is optional.
func (m CSSSetEffectivePropertyValueForNode) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "CSS.setEffectivePropertyValueForNode", m)
	return err
}

// CSSSetKeyframeKey Modifies the keyframe rule key text.
type CSSSetKeyframeKey struct {

	// StyleSheetID ...
	StyleSheetID CSSStyleSheetID `json:"styleSheetId"`

	// Range ...
	Range *CSSSourceRange `json:"range"`

	// KeyText ...
	KeyText string `json:"keyText"`
}

// Call of the command, sessionID is optional.
func (m CSSSetKeyframeKey) Call(caller Caller) (*CSSSetKeyframeKeyResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.setKeyframeKey", m)
	if err != nil {
		return nil, err
	}

	var res CSSSetKeyframeKeyResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSSetKeyframeKeyResult Modifies the keyframe rule key text.
type CSSSetKeyframeKeyResult struct {

	// KeyText The resulting key text after modification.
	KeyText *CSSValue `json:"keyText"`
}

// CSSSetMediaText Modifies the rule selector.
type CSSSetMediaText struct {

	// StyleSheetID ...
	StyleSheetID CSSStyleSheetID `json:"styleSheetId"`

	// Range ...
	Range *CSSSourceRange `json:"range"`

	// Text ...
	Text string `json:"text"`
}

// Call of the command, sessionID is optional.
func (m CSSSetMediaText) Call(caller Caller) (*CSSSetMediaTextResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.setMediaText", m)
	if err != nil {
		return nil, err
	}

	var res CSSSetMediaTextResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSSetMediaTextResult Modifies the rule selector.
type CSSSetMediaTextResult struct {

	// Media The resulting CSS media rule after modification.
	Media *CSSCSSMedia `json:"media"`
}

// CSSSetRuleSelector Modifies the rule selector.
type CSSSetRuleSelector struct {

	// StyleSheetID ...
	StyleSheetID CSSStyleSheetID `json:"styleSheetId"`

	// Range ...
	Range *CSSSourceRange `json:"range"`

	// Selector ...
	Selector string `json:"selector"`
}

// Call of the command, sessionID is optional.
func (m CSSSetRuleSelector) Call(caller Caller) (*CSSSetRuleSelectorResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.setRuleSelector", m)
	if err != nil {
		return nil, err
	}

	var res CSSSetRuleSelectorResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSSetRuleSelectorResult Modifies the rule selector.
type CSSSetRuleSelectorResult struct {

	// SelectorList The resulting selector list after modification.
	SelectorList *CSSSelectorList `json:"selectorList"`
}

// CSSSetStyleSheetText Sets the new stylesheet text.
type CSSSetStyleSheetText struct {

	// StyleSheetID ...
	StyleSheetID CSSStyleSheetID `json:"styleSheetId"`

	// Text ...
	Text string `json:"text"`
}

// Call of the command, sessionID is optional.
func (m CSSSetStyleSheetText) Call(caller Caller) (*CSSSetStyleSheetTextResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.setStyleSheetText", m)
	if err != nil {
		return nil, err
	}

	var res CSSSetStyleSheetTextResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSSetStyleSheetTextResult Sets the new stylesheet text.
type CSSSetStyleSheetTextResult struct {

	// SourceMapURL (optional) URL of source map associated with script (if any).
	SourceMapURL string `json:"sourceMapURL,omitempty"`
}

// CSSSetStyleTexts Applies specified style edits one after another in the given order.
type CSSSetStyleTexts struct {

	// Edits ...
	Edits []*CSSStyleDeclarationEdit `json:"edits"`
}

// Call of the command, sessionID is optional.
func (m CSSSetStyleTexts) Call(caller Caller) (*CSSSetStyleTextsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.setStyleTexts", m)
	if err != nil {
		return nil, err
	}

	var res CSSSetStyleTextsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSSetStyleTextsResult Applies specified style edits one after another in the given order.
type CSSSetStyleTextsResult struct {

	// Styles The resulting styles after modification.
	Styles []*CSSCSSStyle `json:"styles"`
}

// CSSStartRuleUsageTracking Enables the selector recording.
type CSSStartRuleUsageTracking struct {
}

// Call of the command, sessionID is optional.
func (m CSSStartRuleUsageTracking) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "CSS.startRuleUsageTracking", m)
	return err
}

// CSSStopRuleUsageTracking Stop tracking rule usage and return the list of rules that were used since last call to
// `takeCoverageDelta` (or since start of coverage instrumentation)
type CSSStopRuleUsageTracking struct {
}

// Call of the command, sessionID is optional.
func (m CSSStopRuleUsageTracking) Call(caller Caller) (*CSSStopRuleUsageTrackingResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.stopRuleUsageTracking", m)
	if err != nil {
		return nil, err
	}

	var res CSSStopRuleUsageTrackingResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSStopRuleUsageTrackingResult Stop tracking rule usage and return the list of rules that were used since last call to
// `takeCoverageDelta` (or since start of coverage instrumentation)
type CSSStopRuleUsageTrackingResult struct {

	// RuleUsage ...
	RuleUsage []*CSSRuleUsage `json:"ruleUsage"`
}

// CSSTakeCoverageDelta Obtain list of rules that became used since last call to this method (or since start of coverage
// instrumentation)
type CSSTakeCoverageDelta struct {
}

// Call of the command, sessionID is optional.
func (m CSSTakeCoverageDelta) Call(caller Caller) (*CSSTakeCoverageDeltaResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CSS.takeCoverageDelta", m)
	if err != nil {
		return nil, err
	}

	var res CSSTakeCoverageDeltaResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CSSTakeCoverageDeltaResult Obtain list of rules that became used since last call to this method (or since start of coverage
// instrumentation)
type CSSTakeCoverageDeltaResult struct {

	// Coverage ...
	Coverage []*CSSRuleUsage `json:"coverage"`

	// Timestamp Monotonically increasing time, in seconds.
	Timestamp float64 `json:"timestamp"`
}

// CSSFontsUpdated Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
// web font
type CSSFontsUpdated struct {

	// Font (optional) The web font that has loaded.
	Font *CSSFontFace `json:"font,omitempty"`
}

// MethodName interface
func (evt CSSFontsUpdated) MethodName() string {
	return "CSS.fontsUpdated"
}

// CSSMediaQueryResultChanged Fires whenever a MediaQuery result changes (for example, after a browser window has been
// resized.) The current implementation considers only viewport-dependent media features.
type CSSMediaQueryResultChanged struct {
}

// MethodName interface
func (evt CSSMediaQueryResultChanged) MethodName() string {
	return "CSS.mediaQueryResultChanged"
}

// CSSStyleSheetAdded Fired whenever an active document stylesheet is added.
type CSSStyleSheetAdded struct {

	// Header Added stylesheet metainfo.
	Header *CSSCSSStyleSheetHeader `json:"header"`
}

// MethodName interface
func (evt CSSStyleSheetAdded) MethodName() string {
	return "CSS.styleSheetAdded"
}

// CSSStyleSheetChanged Fired whenever a stylesheet is changed as a result of the client operation.
type CSSStyleSheetChanged struct {

	// StyleSheetID ...
	StyleSheetID CSSStyleSheetID `json:"styleSheetId"`
}

// MethodName interface
func (evt CSSStyleSheetChanged) MethodName() string {
	return "CSS.styleSheetChanged"
}

// CSSStyleSheetRemoved Fired whenever an active document stylesheet is removed.
type CSSStyleSheetRemoved struct {

	// StyleSheetID Identifier of the removed stylesheet.
	StyleSheetID CSSStyleSheetID `json:"styleSheetId"`
}

// MethodName interface
func (evt CSSStyleSheetRemoved) MethodName() string {
	return "CSS.styleSheetRemoved"
}

// CacheStorageCacheID Unique identifier of the Cache object.
type CacheStorageCacheID string

// CacheStorageCachedResponseType type of HTTP response cached
type CacheStorageCachedResponseType string

const (
	// CacheStorageCachedResponseTypeBasic enum const
	CacheStorageCachedResponseTypeBasic CacheStorageCachedResponseType = "basic"

	// CacheStorageCachedResponseTypeCors enum const
	CacheStorageCachedResponseTypeCors CacheStorageCachedResponseType = "cors"

	// CacheStorageCachedResponseTypeDefault enum const
	CacheStorageCachedResponseTypeDefault CacheStorageCachedResponseType = "default"

	// CacheStorageCachedResponseTypeError enum const
	CacheStorageCachedResponseTypeError CacheStorageCachedResponseType = "error"

	// CacheStorageCachedResponseTypeOpaqueResponse enum const
	CacheStorageCachedResponseTypeOpaqueResponse CacheStorageCachedResponseType = "opaqueResponse"

	// CacheStorageCachedResponseTypeOpaqueRedirect enum const
	CacheStorageCachedResponseTypeOpaqueRedirect CacheStorageCachedResponseType = "opaqueRedirect"
)

// CacheStorageDataEntry Data entry.
type CacheStorageDataEntry struct {

	// RequestURL Request URL.
	RequestURL string `json:"requestURL"`

	// RequestMethod Request method.
	RequestMethod string `json:"requestMethod"`

	// RequestHeaders Request headers
	RequestHeaders []*CacheStorageHeader `json:"requestHeaders"`

	// ResponseTime Number of seconds since epoch.
	ResponseTime float64 `json:"responseTime"`

	// ResponseStatus HTTP response status code.
	ResponseStatus int64 `json:"responseStatus"`

	// ResponseStatusText HTTP response status text.
	ResponseStatusText string `json:"responseStatusText"`

	// ResponseType HTTP response type
	ResponseType CacheStorageCachedResponseType `json:"responseType"`

	// ResponseHeaders Response headers
	ResponseHeaders []*CacheStorageHeader `json:"responseHeaders"`
}

// CacheStorageCache Cache identifier.
type CacheStorageCache struct {

	// CacheID An opaque unique id of the cache.
	CacheID CacheStorageCacheID `json:"cacheId"`

	// SecurityOrigin Security origin of the cache.
	SecurityOrigin string `json:"securityOrigin"`

	// CacheName The name of the cache.
	CacheName string `json:"cacheName"`
}

// CacheStorageHeader ...
type CacheStorageHeader struct {

	// Name ...
	Name string `json:"name"`

	// Value ...
	Value string `json:"value"`
}

// CacheStorageCachedResponse Cached response
type CacheStorageCachedResponse struct {

	// Body Entry content, base64-encoded.
	Body []byte `json:"body"`
}

// CacheStorageDeleteCache Deletes a cache.
type CacheStorageDeleteCache struct {

	// CacheID Id of cache for deletion.
	CacheID CacheStorageCacheID `json:"cacheId"`
}

// Call of the command, sessionID is optional.
func (m CacheStorageDeleteCache) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "CacheStorage.deleteCache", m)
	return err
}

// CacheStorageDeleteEntry Deletes a cache entry.
type CacheStorageDeleteEntry struct {

	// CacheID Id of cache where the entry will be deleted.
	CacheID CacheStorageCacheID `json:"cacheId"`

	// Request URL spec of the request.
	Request string `json:"request"`
}

// Call of the command, sessionID is optional.
func (m CacheStorageDeleteEntry) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "CacheStorage.deleteEntry", m)
	return err
}

// CacheStorageRequestCacheNames Requests cache names.
type CacheStorageRequestCacheNames struct {

	// SecurityOrigin Security origin.
	SecurityOrigin string `json:"securityOrigin"`
}

// Call of the command, sessionID is optional.
func (m CacheStorageRequestCacheNames) Call(caller Caller) (*CacheStorageRequestCacheNamesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CacheStorage.requestCacheNames", m)
	if err != nil {
		return nil, err
	}

	var res CacheStorageRequestCacheNamesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CacheStorageRequestCacheNamesResult Requests cache names.
type CacheStorageRequestCacheNamesResult struct {

	// Caches Caches for the security origin.
	Caches []*CacheStorageCache `json:"caches"`
}

// CacheStorageRequestCachedResponse Fetches cache entry.
type CacheStorageRequestCachedResponse struct {

	// CacheID Id of cache that contains the entry.
	CacheID CacheStorageCacheID `json:"cacheId"`

	// RequestURL URL spec of the request.
	RequestURL string `json:"requestURL"`

	// RequestHeaders headers of the request.
	RequestHeaders []*CacheStorageHeader `json:"requestHeaders"`
}

// Call of the command, sessionID is optional.
func (m CacheStorageRequestCachedResponse) Call(caller Caller) (*CacheStorageRequestCachedResponseResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CacheStorage.requestCachedResponse", m)
	if err != nil {
		return nil, err
	}

	var res CacheStorageRequestCachedResponseResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CacheStorageRequestCachedResponseResult Fetches cache entry.
type CacheStorageRequestCachedResponseResult struct {

	// Response Response read from the cache.
	Response *CacheStorageCachedResponse `json:"response"`
}

// CacheStorageRequestEntries Requests data from cache.
type CacheStorageRequestEntries struct {

	// CacheID ID of cache to get entries from.
	CacheID CacheStorageCacheID `json:"cacheId"`

	// SkipCount (optional) Number of records to skip.
	SkipCount int64 `json:"skipCount,omitempty"`

	// PageSize (optional) Number of records to fetch.
	PageSize int64 `json:"pageSize,omitempty"`

	// PathFilter (optional) If present, only return the entries containing this substring in the path
	PathFilter string `json:"pathFilter,omitempty"`
}

// Call of the command, sessionID is optional.
func (m CacheStorageRequestEntries) Call(caller Caller) (*CacheStorageRequestEntriesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "CacheStorage.requestEntries", m)
	if err != nil {
		return nil, err
	}

	var res CacheStorageRequestEntriesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// CacheStorageRequestEntriesResult Requests data from cache.
type CacheStorageRequestEntriesResult struct {

	// CacheDataEntries Array of object store data entries.
	CacheDataEntries []*CacheStorageDataEntry `json:"cacheDataEntries"`

	// ReturnCount Count of returned entries from this storage. If pathFilter is empty, it
	// is the count of all entries from this storage.
	ReturnCount float64 `json:"returnCount"`
}

// CastSink ...
type CastSink struct {

	// Name ...
	Name string `json:"name"`

	// ID ...
	ID string `json:"id"`

	// Session (optional) Text describing the current session. Present only if there is an active
	// session on the sink.
	Session string `json:"session,omitempty"`
}

// CastEnable Starts observing for sinks that can be used for tab mirroring, and if set,
// sinks compatible with |presentationUrl| as well. When sinks are found, a
// |sinksUpdated| event is fired.
// Also starts observing for issue messages. When an issue is added or removed,
// an |issueUpdated| event is fired.
type CastEnable struct {

	// PresentationURL (optional) ...
	PresentationURL string `json:"presentationUrl,omitempty"`
}

// Call of the command, sessionID is optional.
func (m CastEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Cast.enable", m)
	return err
}

// CastDisable Stops observing for sinks and issues.
type CastDisable struct {
}

// Call of the command, sessionID is optional.
func (m CastDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Cast.disable", m)
	return err
}

// CastSetSinkToUse Sets a sink to be used when the web page requests the browser to choose a
// sink via Presentation API, Remote Playback API, or Cast SDK.
type CastSetSinkToUse struct {

	// SinkName ...
	SinkName string `json:"sinkName"`
}

// Call of the command, sessionID is optional.
func (m CastSetSinkToUse) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Cast.setSinkToUse", m)
	return err
}

// CastStartTabMirroring Starts mirroring the tab to the sink.
type CastStartTabMirroring struct {

	// SinkName ...
	SinkName string `json:"sinkName"`
}

// Call of the command, sessionID is optional.
func (m CastStartTabMirroring) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Cast.startTabMirroring", m)
	return err
}

// CastStopCasting Stops the active Cast session on the sink.
type CastStopCasting struct {

	// SinkName ...
	SinkName string `json:"sinkName"`
}

// Call of the command, sessionID is optional.
func (m CastStopCasting) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Cast.stopCasting", m)
	return err
}

// CastSinksUpdated This is fired whenever the list of available sinks changes. A sink is a
// device or a software surface that you can cast to.
type CastSinksUpdated struct {

	// Sinks ...
	Sinks []*CastSink `json:"sinks"`
}

// MethodName interface
func (evt CastSinksUpdated) MethodName() string {
	return "Cast.sinksUpdated"
}

// CastIssueUpdated This is fired whenever the outstanding issue/error message changes.
// |issueMessage| is empty if there is no issue.
type CastIssueUpdated struct {

	// IssueMessage ...
	IssueMessage string `json:"issueMessage"`
}

// MethodName interface
func (evt CastIssueUpdated) MethodName() string {
	return "Cast.issueUpdated"
}

// DOMNodeID Unique DOM node identifier.
type DOMNodeID int64

// DOMBackendNodeID Unique DOM node identifier used to reference a node that may not have been pushed to the
// front-end.
type DOMBackendNodeID int64

// DOMBackendNode Backend node with a friendly name.
type DOMBackendNode struct {

	// NodeType `Node`'s nodeType.
	NodeType int64 `json:"nodeType"`

	// NodeName `Node`'s nodeName.
	NodeName string `json:"nodeName"`

	// BackendNodeID ...
	BackendNodeID DOMBackendNodeID `json:"backendNodeId"`
}

// DOMPseudoType Pseudo element type.
type DOMPseudoType string

const (
	// DOMPseudoTypeFirstLine enum const
	DOMPseudoTypeFirstLine DOMPseudoType = "first-line"

	// DOMPseudoTypeFirstLetter enum const
	DOMPseudoTypeFirstLetter DOMPseudoType = "first-letter"

	// DOMPseudoTypeBefore enum const
	DOMPseudoTypeBefore DOMPseudoType = "before"

	// DOMPseudoTypeAfter enum const
	DOMPseudoTypeAfter DOMPseudoType = "after"

	// DOMPseudoTypeMarker enum const
	DOMPseudoTypeMarker DOMPseudoType = "marker"

	// DOMPseudoTypeBackdrop enum const
	DOMPseudoTypeBackdrop DOMPseudoType = "backdrop"

	// DOMPseudoTypeSelection enum const
	DOMPseudoTypeSelection DOMPseudoType = "selection"

	// DOMPseudoTypeFirstLineInherited enum const
	DOMPseudoTypeFirstLineInherited DOMPseudoType = "first-line-inherited"

	// DOMPseudoTypeScrollbar enum const
	DOMPseudoTypeScrollbar DOMPseudoType = "scrollbar"

	// DOMPseudoTypeScrollbarThumb enum const
	DOMPseudoTypeScrollbarThumb DOMPseudoType = "scrollbar-thumb"

	// DOMPseudoTypeScrollbarButton enum const
	DOMPseudoTypeScrollbarButton DOMPseudoType = "scrollbar-button"

	// DOMPseudoTypeScrollbarTrack enum const
	DOMPseudoTypeScrollbarTrack DOMPseudoType = "scrollbar-track"

	// DOMPseudoTypeScrollbarTrackPiece enum const
	DOMPseudoTypeScrollbarTrackPiece DOMPseudoType = "scrollbar-track-piece"

	// DOMPseudoTypeScrollbarCorner enum const
	DOMPseudoTypeScrollbarCorner DOMPseudoType = "scrollbar-corner"

	// DOMPseudoTypeResizer enum const
	DOMPseudoTypeResizer DOMPseudoType = "resizer"

	// DOMPseudoTypeInputListButton enum const
	DOMPseudoTypeInputListButton DOMPseudoType = "input-list-button"
)

// DOMShadowRootType Shadow root type.
type DOMShadowRootType string

const (
	// DOMShadowRootTypeUserAgent enum const
	DOMShadowRootTypeUserAgent DOMShadowRootType = "user-agent"

	// DOMShadowRootTypeOpen enum const
	DOMShadowRootTypeOpen DOMShadowRootType = "open"

	// DOMShadowRootTypeClosed enum const
	DOMShadowRootTypeClosed DOMShadowRootType = "closed"
)

// DOMNode DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes.
// DOMNode is a base node mirror type.
type DOMNode struct {

	// NodeID Node identifier that is passed into the rest of the DOM messages as the `nodeId`. Backend
	// will only push node with given `id` once. It is aware of all requested nodes and will only
	// fire DOM events for nodes known to the client.
	NodeID DOMNodeID `json:"nodeId"`

	// ParentID (optional) The id of the parent node if any.
	ParentID DOMNodeID `json:"parentId,omitempty"`

	// BackendNodeID The BackendNodeId for this node.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId"`

	// NodeType `Node`'s nodeType.
	NodeType int64 `json:"nodeType"`

	// NodeName `Node`'s nodeName.
	NodeName string `json:"nodeName"`

	// LocalName `Node`'s localName.
	LocalName string `json:"localName"`

	// NodeValue `Node`'s nodeValue.
	NodeValue string `json:"nodeValue"`

	// ChildNodeCount (optional) Child count for `Container` nodes.
	ChildNodeCount int64 `json:"childNodeCount,omitempty"`

	// Children (optional) Child nodes of this node when requested with children.
	Children []*DOMNode `json:"children,omitempty"`

	// Attributes (optional) Attributes of the `Element` node in the form of flat array `[name1, value1, name2, value2]`.
	Attributes []string `json:"attributes,omitempty"`

	// DocumentURL (optional) Document URL that `Document` or `FrameOwner` node points to.
	DocumentURL string `json:"documentURL,omitempty"`

	// BaseURL (optional) Base URL that `Document` or `FrameOwner` node uses for URL completion.
	BaseURL string `json:"baseURL,omitempty"`

	// PublicID (optional) `DocumentType`'s publicId.
	PublicID string `json:"publicId,omitempty"`

	// SystemID (optional) `DocumentType`'s systemId.
	SystemID string `json:"systemId,omitempty"`

	// InternalSubset (optional) `DocumentType`'s internalSubset.
	InternalSubset string `json:"internalSubset,omitempty"`

	// XMLVersion (optional) `Document`'s XML version in case of XML documents.
	XMLVersion string `json:"xmlVersion,omitempty"`

	// Name (optional) `Attr`'s name.
	Name string `json:"name,omitempty"`

	// Value (optional) `Attr`'s value.
	Value string `json:"value,omitempty"`

	// PseudoType (optional) Pseudo element type for this node.
	PseudoType DOMPseudoType `json:"pseudoType,omitempty"`

	// ShadowRootType (optional) Shadow root type.
	ShadowRootType DOMShadowRootType `json:"shadowRootType,omitempty"`

	// FrameID (optional) Frame ID for frame owner elements.
	FrameID PageFrameID `json:"frameId,omitempty"`

	// ContentDocument (optional) Content document for frame owner elements.
	ContentDocument *DOMNode `json:"contentDocument,omitempty"`

	// ShadowRoots (optional) Shadow root list for given element host.
	ShadowRoots []*DOMNode `json:"shadowRoots,omitempty"`

	// TemplateContent (optional) Content document fragment for template elements.
	TemplateContent *DOMNode `json:"templateContent,omitempty"`

	// PseudoElements (optional) Pseudo elements associated with this node.
	PseudoElements []*DOMNode `json:"pseudoElements,omitempty"`

	// ImportedDocument (optional) Import document for the HTMLImport links.
	ImportedDocument *DOMNode `json:"importedDocument,omitempty"`

	// DistributedNodes (optional) Distributed nodes for given insertion point.
	DistributedNodes []*DOMBackendNode `json:"distributedNodes,omitempty"`

	// IsSVG (optional) Whether the node is SVG.
	IsSVG bool `json:"isSVG,omitempty"`
}

// DOMRGBA A structure holding an RGBA color.
type DOMRGBA struct {

	// R The red component, in the [0-255] range.
	R int64 `json:"r"`

	// G The green component, in the [0-255] range.
	G int64 `json:"g"`

	// B The blue component, in the [0-255] range.
	B int64 `json:"b"`

	// A (optional) The alpha component, in the [0-1] range (default: 1).
	A float64 `json:"a,omitempty"`
}

// DOMQuad An array of quad vertices, x immediately followed by y for each point, points clock-wise.
type DOMQuad []float64

// DOMBoxModel Box model.
type DOMBoxModel struct {

	// Content Content box
	Content DOMQuad `json:"content"`

	// Padding Padding box
	Padding DOMQuad `json:"padding"`

	// Border Border box
	Border DOMQuad `json:"border"`

	// Margin Margin box
	Margin DOMQuad `json:"margin"`

	// Width Node width
	Width int64 `json:"width"`

	// Height Node height
	Height int64 `json:"height"`

	// ShapeOutside (optional) Shape outside coordinates
	ShapeOutside *DOMShapeOutsideInfo `json:"shapeOutside,omitempty"`
}

// DOMShapeOutsideInfo CSS Shape Outside details.
type DOMShapeOutsideInfo struct {

	// Bounds Shape bounds
	Bounds DOMQuad `json:"bounds"`

	// Shape Shape coordinate details
	Shape []JSON `json:"shape"`

	// MarginShape Margin shape bounds
	MarginShape []JSON `json:"marginShape"`
}

// DOMRect Rectangle.
type DOMRect struct {

	// X X coordinate
	X float64 `json:"x"`

	// Y Y coordinate
	Y float64 `json:"y"`

	// Width Rectangle width
	Width float64 `json:"width"`

	// Height Rectangle height
	Height float64 `json:"height"`
}

// DOMCollectClassNamesFromSubtree (experimental) Collects class names for the node with given id and all of it's child nodes.
type DOMCollectClassNamesFromSubtree struct {

	// NodeID Id of the node to collect class names.
	NodeID DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m DOMCollectClassNamesFromSubtree) Call(caller Caller) (*DOMCollectClassNamesFromSubtreeResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.collectClassNamesFromSubtree", m)
	if err != nil {
		return nil, err
	}

	var res DOMCollectClassNamesFromSubtreeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMCollectClassNamesFromSubtreeResult (experimental) Collects class names for the node with given id and all of it's child nodes.
type DOMCollectClassNamesFromSubtreeResult struct {

	// ClassNames Class name list.
	ClassNames []string `json:"classNames"`
}

// DOMCopyTo (experimental) Creates a deep copy of the specified node and places it into the target container before the
// given anchor.
type DOMCopyTo struct {

	// NodeID Id of the node to copy.
	NodeID DOMNodeID `json:"nodeId"`

	// TargetNodeID Id of the element to drop the copy into.
	TargetNodeID DOMNodeID `json:"targetNodeId"`

	// InsertBeforeNodeID (optional) Drop the copy before this node (if absent, the copy becomes the last child of
	// `targetNodeId`).
	InsertBeforeNodeID DOMNodeID `json:"insertBeforeNodeId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMCopyTo) Call(caller Caller) (*DOMCopyToResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.copyTo", m)
	if err != nil {
		return nil, err
	}

	var res DOMCopyToResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMCopyToResult (experimental) Creates a deep copy of the specified node and places it into the target container before the
// given anchor.
type DOMCopyToResult struct {

	// NodeID Id of the node clone.
	NodeID DOMNodeID `json:"nodeId"`
}

// DOMDescribeNode Describes node given its id, does not require domain to be enabled. Does not start tracking any
// objects, can be used for automation.
type DOMDescribeNode struct {

	// NodeID (optional) Identifier of the node.
	NodeID DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID (optional) Identifier of the backend node.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectID (optional) JavaScript object id of the node wrapper.
	ObjectID RuntimeRemoteObjectID `json:"objectId,omitempty"`

	// Depth (optional) The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
	// entire subtree or provide an integer larger than 0.
	Depth int64 `json:"depth,omitempty"`

	// Pierce (optional) Whether or not iframes and shadow roots should be traversed when returning the subtree
	// (default is false).
	Pierce bool `json:"pierce,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMDescribeNode) Call(caller Caller) (*DOMDescribeNodeResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.describeNode", m)
	if err != nil {
		return nil, err
	}

	var res DOMDescribeNodeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMDescribeNodeResult Describes node given its id, does not require domain to be enabled. Does not start tracking any
// objects, can be used for automation.
type DOMDescribeNodeResult struct {

	// Node Node description.
	Node *DOMNode `json:"node"`
}

// DOMDisable Disables DOM agent for the given page.
type DOMDisable struct {
}

// Call of the command, sessionID is optional.
func (m DOMDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.disable", m)
	return err
}

// DOMDiscardSearchResults (experimental) Discards search results from the session with the given id. `getSearchResults` should no longer
// be called for that search.
type DOMDiscardSearchResults struct {

	// SearchID Unique search session identifier.
	SearchID string `json:"searchId"`
}

// Call of the command, sessionID is optional.
func (m DOMDiscardSearchResults) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.discardSearchResults", m)
	return err
}

// DOMEnable Enables DOM agent for the given page.
type DOMEnable struct {
}

// Call of the command, sessionID is optional.
func (m DOMEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.enable", m)
	return err
}

// DOMFocus Focuses the given element.
type DOMFocus struct {

	// NodeID (optional) Identifier of the node.
	NodeID DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID (optional) Identifier of the backend node.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectID (optional) JavaScript object id of the node wrapper.
	ObjectID RuntimeRemoteObjectID `json:"objectId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMFocus) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.focus", m)
	return err
}

// DOMGetAttributes Returns attributes for the specified node.
type DOMGetAttributes struct {

	// NodeID Id of the node to retrieve attibutes for.
	NodeID DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m DOMGetAttributes) Call(caller Caller) (*DOMGetAttributesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.getAttributes", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetAttributesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetAttributesResult Returns attributes for the specified node.
type DOMGetAttributesResult struct {

	// Attributes An interleaved array of node attribute names and values.
	Attributes []string `json:"attributes"`
}

// DOMGetBoxModel Returns boxes for the given node.
type DOMGetBoxModel struct {

	// NodeID (optional) Identifier of the node.
	NodeID DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID (optional) Identifier of the backend node.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectID (optional) JavaScript object id of the node wrapper.
	ObjectID RuntimeRemoteObjectID `json:"objectId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMGetBoxModel) Call(caller Caller) (*DOMGetBoxModelResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.getBoxModel", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetBoxModelResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetBoxModelResult Returns boxes for the given node.
type DOMGetBoxModelResult struct {

	// Model Box model for the node.
	Model *DOMBoxModel `json:"model"`
}

// DOMGetContentQuads (experimental) Returns quads that describe node position on the page. This method
// might return multiple quads for inline nodes.
type DOMGetContentQuads struct {

	// NodeID (optional) Identifier of the node.
	NodeID DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID (optional) Identifier of the backend node.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectID (optional) JavaScript object id of the node wrapper.
	ObjectID RuntimeRemoteObjectID `json:"objectId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMGetContentQuads) Call(caller Caller) (*DOMGetContentQuadsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.getContentQuads", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetContentQuadsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetContentQuadsResult (experimental) Returns quads that describe node position on the page. This method
// might return multiple quads for inline nodes.
type DOMGetContentQuadsResult struct {

	// Quads Quads that describe node layout relative to viewport.
	Quads []DOMQuad `json:"quads"`
}

// DOMGetDocument Returns the root DOM node (and optionally the subtree) to the caller.
type DOMGetDocument struct {

	// Depth (optional) The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
	// entire subtree or provide an integer larger than 0.
	Depth int64 `json:"depth,omitempty"`

	// Pierce (optional) Whether or not iframes and shadow roots should be traversed when returning the subtree
	// (default is false).
	Pierce bool `json:"pierce,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMGetDocument) Call(caller Caller) (*DOMGetDocumentResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.getDocument", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetDocumentResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetDocumentResult Returns the root DOM node (and optionally the subtree) to the caller.
type DOMGetDocumentResult struct {

	// Root Resulting node.
	Root *DOMNode `json:"root"`
}

// DOMGetFlattenedDocument Returns the root DOM node (and optionally the subtree) to the caller.
type DOMGetFlattenedDocument struct {

	// Depth (optional) The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
	// entire subtree or provide an integer larger than 0.
	Depth int64 `json:"depth,omitempty"`

	// Pierce (optional) Whether or not iframes and shadow roots should be traversed when returning the subtree
	// (default is false).
	Pierce bool `json:"pierce,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMGetFlattenedDocument) Call(caller Caller) (*DOMGetFlattenedDocumentResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.getFlattenedDocument", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetFlattenedDocumentResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetFlattenedDocumentResult Returns the root DOM node (and optionally the subtree) to the caller.
type DOMGetFlattenedDocumentResult struct {

	// Nodes Resulting node.
	Nodes []*DOMNode `json:"nodes"`
}

// DOMGetNodeForLocation Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
// either returned or not.
type DOMGetNodeForLocation struct {

	// X X coordinate.
	X int64 `json:"x"`

	// Y Y coordinate.
	Y int64 `json:"y"`

	// IncludeUserAgentShadowDOM (optional) False to skip to the nearest non-UA shadow root ancestor (default: false).
	IncludeUserAgentShadowDOM bool `json:"includeUserAgentShadowDOM,omitempty"`

	// IgnorePointerEventsNone (optional) Whether to ignore pointer-events: none on elements and hit test them.
	IgnorePointerEventsNone bool `json:"ignorePointerEventsNone,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMGetNodeForLocation) Call(caller Caller) (*DOMGetNodeForLocationResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.getNodeForLocation", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetNodeForLocationResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetNodeForLocationResult Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
// either returned or not.
type DOMGetNodeForLocationResult struct {

	// BackendNodeID Resulting node.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId"`

	// FrameID Frame this node belongs to.
	FrameID PageFrameID `json:"frameId"`

	// NodeID (optional) Id of the node at given coordinates, only when enabled and requested document.
	NodeID DOMNodeID `json:"nodeId,omitempty"`
}

// DOMGetOuterHTML Returns node's HTML markup.
type DOMGetOuterHTML struct {

	// NodeID (optional) Identifier of the node.
	NodeID DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID (optional) Identifier of the backend node.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectID (optional) JavaScript object id of the node wrapper.
	ObjectID RuntimeRemoteObjectID `json:"objectId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMGetOuterHTML) Call(caller Caller) (*DOMGetOuterHTMLResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.getOuterHTML", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetOuterHTMLResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetOuterHTMLResult Returns node's HTML markup.
type DOMGetOuterHTMLResult struct {

	// OuterHTML Outer HTML markup.
	OuterHTML string `json:"outerHTML"`
}

// DOMGetRelayoutBoundary (experimental) Returns the id of the nearest ancestor that is a relayout boundary.
type DOMGetRelayoutBoundary struct {

	// NodeID Id of the node.
	NodeID DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m DOMGetRelayoutBoundary) Call(caller Caller) (*DOMGetRelayoutBoundaryResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.getRelayoutBoundary", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetRelayoutBoundaryResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetRelayoutBoundaryResult (experimental) Returns the id of the nearest ancestor that is a relayout boundary.
type DOMGetRelayoutBoundaryResult struct {

	// NodeID Relayout boundary node id for the given node.
	NodeID DOMNodeID `json:"nodeId"`
}

// DOMGetSearchResults (experimental) Returns search results from given `fromIndex` to given `toIndex` from the search with the given
// identifier.
type DOMGetSearchResults struct {

	// SearchID Unique search session identifier.
	SearchID string `json:"searchId"`

	// FromIndex Start index of the search result to be returned.
	FromIndex int64 `json:"fromIndex"`

	// ToIndex End index of the search result to be returned.
	ToIndex int64 `json:"toIndex"`
}

// Call of the command, sessionID is optional.
func (m DOMGetSearchResults) Call(caller Caller) (*DOMGetSearchResultsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.getSearchResults", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetSearchResultsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetSearchResultsResult (experimental) Returns search results from given `fromIndex` to given `toIndex` from the search with the given
// identifier.
type DOMGetSearchResultsResult struct {

	// NodeIds Ids of the search result nodes.
	NodeIds []DOMNodeID `json:"nodeIds"`
}

// DOMHideHighlight Hides any highlight.
type DOMHideHighlight struct {
}

// Call of the command, sessionID is optional.
func (m DOMHideHighlight) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.hideHighlight", m)
	return err
}

// DOMHighlightNode Highlights DOM node.
type DOMHighlightNode struct {
}

// Call of the command, sessionID is optional.
func (m DOMHighlightNode) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.highlightNode", m)
	return err
}

// DOMHighlightRect Highlights given rectangle.
type DOMHighlightRect struct {
}

// Call of the command, sessionID is optional.
func (m DOMHighlightRect) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.highlightRect", m)
	return err
}

// DOMMarkUndoableState (experimental) Marks last undoable state.
type DOMMarkUndoableState struct {
}

// Call of the command, sessionID is optional.
func (m DOMMarkUndoableState) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.markUndoableState", m)
	return err
}

// DOMMoveTo Moves node into the new container, places it before the given anchor.
type DOMMoveTo struct {

	// NodeID Id of the node to move.
	NodeID DOMNodeID `json:"nodeId"`

	// TargetNodeID Id of the element to drop the moved node into.
	TargetNodeID DOMNodeID `json:"targetNodeId"`

	// InsertBeforeNodeID (optional) Drop node before this one (if absent, the moved node becomes the last child of
	// `targetNodeId`).
	InsertBeforeNodeID DOMNodeID `json:"insertBeforeNodeId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMMoveTo) Call(caller Caller) (*DOMMoveToResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.moveTo", m)
	if err != nil {
		return nil, err
	}

	var res DOMMoveToResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMMoveToResult Moves node into the new container, places it before the given anchor.
type DOMMoveToResult struct {

	// NodeID New id of the moved node.
	NodeID DOMNodeID `json:"nodeId"`
}

// DOMPerformSearch (experimental) Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
// `cancelSearch` to end this search session.
type DOMPerformSearch struct {

	// Query Plain text or query selector or XPath search query.
	Query string `json:"query"`

	// IncludeUserAgentShadowDOM (optional) True to search in user agent shadow DOM.
	IncludeUserAgentShadowDOM bool `json:"includeUserAgentShadowDOM,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMPerformSearch) Call(caller Caller) (*DOMPerformSearchResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.performSearch", m)
	if err != nil {
		return nil, err
	}

	var res DOMPerformSearchResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMPerformSearchResult (experimental) Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
// `cancelSearch` to end this search session.
type DOMPerformSearchResult struct {

	// SearchID Unique search session identifier.
	SearchID string `json:"searchId"`

	// ResultCount Number of search results.
	ResultCount int64 `json:"resultCount"`
}

// DOMPushNodeByPathToFrontend (experimental) Requests that the node is sent to the caller given its path. // FIXME, use XPath
type DOMPushNodeByPathToFrontend struct {

	// Path Path to node in the proprietary format.
	Path string `json:"path"`
}

// Call of the command, sessionID is optional.
func (m DOMPushNodeByPathToFrontend) Call(caller Caller) (*DOMPushNodeByPathToFrontendResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.pushNodeByPathToFrontend", m)
	if err != nil {
		return nil, err
	}

	var res DOMPushNodeByPathToFrontendResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMPushNodeByPathToFrontendResult (experimental) Requests that the node is sent to the caller given its path. // FIXME, use XPath
type DOMPushNodeByPathToFrontendResult struct {

	// NodeID Id of the node for given path.
	NodeID DOMNodeID `json:"nodeId"`
}

// DOMPushNodesByBackendIdsToFrontend (experimental) Requests that a batch of nodes is sent to the caller given their backend node ids.
type DOMPushNodesByBackendIdsToFrontend struct {

	// BackendNodeIds The array of backend node ids.
	BackendNodeIds []DOMBackendNodeID `json:"backendNodeIds"`
}

// Call of the command, sessionID is optional.
func (m DOMPushNodesByBackendIdsToFrontend) Call(caller Caller) (*DOMPushNodesByBackendIdsToFrontendResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.pushNodesByBackendIdsToFrontend", m)
	if err != nil {
		return nil, err
	}

	var res DOMPushNodesByBackendIdsToFrontendResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMPushNodesByBackendIdsToFrontendResult (experimental) Requests that a batch of nodes is sent to the caller given their backend node ids.
type DOMPushNodesByBackendIdsToFrontendResult struct {

	// NodeIds The array of ids of pushed nodes that correspond to the backend ids specified in
	// backendNodeIds.
	NodeIds []DOMNodeID `json:"nodeIds"`
}

// DOMQuerySelector Executes `querySelector` on a given node.
type DOMQuerySelector struct {

	// NodeID Id of the node to query upon.
	NodeID DOMNodeID `json:"nodeId"`

	// Selector Selector string.
	Selector string `json:"selector"`
}

// Call of the command, sessionID is optional.
func (m DOMQuerySelector) Call(caller Caller) (*DOMQuerySelectorResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.querySelector", m)
	if err != nil {
		return nil, err
	}

	var res DOMQuerySelectorResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMQuerySelectorResult Executes `querySelector` on a given node.
type DOMQuerySelectorResult struct {

	// NodeID Query selector result.
	NodeID DOMNodeID `json:"nodeId"`
}

// DOMQuerySelectorAll Executes `querySelectorAll` on a given node.
type DOMQuerySelectorAll struct {

	// NodeID Id of the node to query upon.
	NodeID DOMNodeID `json:"nodeId"`

	// Selector Selector string.
	Selector string `json:"selector"`
}

// Call of the command, sessionID is optional.
func (m DOMQuerySelectorAll) Call(caller Caller) (*DOMQuerySelectorAllResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.querySelectorAll", m)
	if err != nil {
		return nil, err
	}

	var res DOMQuerySelectorAllResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMQuerySelectorAllResult Executes `querySelectorAll` on a given node.
type DOMQuerySelectorAllResult struct {

	// NodeIds Query selector result.
	NodeIds []DOMNodeID `json:"nodeIds"`
}

// DOMRedo (experimental) Re-does the last undone action.
type DOMRedo struct {
}

// Call of the command, sessionID is optional.
func (m DOMRedo) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.redo", m)
	return err
}

// DOMRemoveAttribute Removes attribute with given name from an element with given id.
type DOMRemoveAttribute struct {

	// NodeID Id of the element to remove attribute from.
	NodeID DOMNodeID `json:"nodeId"`

	// Name Name of the attribute to remove.
	Name string `json:"name"`
}

// Call of the command, sessionID is optional.
func (m DOMRemoveAttribute) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.removeAttribute", m)
	return err
}

// DOMRemoveNode Removes node with given id.
type DOMRemoveNode struct {

	// NodeID Id of the node to remove.
	NodeID DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m DOMRemoveNode) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.removeNode", m)
	return err
}

// DOMRequestChildNodes Requests that children of the node with given id are returned to the caller in form of
// `setChildNodes` events where not only immediate children are retrieved, but all children down to
// the specified depth.
type DOMRequestChildNodes struct {

	// NodeID Id of the node to get children for.
	NodeID DOMNodeID `json:"nodeId"`

	// Depth (optional) The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
	// entire subtree or provide an integer larger than 0.
	Depth int64 `json:"depth,omitempty"`

	// Pierce (optional) Whether or not iframes and shadow roots should be traversed when returning the sub-tree
	// (default is false).
	Pierce bool `json:"pierce,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMRequestChildNodes) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.requestChildNodes", m)
	return err
}

// DOMRequestNode Requests that the node is sent to the caller given the JavaScript node object reference. All
// nodes that form the path from the node to the root are also sent to the client as a series of
// `setChildNodes` notifications.
type DOMRequestNode struct {

	// ObjectID JavaScript object id to convert into node.
	ObjectID RuntimeRemoteObjectID `json:"objectId"`
}

// Call of the command, sessionID is optional.
func (m DOMRequestNode) Call(caller Caller) (*DOMRequestNodeResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.requestNode", m)
	if err != nil {
		return nil, err
	}

	var res DOMRequestNodeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMRequestNodeResult Requests that the node is sent to the caller given the JavaScript node object reference. All
// nodes that form the path from the node to the root are also sent to the client as a series of
// `setChildNodes` notifications.
type DOMRequestNodeResult struct {

	// NodeID Node id for given object.
	NodeID DOMNodeID `json:"nodeId"`
}

// DOMResolveNode Resolves the JavaScript node object for a given NodeId or BackendNodeId.
type DOMResolveNode struct {

	// NodeID (optional) Id of the node to resolve.
	NodeID DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID (optional) Backend identifier of the node to resolve.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectGroup (optional) Symbolic group name that can be used to release multiple objects.
	ObjectGroup string `json:"objectGroup,omitempty"`

	// ExecutionContextID (optional) Execution context in which to resolve the node.
	ExecutionContextID RuntimeExecutionContextID `json:"executionContextId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMResolveNode) Call(caller Caller) (*DOMResolveNodeResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.resolveNode", m)
	if err != nil {
		return nil, err
	}

	var res DOMResolveNodeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMResolveNodeResult Resolves the JavaScript node object for a given NodeId or BackendNodeId.
type DOMResolveNodeResult struct {

	// Object JavaScript object wrapper for given node.
	Object *RuntimeRemoteObject `json:"object"`
}

// DOMSetAttributeValue Sets attribute for an element with given id.
type DOMSetAttributeValue struct {

	// NodeID Id of the element to set attribute for.
	NodeID DOMNodeID `json:"nodeId"`

	// Name Attribute name.
	Name string `json:"name"`

	// Value Attribute value.
	Value string `json:"value"`
}

// Call of the command, sessionID is optional.
func (m DOMSetAttributeValue) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.setAttributeValue", m)
	return err
}

// DOMSetAttributesAsText Sets attributes on element with given id. This method is useful when user edits some existing
// attribute value and types in several attribute name/value pairs.
type DOMSetAttributesAsText struct {

	// NodeID Id of the element to set attributes for.
	NodeID DOMNodeID `json:"nodeId"`

	// Text Text with a number of attributes. Will parse this text using HTML parser.
	Text string `json:"text"`

	// Name (optional) Attribute name to replace with new attributes derived from text in case text parsed
	// successfully.
	Name string `json:"name,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMSetAttributesAsText) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.setAttributesAsText", m)
	return err
}

// DOMSetFileInputFiles Sets files for the given file input element.
type DOMSetFileInputFiles struct {

	// Files Array of file paths to set.
	Files []string `json:"files"`

	// NodeID (optional) Identifier of the node.
	NodeID DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID (optional) Identifier of the backend node.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectID (optional) JavaScript object id of the node wrapper.
	ObjectID RuntimeRemoteObjectID `json:"objectId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMSetFileInputFiles) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.setFileInputFiles", m)
	return err
}

// DOMSetNodeStackTracesEnabled (experimental) Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled.
type DOMSetNodeStackTracesEnabled struct {

	// Enable Enable or disable.
	Enable bool `json:"enable"`
}

// Call of the command, sessionID is optional.
func (m DOMSetNodeStackTracesEnabled) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.setNodeStackTracesEnabled", m)
	return err
}

// DOMGetNodeStackTraces (experimental) Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.
type DOMGetNodeStackTraces struct {

	// NodeID Id of the node to get stack traces for.
	NodeID DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m DOMGetNodeStackTraces) Call(caller Caller) (*DOMGetNodeStackTracesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.getNodeStackTraces", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetNodeStackTracesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetNodeStackTracesResult (experimental) Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation.
type DOMGetNodeStackTracesResult struct {

	// Creation (optional) Creation stack trace, if available.
	Creation *RuntimeStackTrace `json:"creation,omitempty"`
}

// DOMGetFileInfo (experimental) Returns file information for the given
// File wrapper.
type DOMGetFileInfo struct {

	// ObjectID JavaScript object id of the node wrapper.
	ObjectID RuntimeRemoteObjectID `json:"objectId"`
}

// Call of the command, sessionID is optional.
func (m DOMGetFileInfo) Call(caller Caller) (*DOMGetFileInfoResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.getFileInfo", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetFileInfoResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetFileInfoResult (experimental) Returns file information for the given
// File wrapper.
type DOMGetFileInfoResult struct {

	// Path ...
	Path string `json:"path"`
}

// DOMSetInspectedNode (experimental) Enables console to refer to the node with given id via $x (see Command Line API for more details
// $x functions).
type DOMSetInspectedNode struct {

	// NodeID DOM node id to be accessible by means of $x command line API.
	NodeID DOMNodeID `json:"nodeId"`
}

// Call of the command, sessionID is optional.
func (m DOMSetInspectedNode) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.setInspectedNode", m)
	return err
}

// DOMSetNodeName Sets node name for a node with given id.
type DOMSetNodeName struct {

	// NodeID Id of the node to set name for.
	NodeID DOMNodeID `json:"nodeId"`

	// Name New node's name.
	Name string `json:"name"`
}

// Call of the command, sessionID is optional.
func (m DOMSetNodeName) Call(caller Caller) (*DOMSetNodeNameResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.setNodeName", m)
	if err != nil {
		return nil, err
	}

	var res DOMSetNodeNameResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMSetNodeNameResult Sets node name for a node with given id.
type DOMSetNodeNameResult struct {

	// NodeID New node's id.
	NodeID DOMNodeID `json:"nodeId"`
}

// DOMSetNodeValue Sets node value for a node with given id.
type DOMSetNodeValue struct {

	// NodeID Id of the node to set value for.
	NodeID DOMNodeID `json:"nodeId"`

	// Value New node's value.
	Value string `json:"value"`
}

// Call of the command, sessionID is optional.
func (m DOMSetNodeValue) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.setNodeValue", m)
	return err
}

// DOMSetOuterHTML Sets node HTML markup, returns new node id.
type DOMSetOuterHTML struct {

	// NodeID Id of the node to set markup for.
	NodeID DOMNodeID `json:"nodeId"`

	// OuterHTML Outer HTML markup to set.
	OuterHTML string `json:"outerHTML"`
}

// Call of the command, sessionID is optional.
func (m DOMSetOuterHTML) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.setOuterHTML", m)
	return err
}

// DOMUndo (experimental) Undoes the last performed action.
type DOMUndo struct {
}

// Call of the command, sessionID is optional.
func (m DOMUndo) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOM.undo", m)
	return err
}

// DOMGetFrameOwner (experimental) Returns iframe node that owns iframe with the given domain.
type DOMGetFrameOwner struct {

	// FrameID ...
	FrameID PageFrameID `json:"frameId"`
}

// Call of the command, sessionID is optional.
func (m DOMGetFrameOwner) Call(caller Caller) (*DOMGetFrameOwnerResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOM.getFrameOwner", m)
	if err != nil {
		return nil, err
	}

	var res DOMGetFrameOwnerResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMGetFrameOwnerResult (experimental) Returns iframe node that owns iframe with the given domain.
type DOMGetFrameOwnerResult struct {

	// BackendNodeID Resulting node.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId"`

	// NodeID (optional) Id of the node at given coordinates, only when enabled and requested document.
	NodeID DOMNodeID `json:"nodeId,omitempty"`
}

// DOMAttributeModified Fired when `Element`'s attribute is modified.
type DOMAttributeModified struct {

	// NodeID Id of the node that has changed.
	NodeID DOMNodeID `json:"nodeId"`

	// Name Attribute name.
	Name string `json:"name"`

	// Value Attribute value.
	Value string `json:"value"`
}

// MethodName interface
func (evt DOMAttributeModified) MethodName() string {
	return "DOM.attributeModified"
}

// DOMAttributeRemoved Fired when `Element`'s attribute is removed.
type DOMAttributeRemoved struct {

	// NodeID Id of the node that has changed.
	NodeID DOMNodeID `json:"nodeId"`

	// Name A ttribute name.
	Name string `json:"name"`
}

// MethodName interface
func (evt DOMAttributeRemoved) MethodName() string {
	return "DOM.attributeRemoved"
}

// DOMCharacterDataModified Mirrors `DOMCharacterDataModified` event.
type DOMCharacterDataModified struct {

	// NodeID Id of the node that has changed.
	NodeID DOMNodeID `json:"nodeId"`

	// CharacterData New text value.
	CharacterData string `json:"characterData"`
}

// MethodName interface
func (evt DOMCharacterDataModified) MethodName() string {
	return "DOM.characterDataModified"
}

// DOMChildNodeCountUpdated Fired when `Container`'s child node count has changed.
type DOMChildNodeCountUpdated struct {

	// NodeID Id of the node that has changed.
	NodeID DOMNodeID `json:"nodeId"`

	// ChildNodeCount New node count.
	ChildNodeCount int64 `json:"childNodeCount"`
}

// MethodName interface
func (evt DOMChildNodeCountUpdated) MethodName() string {
	return "DOM.childNodeCountUpdated"
}

// DOMChildNodeInserted Mirrors `DOMNodeInserted` event.
type DOMChildNodeInserted struct {

	// ParentNodeID Id of the node that has changed.
	ParentNodeID DOMNodeID `json:"parentNodeId"`

	// PreviousNodeID If of the previous siblint.
	PreviousNodeID DOMNodeID `json:"previousNodeId"`

	// Node Inserted node data.
	Node *DOMNode `json:"node"`
}

// MethodName interface
func (evt DOMChildNodeInserted) MethodName() string {
	return "DOM.childNodeInserted"
}

// DOMChildNodeRemoved Mirrors `DOMNodeRemoved` event.
type DOMChildNodeRemoved struct {

	// ParentNodeID Parent id.
	ParentNodeID DOMNodeID `json:"parentNodeId"`

	// NodeID Id of the node that has been removed.
	NodeID DOMNodeID `json:"nodeId"`
}

// MethodName interface
func (evt DOMChildNodeRemoved) MethodName() string {
	return "DOM.childNodeRemoved"
}

// DOMDistributedNodesUpdated (experimental) Called when distrubution is changed.
type DOMDistributedNodesUpdated struct {

	// InsertionPointID Insertion point where distrubuted nodes were updated.
	InsertionPointID DOMNodeID `json:"insertionPointId"`

	// DistributedNodes Distributed nodes for given insertion point.
	DistributedNodes []*DOMBackendNode `json:"distributedNodes"`
}

// MethodName interface
func (evt DOMDistributedNodesUpdated) MethodName() string {
	return "DOM.distributedNodesUpdated"
}

// DOMDocumentUpdated Fired when `Document` has been totally updated. Node ids are no longer valid.
type DOMDocumentUpdated struct {
}

// MethodName interface
func (evt DOMDocumentUpdated) MethodName() string {
	return "DOM.documentUpdated"
}

// DOMInlineStyleInvalidated (experimental) Fired when `Element`'s inline style is modified via a CSS property modification.
type DOMInlineStyleInvalidated struct {

	// NodeIds Ids of the nodes for which the inline styles have been invalidated.
	NodeIds []DOMNodeID `json:"nodeIds"`
}

// MethodName interface
func (evt DOMInlineStyleInvalidated) MethodName() string {
	return "DOM.inlineStyleInvalidated"
}

// DOMPseudoElementAdded (experimental) Called when a pseudo element is added to an element.
type DOMPseudoElementAdded struct {

	// ParentID Pseudo element's parent element id.
	ParentID DOMNodeID `json:"parentId"`

	// PseudoElement The added pseudo element.
	PseudoElement *DOMNode `json:"pseudoElement"`
}

// MethodName interface
func (evt DOMPseudoElementAdded) MethodName() string {
	return "DOM.pseudoElementAdded"
}

// DOMPseudoElementRemoved (experimental) Called when a pseudo element is removed from an element.
type DOMPseudoElementRemoved struct {

	// ParentID Pseudo element's parent element id.
	ParentID DOMNodeID `json:"parentId"`

	// PseudoElementID The removed pseudo element id.
	PseudoElementID DOMNodeID `json:"pseudoElementId"`
}

// MethodName interface
func (evt DOMPseudoElementRemoved) MethodName() string {
	return "DOM.pseudoElementRemoved"
}

// DOMSetChildNodes Fired when backend wants to provide client with the missing DOM structure. This happens upon
// most of the calls requesting node ids.
type DOMSetChildNodes struct {

	// ParentID Parent node id to populate with children.
	ParentID DOMNodeID `json:"parentId"`

	// Nodes Child nodes array.
	Nodes []*DOMNode `json:"nodes"`
}

// MethodName interface
func (evt DOMSetChildNodes) MethodName() string {
	return "DOM.setChildNodes"
}

// DOMShadowRootPopped (experimental) Called when shadow root is popped from the element.
type DOMShadowRootPopped struct {

	// HostID Host element id.
	HostID DOMNodeID `json:"hostId"`

	// RootID Shadow root id.
	RootID DOMNodeID `json:"rootId"`
}

// MethodName interface
func (evt DOMShadowRootPopped) MethodName() string {
	return "DOM.shadowRootPopped"
}

// DOMShadowRootPushed (experimental) Called when shadow root is pushed into the element.
type DOMShadowRootPushed struct {

	// HostID Host element id.
	HostID DOMNodeID `json:"hostId"`

	// Root Shadow root.
	Root *DOMNode `json:"root"`
}

// MethodName interface
func (evt DOMShadowRootPushed) MethodName() string {
	return "DOM.shadowRootPushed"
}

// DOMDebuggerDOMBreakpointType DOM breakpoint type.
type DOMDebuggerDOMBreakpointType string

const (
	// DOMDebuggerDOMBreakpointTypeSubtreeModified enum const
	DOMDebuggerDOMBreakpointTypeSubtreeModified DOMDebuggerDOMBreakpointType = "subtree-modified"

	// DOMDebuggerDOMBreakpointTypeAttributeModified enum const
	DOMDebuggerDOMBreakpointTypeAttributeModified DOMDebuggerDOMBreakpointType = "attribute-modified"

	// DOMDebuggerDOMBreakpointTypeNodeRemoved enum const
	DOMDebuggerDOMBreakpointTypeNodeRemoved DOMDebuggerDOMBreakpointType = "node-removed"
)

// DOMDebuggerEventListener Object event listener.
type DOMDebuggerEventListener struct {

	// Type `EventListener`'s type.
	Type string `json:"type"`

	// UseCapture `EventListener`'s useCapture.
	UseCapture bool `json:"useCapture"`

	// Passive `EventListener`'s passive flag.
	Passive bool `json:"passive"`

	// Once `EventListener`'s once flag.
	Once bool `json:"once"`

	// ScriptID Script id of the handler code.
	ScriptID RuntimeScriptID `json:"scriptId"`

	// LineNumber Line number in the script (0-based).
	LineNumber int64 `json:"lineNumber"`

	// ColumnNumber Column number in the script (0-based).
	ColumnNumber int64 `json:"columnNumber"`

	// Handler (optional) Event handler function value.
	Handler *RuntimeRemoteObject `json:"handler,omitempty"`

	// OriginalHandler (optional) Event original handler function value.
	OriginalHandler *RuntimeRemoteObject `json:"originalHandler,omitempty"`

	// BackendNodeID (optional) Node the listener is added to (if any).
	BackendNodeID DOMBackendNodeID `json:"backendNodeId,omitempty"`
}

// DOMDebuggerGetEventListeners Returns event listeners of the given object.
type DOMDebuggerGetEventListeners struct {

	// ObjectID Identifier of the object to return listeners for.
	ObjectID RuntimeRemoteObjectID `json:"objectId"`

	// Depth (optional) The maximum depth at which Node children should be retrieved, defaults to 1. Use -1 for the
	// entire subtree or provide an integer larger than 0.
	Depth int64 `json:"depth,omitempty"`

	// Pierce (optional) Whether or not iframes and shadow roots should be traversed when returning the subtree
	// (default is false). Reports listeners for all contexts if pierce is enabled.
	Pierce bool `json:"pierce,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMDebuggerGetEventListeners) Call(caller Caller) (*DOMDebuggerGetEventListenersResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOMDebugger.getEventListeners", m)
	if err != nil {
		return nil, err
	}

	var res DOMDebuggerGetEventListenersResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMDebuggerGetEventListenersResult Returns event listeners of the given object.
type DOMDebuggerGetEventListenersResult struct {

	// Listeners Array of relevant listeners.
	Listeners []*DOMDebuggerEventListener `json:"listeners"`
}

// DOMDebuggerRemoveDOMBreakpoint Removes DOM breakpoint that was set using `setDOMBreakpoint`.
type DOMDebuggerRemoveDOMBreakpoint struct {

	// NodeID Identifier of the node to remove breakpoint from.
	NodeID DOMNodeID `json:"nodeId"`

	// Type Type of the breakpoint to remove.
	Type DOMDebuggerDOMBreakpointType `json:"type"`
}

// Call of the command, sessionID is optional.
func (m DOMDebuggerRemoveDOMBreakpoint) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOMDebugger.removeDOMBreakpoint", m)
	return err
}

// DOMDebuggerRemoveEventListenerBreakpoint Removes breakpoint on particular DOM event.
type DOMDebuggerRemoveEventListenerBreakpoint struct {

	// EventName Event name.
	EventName string `json:"eventName"`

	// TargetName (experimental) (optional) EventTarget interface name.
	TargetName string `json:"targetName,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMDebuggerRemoveEventListenerBreakpoint) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOMDebugger.removeEventListenerBreakpoint", m)
	return err
}

// DOMDebuggerRemoveInstrumentationBreakpoint (experimental) Removes breakpoint on particular native event.
type DOMDebuggerRemoveInstrumentationBreakpoint struct {

	// EventName Instrumentation name to stop on.
	EventName string `json:"eventName"`
}

// Call of the command, sessionID is optional.
func (m DOMDebuggerRemoveInstrumentationBreakpoint) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOMDebugger.removeInstrumentationBreakpoint", m)
	return err
}

// DOMDebuggerRemoveXHRBreakpoint Removes breakpoint from XMLHttpRequest.
type DOMDebuggerRemoveXHRBreakpoint struct {

	// URL Resource URL substring.
	URL string `json:"url"`
}

// Call of the command, sessionID is optional.
func (m DOMDebuggerRemoveXHRBreakpoint) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOMDebugger.removeXHRBreakpoint", m)
	return err
}

// DOMDebuggerSetDOMBreakpoint Sets breakpoint on particular operation with DOM.
type DOMDebuggerSetDOMBreakpoint struct {

	// NodeID Identifier of the node to set breakpoint on.
	NodeID DOMNodeID `json:"nodeId"`

	// Type Type of the operation to stop upon.
	Type DOMDebuggerDOMBreakpointType `json:"type"`
}

// Call of the command, sessionID is optional.
func (m DOMDebuggerSetDOMBreakpoint) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOMDebugger.setDOMBreakpoint", m)
	return err
}

// DOMDebuggerSetEventListenerBreakpoint Sets breakpoint on particular DOM event.
type DOMDebuggerSetEventListenerBreakpoint struct {

	// EventName DOM Event name to stop on (any DOM event will do).
	EventName string `json:"eventName"`

	// TargetName (experimental) (optional) EventTarget interface name to stop on. If equal to `"*"` or not provided, will stop on any
	// EventTarget.
	TargetName string `json:"targetName,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMDebuggerSetEventListenerBreakpoint) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOMDebugger.setEventListenerBreakpoint", m)
	return err
}

// DOMDebuggerSetInstrumentationBreakpoint (experimental) Sets breakpoint on particular native event.
type DOMDebuggerSetInstrumentationBreakpoint struct {

	// EventName Instrumentation name to stop on.
	EventName string `json:"eventName"`
}

// Call of the command, sessionID is optional.
func (m DOMDebuggerSetInstrumentationBreakpoint) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOMDebugger.setInstrumentationBreakpoint", m)
	return err
}

// DOMDebuggerSetXHRBreakpoint Sets breakpoint on XMLHttpRequest.
type DOMDebuggerSetXHRBreakpoint struct {

	// URL Resource URL substring. All XHRs having this substring in the URL will get stopped upon.
	URL string `json:"url"`
}

// Call of the command, sessionID is optional.
func (m DOMDebuggerSetXHRBreakpoint) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOMDebugger.setXHRBreakpoint", m)
	return err
}

// DOMSnapshotDOMNode A Node in the DOM tree.
type DOMSnapshotDOMNode struct {

	// NodeType `Node`'s nodeType.
	NodeType int64 `json:"nodeType"`

	// NodeName `Node`'s nodeName.
	NodeName string `json:"nodeName"`

	// NodeValue `Node`'s nodeValue.
	NodeValue string `json:"nodeValue"`

	// TextValue (optional) Only set for textarea elements, contains the text value.
	TextValue string `json:"textValue,omitempty"`

	// InputValue (optional) Only set for input elements, contains the input's associated text value.
	InputValue string `json:"inputValue,omitempty"`

	// InputChecked (optional) Only set for radio and checkbox input elements, indicates if the element has been checked
	InputChecked bool `json:"inputChecked,omitempty"`

	// OptionSelected (optional) Only set for option elements, indicates if the element has been selected
	OptionSelected bool `json:"optionSelected,omitempty"`

	// BackendNodeID `Node`'s id, corresponds to DOM.Node.backendNodeId.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId"`

	// ChildNodeIndexes (optional) The indexes of the node's child nodes in the `domNodes` array returned by `getSnapshot`, if
	// any.
	ChildNodeIndexes []int64 `json:"childNodeIndexes,omitempty"`

	// Attributes (optional) Attributes of an `Element` node.
	Attributes []*DOMSnapshotNameValue `json:"attributes,omitempty"`

	// PseudoElementIndexes (optional) Indexes of pseudo elements associated with this node in the `domNodes` array returned by
	// `getSnapshot`, if any.
	PseudoElementIndexes []int64 `json:"pseudoElementIndexes,omitempty"`

	// LayoutNodeIndex (optional) The index of the node's related layout tree node in the `layoutTreeNodes` array returned by
	// `getSnapshot`, if any.
	LayoutNodeIndex int64 `json:"layoutNodeIndex,omitempty"`

	// DocumentURL (optional) Document URL that `Document` or `FrameOwner` node points to.
	DocumentURL string `json:"documentURL,omitempty"`

	// BaseURL (optional) Base URL that `Document` or `FrameOwner` node uses for URL completion.
	BaseURL string `json:"baseURL,omitempty"`

	// ContentLanguage (optional) Only set for documents, contains the document's content language.
	ContentLanguage string `json:"contentLanguage,omitempty"`

	// DocumentEncoding (optional) Only set for documents, contains the document's character set encoding.
	DocumentEncoding string `json:"documentEncoding,omitempty"`

	// PublicID (optional) `DocumentType` node's publicId.
	PublicID string `json:"publicId,omitempty"`

	// SystemID (optional) `DocumentType` node's systemId.
	SystemID string `json:"systemId,omitempty"`

	// FrameID (optional) Frame ID for frame owner elements and also for the document node.
	FrameID PageFrameID `json:"frameId,omitempty"`

	// ContentDocumentIndex (optional) The index of a frame owner element's content document in the `domNodes` array returned by
	// `getSnapshot`, if any.
	ContentDocumentIndex int64 `json:"contentDocumentIndex,omitempty"`

	// PseudoType (optional) Type of a pseudo element node.
	PseudoType DOMPseudoType `json:"pseudoType,omitempty"`

	// ShadowRootType (optional) Shadow root type.
	ShadowRootType DOMShadowRootType `json:"shadowRootType,omitempty"`

	// IsClickable (optional) Whether this DOM node responds to mouse clicks. This includes nodes that have had click
	// event listeners attached via JavaScript as well as anchor tags that naturally navigate when
	// clicked.
	IsClickable bool `json:"isClickable,omitempty"`

	// EventListeners (optional) Details of the node's event listeners, if any.
	EventListeners []*DOMDebuggerEventListener `json:"eventListeners,omitempty"`

	// CurrentSourceURL (optional) The selected url for nodes with a srcset attribute.
	CurrentSourceURL string `json:"currentSourceURL,omitempty"`

	// OriginURL (optional) The url of the script (if any) that generates this node.
	OriginURL string `json:"originURL,omitempty"`

	// ScrollOffsetX (optional) Scroll offsets, set when this node is a Document.
	ScrollOffsetX float64 `json:"scrollOffsetX,omitempty"`

	// ScrollOffsetY (optional) ...
	ScrollOffsetY float64 `json:"scrollOffsetY,omitempty"`
}

// DOMSnapshotInlineTextBox Details of post layout rendered text positions. The exact layout should not be regarded as
// stable and may change between versions.
type DOMSnapshotInlineTextBox struct {

	// BoundingBox The bounding box in document coordinates. Note that scroll offset of the document is ignored.
	BoundingBox *DOMRect `json:"boundingBox"`

	// StartCharacterIndex The starting index in characters, for this post layout textbox substring. Characters that
	// would be represented as a surrogate pair in UTF-16 have length 2.
	StartCharacterIndex int64 `json:"startCharacterIndex"`

	// NumCharacters The number of characters in this post layout textbox substring. Characters that would be
	// represented as a surrogate pair in UTF-16 have length 2.
	NumCharacters int64 `json:"numCharacters"`
}

// DOMSnapshotLayoutTreeNode Details of an element in the DOM tree with a LayoutObject.
type DOMSnapshotLayoutTreeNode struct {

	// DomNodeIndex The index of the related DOM node in the `domNodes` array returned by `getSnapshot`.
	DomNodeIndex int64 `json:"domNodeIndex"`

	// BoundingBox The bounding box in document coordinates. Note that scroll offset of the document is ignored.
	BoundingBox *DOMRect `json:"boundingBox"`

	// LayoutText (optional) Contents of the LayoutText, if any.
	LayoutText string `json:"layoutText,omitempty"`

	// InlineTextNodes (optional) The post-layout inline text nodes, if any.
	InlineTextNodes []*DOMSnapshotInlineTextBox `json:"inlineTextNodes,omitempty"`

	// StyleIndex (optional) Index into the `computedStyles` array returned by `getSnapshot`.
	StyleIndex int64 `json:"styleIndex,omitempty"`

	// PaintOrder (optional) Global paint order index, which is determined by the stacking order of the nodes. Nodes
	// that are painted together will have the same index. Only provided if includePaintOrder in
	// getSnapshot was true.
	PaintOrder int64 `json:"paintOrder,omitempty"`

	// IsStackingContext (optional) Set to true to indicate the element begins a new stacking context.
	IsStackingContext bool `json:"isStackingContext,omitempty"`
}

// DOMSnapshotComputedStyle A subset of the full ComputedStyle as defined by the request whitelist.
type DOMSnapshotComputedStyle struct {

	// Properties Name/value pairs of computed style properties.
	Properties []*DOMSnapshotNameValue `json:"properties"`
}

// DOMSnapshotNameValue A name/value pair.
type DOMSnapshotNameValue struct {

	// Name Attribute/property name.
	Name string `json:"name"`

	// Value Attribute/property value.
	Value string `json:"value"`
}

// DOMSnapshotStringIndex Index of the string in the strings table.
type DOMSnapshotStringIndex int64

// DOMSnapshotArrayOfStrings Index of the string in the strings table.
type DOMSnapshotArrayOfStrings []DOMSnapshotStringIndex

// DOMSnapshotRareStringData Data that is only present on rare nodes.
type DOMSnapshotRareStringData struct {

	// Index ...
	Index []int64 `json:"index"`

	// Value ...
	Value []DOMSnapshotStringIndex `json:"value"`
}

// DOMSnapshotRareBooleanData ...
type DOMSnapshotRareBooleanData struct {

	// Index ...
	Index []int64 `json:"index"`
}

// DOMSnapshotRareIntegerData ...
type DOMSnapshotRareIntegerData struct {

	// Index ...
	Index []int64 `json:"index"`

	// Value ...
	Value []int64 `json:"value"`
}

// DOMSnapshotRectangle ...
type DOMSnapshotRectangle []float64

// DOMSnapshotDocumentSnapshot Document snapshot.
type DOMSnapshotDocumentSnapshot struct {

	// DocumentURL Document URL that `Document` or `FrameOwner` node points to.
	DocumentURL DOMSnapshotStringIndex `json:"documentURL"`

	// Title Document title.
	Title DOMSnapshotStringIndex `json:"title"`

	// BaseURL Base URL that `Document` or `FrameOwner` node uses for URL completion.
	BaseURL DOMSnapshotStringIndex `json:"baseURL"`

	// ContentLanguage Contains the document's content language.
	ContentLanguage DOMSnapshotStringIndex `json:"contentLanguage"`

	// EncodingName Contains the document's character set encoding.
	EncodingName DOMSnapshotStringIndex `json:"encodingName"`

	// PublicID `DocumentType` node's publicId.
	PublicID DOMSnapshotStringIndex `json:"publicId"`

	// SystemID `DocumentType` node's systemId.
	SystemID DOMSnapshotStringIndex `json:"systemId"`

	// FrameID Frame ID for frame owner elements and also for the document node.
	FrameID DOMSnapshotStringIndex `json:"frameId"`

	// Nodes A table with dom nodes.
	Nodes *DOMSnapshotNodeTreeSnapshot `json:"nodes"`

	// Layout The nodes in the layout tree.
	Layout *DOMSnapshotLayoutTreeSnapshot `json:"layout"`

	// TextBoxes The post-layout inline text nodes.
	TextBoxes *DOMSnapshotTextBoxSnapshot `json:"textBoxes"`

	// ScrollOffsetX (optional) Horizontal scroll offset.
	ScrollOffsetX float64 `json:"scrollOffsetX,omitempty"`

	// ScrollOffsetY (optional) Vertical scroll offset.
	ScrollOffsetY float64 `json:"scrollOffsetY,omitempty"`

	// ContentWidth (optional) Document content width.
	ContentWidth float64 `json:"contentWidth,omitempty"`

	// ContentHeight (optional) Document content height.
	ContentHeight float64 `json:"contentHeight,omitempty"`
}

// DOMSnapshotNodeTreeSnapshot Table containing nodes.
type DOMSnapshotNodeTreeSnapshot struct {

	// ParentIndex (optional) Parent node index.
	ParentIndex []int64 `json:"parentIndex,omitempty"`

	// NodeType (optional) `Node`'s nodeType.
	NodeType []int64 `json:"nodeType,omitempty"`

	// NodeName (optional) `Node`'s nodeName.
	NodeName []DOMSnapshotStringIndex `json:"nodeName,omitempty"`

	// NodeValue (optional) `Node`'s nodeValue.
	NodeValue []DOMSnapshotStringIndex `json:"nodeValue,omitempty"`

	// BackendNodeID (optional) `Node`'s id, corresponds to DOM.Node.backendNodeId.
	BackendNodeID []DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// Attributes (optional) Attributes of an `Element` node. Flatten name, value pairs.
	Attributes []DOMSnapshotArrayOfStrings `json:"attributes,omitempty"`

	// TextValue (optional) Only set for textarea elements, contains the text value.
	TextValue *DOMSnapshotRareStringData `json:"textValue,omitempty"`

	// InputValue (optional) Only set for input elements, contains the input's associated text value.
	InputValue *DOMSnapshotRareStringData `json:"inputValue,omitempty"`

	// InputChecked (optional) Only set for radio and checkbox input elements, indicates if the element has been checked
	InputChecked *DOMSnapshotRareBooleanData `json:"inputChecked,omitempty"`

	// OptionSelected (optional) Only set for option elements, indicates if the element has been selected
	OptionSelected *DOMSnapshotRareBooleanData `json:"optionSelected,omitempty"`

	// ContentDocumentIndex (optional) The index of the document in the list of the snapshot documents.
	ContentDocumentIndex *DOMSnapshotRareIntegerData `json:"contentDocumentIndex,omitempty"`

	// PseudoType (optional) Type of a pseudo element node.
	PseudoType *DOMSnapshotRareStringData `json:"pseudoType,omitempty"`

	// IsClickable (optional) Whether this DOM node responds to mouse clicks. This includes nodes that have had click
	// event listeners attached via JavaScript as well as anchor tags that naturally navigate when
	// clicked.
	IsClickable *DOMSnapshotRareBooleanData `json:"isClickable,omitempty"`

	// CurrentSourceURL (optional) The selected url for nodes with a srcset attribute.
	CurrentSourceURL *DOMSnapshotRareStringData `json:"currentSourceURL,omitempty"`

	// OriginURL (optional) The url of the script (if any) that generates this node.
	OriginURL *DOMSnapshotRareStringData `json:"originURL,omitempty"`
}

// DOMSnapshotLayoutTreeSnapshot Table of details of an element in the DOM tree with a LayoutObject.
type DOMSnapshotLayoutTreeSnapshot struct {

	// NodeIndex Index of the corresponding node in the `NodeTreeSnapshot` array returned by `captureSnapshot`.
	NodeIndex []int64 `json:"nodeIndex"`

	// Styles Array of indexes specifying computed style strings, filtered according to the `computedStyles` parameter passed to `captureSnapshot`.
	Styles []DOMSnapshotArrayOfStrings `json:"styles"`

	// Bounds The absolute position bounding box.
	Bounds []DOMSnapshotRectangle `json:"bounds"`

	// Text Contents of the LayoutText, if any.
	Text []DOMSnapshotStringIndex `json:"text"`

	// StackingContexts Stacking context information.
	StackingContexts *DOMSnapshotRareBooleanData `json:"stackingContexts"`

	// PaintOrders (optional) Global paint order index, which is determined by the stacking order of the nodes. Nodes
	// that are painted together will have the same index. Only provided if includePaintOrder in
	// captureSnapshot was true.
	PaintOrders []int64 `json:"paintOrders,omitempty"`

	// OffsetRects (optional) The offset rect of nodes. Only available when includeDOMRects is set to true
	OffsetRects []DOMSnapshotRectangle `json:"offsetRects,omitempty"`

	// ScrollRects (optional) The scroll rect of nodes. Only available when includeDOMRects is set to true
	ScrollRects []DOMSnapshotRectangle `json:"scrollRects,omitempty"`

	// ClientRects (optional) The client rect of nodes. Only available when includeDOMRects is set to true
	ClientRects []DOMSnapshotRectangle `json:"clientRects,omitempty"`
}

// DOMSnapshotTextBoxSnapshot Table of details of the post layout rendered text positions. The exact layout should not be regarded as
// stable and may change between versions.
type DOMSnapshotTextBoxSnapshot struct {

	// LayoutIndex Index of the layout tree node that owns this box collection.
	LayoutIndex []int64 `json:"layoutIndex"`

	// Bounds The absolute position bounding box.
	Bounds []DOMSnapshotRectangle `json:"bounds"`

	// Start The starting index in characters, for this post layout textbox substring. Characters that
	// would be represented as a surrogate pair in UTF-16 have length 2.
	Start []int64 `json:"start"`

	// Length The number of characters in this post layout textbox substring. Characters that would be
	// represented as a surrogate pair in UTF-16 have length 2.
	Length []int64 `json:"length"`
}

// DOMSnapshotDisable Disables DOM snapshot agent for the given page.
type DOMSnapshotDisable struct {
}

// Call of the command, sessionID is optional.
func (m DOMSnapshotDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOMSnapshot.disable", m)
	return err
}

// DOMSnapshotEnable Enables DOM snapshot agent for the given page.
type DOMSnapshotEnable struct {
}

// Call of the command, sessionID is optional.
func (m DOMSnapshotEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOMSnapshot.enable", m)
	return err
}

// DOMSnapshotGetSnapshot (deprecated) Returns a document snapshot, including the full DOM tree of the root node (including iframes,
// template contents, and imported documents) in a flattened array, as well as layout and
// white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
// flattened.
type DOMSnapshotGetSnapshot struct {

	// ComputedStyleWhitelist Whitelist of computed styles to return.
	ComputedStyleWhitelist []string `json:"computedStyleWhitelist"`

	// IncludeEventListeners (optional) Whether or not to retrieve details of DOM listeners (default false).
	IncludeEventListeners bool `json:"includeEventListeners,omitempty"`

	// IncludePaintOrder (optional) Whether to determine and include the paint order index of LayoutTreeNodes (default false).
	IncludePaintOrder bool `json:"includePaintOrder,omitempty"`

	// IncludeUserAgentShadowTree (optional) Whether to include UA shadow tree in the snapshot (default false).
	IncludeUserAgentShadowTree bool `json:"includeUserAgentShadowTree,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMSnapshotGetSnapshot) Call(caller Caller) (*DOMSnapshotGetSnapshotResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOMSnapshot.getSnapshot", m)
	if err != nil {
		return nil, err
	}

	var res DOMSnapshotGetSnapshotResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMSnapshotGetSnapshotResult (deprecated) Returns a document snapshot, including the full DOM tree of the root node (including iframes,
// template contents, and imported documents) in a flattened array, as well as layout and
// white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
// flattened.
type DOMSnapshotGetSnapshotResult struct {

	// DomNodes The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
	DomNodes []*DOMSnapshotDOMNode `json:"domNodes"`

	// LayoutTreeNodes The nodes in the layout tree.
	LayoutTreeNodes []*DOMSnapshotLayoutTreeNode `json:"layoutTreeNodes"`

	// ComputedStyles Whitelisted ComputedStyle properties for each node in the layout tree.
	ComputedStyles []*DOMSnapshotComputedStyle `json:"computedStyles"`
}

// DOMSnapshotCaptureSnapshot Returns a document snapshot, including the full DOM tree of the root node (including iframes,
// template contents, and imported documents) in a flattened array, as well as layout and
// white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
// flattened.
type DOMSnapshotCaptureSnapshot struct {

	// ComputedStyles Whitelist of computed styles to return.
	ComputedStyles []string `json:"computedStyles"`

	// IncludePaintOrder (optional) Whether to include layout object paint orders into the snapshot.
	IncludePaintOrder bool `json:"includePaintOrder,omitempty"`

	// IncludeDOMRects (optional) Whether to include DOM rectangles (offsetRects, clientRects, scrollRects) into the snapshot
	IncludeDOMRects bool `json:"includeDOMRects,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DOMSnapshotCaptureSnapshot) Call(caller Caller) (*DOMSnapshotCaptureSnapshotResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOMSnapshot.captureSnapshot", m)
	if err != nil {
		return nil, err
	}

	var res DOMSnapshotCaptureSnapshotResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMSnapshotCaptureSnapshotResult Returns a document snapshot, including the full DOM tree of the root node (including iframes,
// template contents, and imported documents) in a flattened array, as well as layout and
// white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
// flattened.
type DOMSnapshotCaptureSnapshotResult struct {

	// Documents The nodes in the DOM tree. The DOMNode at index 0 corresponds to the root document.
	Documents []*DOMSnapshotDocumentSnapshot `json:"documents"`

	// Strings Shared string table that all string properties refer to with indexes.
	Strings []string `json:"strings"`
}

// DOMStorageStorageID DOM Storage identifier.
type DOMStorageStorageID struct {

	// SecurityOrigin Security origin for the storage.
	SecurityOrigin string `json:"securityOrigin"`

	// IsLocalStorage Whether the storage is local storage (not session storage).
	IsLocalStorage bool `json:"isLocalStorage"`
}

// DOMStorageItem DOM Storage item.
type DOMStorageItem []string

// DOMStorageClear ...
type DOMStorageClear struct {

	// StorageID ...
	StorageID *DOMStorageStorageID `json:"storageId"`
}

// Call of the command, sessionID is optional.
func (m DOMStorageClear) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOMStorage.clear", m)
	return err
}

// DOMStorageDisable Disables storage tracking, prevents storage events from being sent to the client.
type DOMStorageDisable struct {
}

// Call of the command, sessionID is optional.
func (m DOMStorageDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOMStorage.disable", m)
	return err
}

// DOMStorageEnable Enables storage tracking, storage events will now be delivered to the client.
type DOMStorageEnable struct {
}

// Call of the command, sessionID is optional.
func (m DOMStorageEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOMStorage.enable", m)
	return err
}

// DOMStorageGetDOMStorageItems ...
type DOMStorageGetDOMStorageItems struct {

	// StorageID ...
	StorageID *DOMStorageStorageID `json:"storageId"`
}

// Call of the command, sessionID is optional.
func (m DOMStorageGetDOMStorageItems) Call(caller Caller) (*DOMStorageGetDOMStorageItemsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "DOMStorage.getDOMStorageItems", m)
	if err != nil {
		return nil, err
	}

	var res DOMStorageGetDOMStorageItemsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DOMStorageGetDOMStorageItemsResult ...
type DOMStorageGetDOMStorageItemsResult struct {

	// Entries ...
	Entries []DOMStorageItem `json:"entries"`
}

// DOMStorageRemoveDOMStorageItem ...
type DOMStorageRemoveDOMStorageItem struct {

	// StorageID ...
	StorageID *DOMStorageStorageID `json:"storageId"`

	// Key ...
	Key string `json:"key"`
}

// Call of the command, sessionID is optional.
func (m DOMStorageRemoveDOMStorageItem) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOMStorage.removeDOMStorageItem", m)
	return err
}

// DOMStorageSetDOMStorageItem ...
type DOMStorageSetDOMStorageItem struct {

	// StorageID ...
	StorageID *DOMStorageStorageID `json:"storageId"`

	// Key ...
	Key string `json:"key"`

	// Value ...
	Value string `json:"value"`
}

// Call of the command, sessionID is optional.
func (m DOMStorageSetDOMStorageItem) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DOMStorage.setDOMStorageItem", m)
	return err
}

// DOMStorageDomStorageItemAdded ...
type DOMStorageDomStorageItemAdded struct {

	// StorageID ...
	StorageID *DOMStorageStorageID `json:"storageId"`

	// Key ...
	Key string `json:"key"`

	// NewValue ...
	NewValue string `json:"newValue"`
}

// MethodName interface
func (evt DOMStorageDomStorageItemAdded) MethodName() string {
	return "DOMStorage.domStorageItemAdded"
}

// DOMStorageDomStorageItemRemoved ...
type DOMStorageDomStorageItemRemoved struct {

	// StorageID ...
	StorageID *DOMStorageStorageID `json:"storageId"`

	// Key ...
	Key string `json:"key"`
}

// MethodName interface
func (evt DOMStorageDomStorageItemRemoved) MethodName() string {
	return "DOMStorage.domStorageItemRemoved"
}

// DOMStorageDomStorageItemUpdated ...
type DOMStorageDomStorageItemUpdated struct {

	// StorageID ...
	StorageID *DOMStorageStorageID `json:"storageId"`

	// Key ...
	Key string `json:"key"`

	// OldValue ...
	OldValue string `json:"oldValue"`

	// NewValue ...
	NewValue string `json:"newValue"`
}

// MethodName interface
func (evt DOMStorageDomStorageItemUpdated) MethodName() string {
	return "DOMStorage.domStorageItemUpdated"
}

// DOMStorageDomStorageItemsCleared ...
type DOMStorageDomStorageItemsCleared struct {

	// StorageID ...
	StorageID *DOMStorageStorageID `json:"storageId"`
}

// MethodName interface
func (evt DOMStorageDomStorageItemsCleared) MethodName() string {
	return "DOMStorage.domStorageItemsCleared"
}

// DatabaseDatabaseID Unique identifier of Database object.
type DatabaseDatabaseID string

// DatabaseDatabase Database object.
type DatabaseDatabase struct {

	// ID Database ID.
	ID DatabaseDatabaseID `json:"id"`

	// Domain Database domain.
	Domain string `json:"domain"`

	// Name Database name.
	Name string `json:"name"`

	// Version Database version.
	Version string `json:"version"`
}

// DatabaseError Database error.
type DatabaseError struct {

	// Message Error message.
	Message string `json:"message"`

	// Code Error code.
	Code int64 `json:"code"`
}

// DatabaseDisable Disables database tracking, prevents database events from being sent to the client.
type DatabaseDisable struct {
}

// Call of the command, sessionID is optional.
func (m DatabaseDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Database.disable", m)
	return err
}

// DatabaseEnable Enables database tracking, database events will now be delivered to the client.
type DatabaseEnable struct {
}

// Call of the command, sessionID is optional.
func (m DatabaseEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Database.enable", m)
	return err
}

// DatabaseExecuteSQL ...
type DatabaseExecuteSQL struct {

	// DatabaseID ...
	DatabaseID DatabaseDatabaseID `json:"databaseId"`

	// Query ...
	Query string `json:"query"`
}

// Call of the command, sessionID is optional.
func (m DatabaseExecuteSQL) Call(caller Caller) (*DatabaseExecuteSQLResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Database.executeSQL", m)
	if err != nil {
		return nil, err
	}

	var res DatabaseExecuteSQLResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DatabaseExecuteSQLResult ...
type DatabaseExecuteSQLResult struct {

	// ColumnNames (optional) ...
	ColumnNames []string `json:"columnNames,omitempty"`

	// Values (optional) ...
	Values []JSON `json:"values,omitempty"`

	// SQLError (optional) ...
	SQLError *DatabaseError `json:"sqlError,omitempty"`
}

// DatabaseGetDatabaseTableNames ...
type DatabaseGetDatabaseTableNames struct {

	// DatabaseID ...
	DatabaseID DatabaseDatabaseID `json:"databaseId"`
}

// Call of the command, sessionID is optional.
func (m DatabaseGetDatabaseTableNames) Call(caller Caller) (*DatabaseGetDatabaseTableNamesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Database.getDatabaseTableNames", m)
	if err != nil {
		return nil, err
	}

	var res DatabaseGetDatabaseTableNamesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DatabaseGetDatabaseTableNamesResult ...
type DatabaseGetDatabaseTableNamesResult struct {

	// TableNames ...
	TableNames []string `json:"tableNames"`
}

// DatabaseAddDatabase ...
type DatabaseAddDatabase struct {

	// Database ...
	Database *DatabaseDatabase `json:"database"`
}

// MethodName interface
func (evt DatabaseAddDatabase) MethodName() string {
	return "Database.addDatabase"
}

// DeviceOrientationClearDeviceOrientationOverride Clears the overridden Device Orientation.
type DeviceOrientationClearDeviceOrientationOverride struct {
}

// Call of the command, sessionID is optional.
func (m DeviceOrientationClearDeviceOrientationOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DeviceOrientation.clearDeviceOrientationOverride", m)
	return err
}

// DeviceOrientationSetDeviceOrientationOverride Overrides the Device Orientation.
type DeviceOrientationSetDeviceOrientationOverride struct {

	// Alpha Mock alpha
	Alpha float64 `json:"alpha"`

	// Beta Mock beta
	Beta float64 `json:"beta"`

	// Gamma Mock gamma
	Gamma float64 `json:"gamma"`
}

// Call of the command, sessionID is optional.
func (m DeviceOrientationSetDeviceOrientationOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "DeviceOrientation.setDeviceOrientationOverride", m)
	return err
}

// EmulationScreenOrientationType enum
type EmulationScreenOrientationType string

const (
	// EmulationScreenOrientationTypePortraitPrimary enum const
	EmulationScreenOrientationTypePortraitPrimary EmulationScreenOrientationType = "portraitPrimary"

	// EmulationScreenOrientationTypePortraitSecondary enum const
	EmulationScreenOrientationTypePortraitSecondary EmulationScreenOrientationType = "portraitSecondary"

	// EmulationScreenOrientationTypeLandscapePrimary enum const
	EmulationScreenOrientationTypeLandscapePrimary EmulationScreenOrientationType = "landscapePrimary"

	// EmulationScreenOrientationTypeLandscapeSecondary enum const
	EmulationScreenOrientationTypeLandscapeSecondary EmulationScreenOrientationType = "landscapeSecondary"
)

// EmulationScreenOrientation Screen orientation.
type EmulationScreenOrientation struct {

	// Type Orientation type.
	Type EmulationScreenOrientationType `json:"type"`

	// Angle Orientation angle.
	Angle int64 `json:"angle"`
}

// EmulationMediaFeature ...
type EmulationMediaFeature struct {

	// Name ...
	Name string `json:"name"`

	// Value ...
	Value string `json:"value"`
}

// EmulationVirtualTimePolicy (experimental) advance: If the scheduler runs out of immediate work, the virtual time base may fast forward to
// allow the next delayed task (if any) to run; pause: The virtual time base may not advance;
// pauseIfNetworkFetchesPending: The virtual time base may not advance if there are any pending
// resource fetches.
type EmulationVirtualTimePolicy string

const (
	// EmulationVirtualTimePolicyAdvance enum const
	EmulationVirtualTimePolicyAdvance EmulationVirtualTimePolicy = "advance"

	// EmulationVirtualTimePolicyPause enum const
	EmulationVirtualTimePolicyPause EmulationVirtualTimePolicy = "pause"

	// EmulationVirtualTimePolicyPauseIfNetworkFetchesPending enum const
	EmulationVirtualTimePolicyPauseIfNetworkFetchesPending EmulationVirtualTimePolicy = "pauseIfNetworkFetchesPending"
)

// EmulationCanEmulate Tells whether emulation is supported.
type EmulationCanEmulate struct {
}

// Call of the command, sessionID is optional.
func (m EmulationCanEmulate) Call(caller Caller) (*EmulationCanEmulateResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Emulation.canEmulate", m)
	if err != nil {
		return nil, err
	}

	var res EmulationCanEmulateResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// EmulationCanEmulateResult Tells whether emulation is supported.
type EmulationCanEmulateResult struct {

	// Result True if emulation is supported.
	Result bool `json:"result"`
}

// EmulationClearDeviceMetricsOverride Clears the overriden device metrics.
type EmulationClearDeviceMetricsOverride struct {
}

// Call of the command, sessionID is optional.
func (m EmulationClearDeviceMetricsOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.clearDeviceMetricsOverride", m)
	return err
}

// EmulationClearGeolocationOverride Clears the overriden Geolocation Position and Error.
type EmulationClearGeolocationOverride struct {
}

// Call of the command, sessionID is optional.
func (m EmulationClearGeolocationOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.clearGeolocationOverride", m)
	return err
}

// EmulationResetPageScaleFactor (experimental) Requests that page scale factor is reset to initial values.
type EmulationResetPageScaleFactor struct {
}

// Call of the command, sessionID is optional.
func (m EmulationResetPageScaleFactor) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.resetPageScaleFactor", m)
	return err
}

// EmulationSetFocusEmulationEnabled (experimental) Enables or disables simulating a focused and active page.
type EmulationSetFocusEmulationEnabled struct {

	// Enabled Whether to enable to disable focus emulation.
	Enabled bool `json:"enabled"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetFocusEmulationEnabled) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setFocusEmulationEnabled", m)
	return err
}

// EmulationSetCPUThrottlingRate (experimental) Enables CPU throttling to emulate slow CPUs.
type EmulationSetCPUThrottlingRate struct {

	// Rate Throttling rate as a slowdown factor (1 is no throttle, 2 is 2x slowdown, etc).
	Rate float64 `json:"rate"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetCPUThrottlingRate) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setCPUThrottlingRate", m)
	return err
}

// EmulationSetDefaultBackgroundColorOverride Sets or clears an override of the default background color of the frame. This override is used
// if the content does not specify one.
type EmulationSetDefaultBackgroundColorOverride struct {

	// Color (optional) RGBA of the default background color. If not specified, any existing override will be
	// cleared.
	Color *DOMRGBA `json:"color,omitempty"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetDefaultBackgroundColorOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setDefaultBackgroundColorOverride", m)
	return err
}

// EmulationSetDeviceMetricsOverride Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
// window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
// query results).
type EmulationSetDeviceMetricsOverride struct {

	// Width Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
	Width int64 `json:"width"`

	// Height Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
	Height int64 `json:"height"`

	// DeviceScaleFactor Overriding device scale factor value. 0 disables the override.
	DeviceScaleFactor float64 `json:"deviceScaleFactor"`

	// Mobile Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text
	// autosizing and more.
	Mobile bool `json:"mobile"`

	// Scale (experimental) (optional) Scale to apply to resulting view image.
	Scale float64 `json:"scale,omitempty"`

	// ScreenWidth (experimental) (optional) Overriding screen width value in pixels (minimum 0, maximum 10000000).
	ScreenWidth int64 `json:"screenWidth,omitempty"`

	// ScreenHeight (experimental) (optional) Overriding screen height value in pixels (minimum 0, maximum 10000000).
	ScreenHeight int64 `json:"screenHeight,omitempty"`

	// PositionX (experimental) (optional) Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
	PositionX int64 `json:"positionX,omitempty"`

	// PositionY (experimental) (optional) Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
	PositionY int64 `json:"positionY,omitempty"`

	// DontSetVisibleSize (experimental) (optional) Do not set visible view size, rely upon explicit setVisibleSize call.
	DontSetVisibleSize bool `json:"dontSetVisibleSize,omitempty"`

	// ScreenOrientation (optional) Screen orientation override.
	ScreenOrientation *EmulationScreenOrientation `json:"screenOrientation,omitempty"`

	// Viewport (experimental) (optional) If set, the visible area of the page will be overridden to this viewport. This viewport
	// change is not observed by the page, e.g. viewport-relative elements do not change positions.
	Viewport *PageViewport `json:"viewport,omitempty"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetDeviceMetricsOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setDeviceMetricsOverride", m)
	return err
}

// EmulationSetScrollbarsHidden (experimental) ...
type EmulationSetScrollbarsHidden struct {

	// Hidden Whether scrollbars should be always hidden.
	Hidden bool `json:"hidden"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetScrollbarsHidden) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setScrollbarsHidden", m)
	return err
}

// EmulationSetDocumentCookieDisabled (experimental) ...
type EmulationSetDocumentCookieDisabled struct {

	// Disabled Whether document.coookie API should be disabled.
	Disabled bool `json:"disabled"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetDocumentCookieDisabled) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setDocumentCookieDisabled", m)
	return err
}

// EmulationSetEmitTouchEventsForMouseConfiguration enum
type EmulationSetEmitTouchEventsForMouseConfiguration string

const (
	// EmulationSetEmitTouchEventsForMouseConfigurationMobile enum const
	EmulationSetEmitTouchEventsForMouseConfigurationMobile EmulationSetEmitTouchEventsForMouseConfiguration = "mobile"

	// EmulationSetEmitTouchEventsForMouseConfigurationDesktop enum const
	EmulationSetEmitTouchEventsForMouseConfigurationDesktop EmulationSetEmitTouchEventsForMouseConfiguration = "desktop"
)

// EmulationSetEmitTouchEventsForMouse (experimental) ...
type EmulationSetEmitTouchEventsForMouse struct {

	// Enabled Whether touch emulation based on mouse input should be enabled.
	Enabled bool `json:"enabled"`

	// Configuration (optional) Touch/gesture events configuration. Default: current platform.
	Configuration EmulationSetEmitTouchEventsForMouseConfiguration `json:"configuration,omitempty"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetEmitTouchEventsForMouse) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setEmitTouchEventsForMouse", m)
	return err
}

// EmulationSetEmulatedMedia Emulates the given media type or media feature for CSS media queries.
type EmulationSetEmulatedMedia struct {

	// Media (optional) Media type to emulate. Empty string disables the override.
	Media string `json:"media,omitempty"`

	// Features (optional) Media features to emulate.
	Features []*EmulationMediaFeature `json:"features,omitempty"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetEmulatedMedia) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setEmulatedMedia", m)
	return err
}

// EmulationSetGeolocationOverride Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
// unavailable.
type EmulationSetGeolocationOverride struct {

	// Latitude (optional) Mock latitude
	Latitude float64 `json:"latitude,omitempty"`

	// Longitude (optional) Mock longitude
	Longitude float64 `json:"longitude,omitempty"`

	// Accuracy (optional) Mock accuracy
	Accuracy float64 `json:"accuracy,omitempty"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetGeolocationOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setGeolocationOverride", m)
	return err
}

// EmulationSetNavigatorOverrides (deprecated) (experimental) Overrides value returned by the javascript navigator object.
type EmulationSetNavigatorOverrides struct {

	// Platform The platform navigator.platform should return.
	Platform string `json:"platform"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetNavigatorOverrides) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setNavigatorOverrides", m)
	return err
}

// EmulationSetPageScaleFactor (experimental) Sets a specified page scale factor.
type EmulationSetPageScaleFactor struct {

	// PageScaleFactor Page scale factor.
	PageScaleFactor float64 `json:"pageScaleFactor"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetPageScaleFactor) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setPageScaleFactor", m)
	return err
}

// EmulationSetScriptExecutionDisabled Switches script execution in the page.
type EmulationSetScriptExecutionDisabled struct {

	// Value Whether script execution should be disabled in the page.
	Value bool `json:"value"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetScriptExecutionDisabled) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setScriptExecutionDisabled", m)
	return err
}

// EmulationSetTouchEmulationEnabled Enables touch on platforms which do not support them.
type EmulationSetTouchEmulationEnabled struct {

	// Enabled Whether the touch event emulation should be enabled.
	Enabled bool `json:"enabled"`

	// MaxTouchPoints (optional) Maximum touch points supported. Defaults to one.
	MaxTouchPoints int64 `json:"maxTouchPoints,omitempty"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetTouchEmulationEnabled) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setTouchEmulationEnabled", m)
	return err
}

// EmulationSetVirtualTimePolicy (experimental) Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
// the current virtual time policy.  Note this supersedes any previous time budget.
type EmulationSetVirtualTimePolicy struct {

	// Policy ...
	Policy EmulationVirtualTimePolicy `json:"policy"`

	// Budget (optional) If set, after this many virtual milliseconds have elapsed virtual time will be paused and a
	// virtualTimeBudgetExpired event is sent.
	Budget float64 `json:"budget,omitempty"`

	// MaxVirtualTimeTaskStarvationCount (optional) If set this specifies the maximum number of tasks that can be run before virtual is forced
	// forwards to prevent deadlock.
	MaxVirtualTimeTaskStarvationCount int64 `json:"maxVirtualTimeTaskStarvationCount,omitempty"`

	// WaitForNavigation (optional) If set the virtual time policy change should be deferred until any frame starts navigating.
	// Note any previous deferred policy change is superseded.
	WaitForNavigation bool `json:"waitForNavigation,omitempty"`

	// InitialVirtualTime (optional) If set, base::Time::Now will be overriden to initially return this value.
	InitialVirtualTime NetworkTimeSinceEpoch `json:"initialVirtualTime,omitempty"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetVirtualTimePolicy) Call(caller Caller) (*EmulationSetVirtualTimePolicyResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Emulation.setVirtualTimePolicy", m)
	if err != nil {
		return nil, err
	}

	var res EmulationSetVirtualTimePolicyResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// EmulationSetVirtualTimePolicyResult (experimental) Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
// the current virtual time policy.  Note this supersedes any previous time budget.
type EmulationSetVirtualTimePolicyResult struct {

	// VirtualTimeTicksBase Absolute timestamp at which virtual time was first enabled (up time in milliseconds).
	VirtualTimeTicksBase float64 `json:"virtualTimeTicksBase"`
}

// EmulationSetTimezoneOverride (experimental) Overrides default host system timezone with the specified one.
type EmulationSetTimezoneOverride struct {

	// TimezoneID The timezone identifier. If empty, disables the override and
	// restores default host system timezone.
	TimezoneID string `json:"timezoneId"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetTimezoneOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setTimezoneOverride", m)
	return err
}

// EmulationSetVisibleSize (deprecated) (experimental) Resizes the frame/viewport of the page. Note that this does not affect the frame's container
// (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported
// on Android.
type EmulationSetVisibleSize struct {

	// Width Frame width (DIP).
	Width int64 `json:"width"`

	// Height Frame height (DIP).
	Height int64 `json:"height"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetVisibleSize) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setVisibleSize", m)
	return err
}

// EmulationSetUserAgentOverride Allows overriding user agent with the given string.
type EmulationSetUserAgentOverride struct {

	// UserAgent User agent to use.
	UserAgent string `json:"userAgent"`

	// AcceptLanguage (optional) Browser langugage to emulate.
	AcceptLanguage string `json:"acceptLanguage,omitempty"`

	// Platform (optional) The platform navigator.platform should return.
	Platform string `json:"platform,omitempty"`
}

// Call of the command, sessionID is optional.
func (m EmulationSetUserAgentOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Emulation.setUserAgentOverride", m)
	return err
}

// EmulationVirtualTimeBudgetExpired (experimental) Notification sent after the virtual time budget for the current VirtualTimePolicy has run out.
type EmulationVirtualTimeBudgetExpired struct {
}

// MethodName interface
func (evt EmulationVirtualTimeBudgetExpired) MethodName() string {
	return "Emulation.virtualTimeBudgetExpired"
}

// HeadlessExperimentalScreenshotParamsFormat enum
type HeadlessExperimentalScreenshotParamsFormat string

const (
	// HeadlessExperimentalScreenshotParamsFormatJpeg enum const
	HeadlessExperimentalScreenshotParamsFormatJpeg HeadlessExperimentalScreenshotParamsFormat = "jpeg"

	// HeadlessExperimentalScreenshotParamsFormatPng enum const
	HeadlessExperimentalScreenshotParamsFormatPng HeadlessExperimentalScreenshotParamsFormat = "png"
)

// HeadlessExperimentalScreenshotParams Encoding options for a screenshot.
type HeadlessExperimentalScreenshotParams struct {

	// Format (optional) Image compression format (defaults to png).
	Format HeadlessExperimentalScreenshotParamsFormat `json:"format,omitempty"`

	// Quality (optional) Compression quality from range [0..100] (jpeg only).
	Quality int64 `json:"quality,omitempty"`
}

// HeadlessExperimentalBeginFrame Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
// screenshot from the resulting frame. Requires that the target was created with enabled
// BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
// https://goo.gl/3zHXhB for more background.
type HeadlessExperimentalBeginFrame struct {

	// FrameTimeTicks (optional) Timestamp of this BeginFrame in Renderer TimeTicks (milliseconds of uptime). If not set,
	// the current time will be used.
	FrameTimeTicks float64 `json:"frameTimeTicks,omitempty"`

	// Interval (optional) The interval between BeginFrames that is reported to the compositor, in milliseconds.
	// Defaults to a 60 frames/second interval, i.e. about 16.666 milliseconds.
	Interval float64 `json:"interval,omitempty"`

	// NoDisplayUpdates (optional) Whether updates should not be committed and drawn onto the display. False by default. If
	// true, only side effects of the BeginFrame will be run, such as layout and animations, but
	// any visual updates may not be visible on the display or in screenshots.
	NoDisplayUpdates bool `json:"noDisplayUpdates,omitempty"`

	// Screenshot (optional) If set, a screenshot of the frame will be captured and returned in the response. Otherwise,
	// no screenshot will be captured. Note that capturing a screenshot can fail, for example,
	// during renderer initialization. In such a case, no screenshot data will be returned.
	Screenshot *HeadlessExperimentalScreenshotParams `json:"screenshot,omitempty"`
}

// Call of the command, sessionID is optional.
func (m HeadlessExperimentalBeginFrame) Call(caller Caller) (*HeadlessExperimentalBeginFrameResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "HeadlessExperimental.beginFrame", m)
	if err != nil {
		return nil, err
	}

	var res HeadlessExperimentalBeginFrameResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// HeadlessExperimentalBeginFrameResult Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
// screenshot from the resulting frame. Requires that the target was created with enabled
// BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
// https://goo.gl/3zHXhB for more background.
type HeadlessExperimentalBeginFrameResult struct {

	// HasDamage Whether the BeginFrame resulted in damage and, thus, a new frame was committed to the
	// display. Reported for diagnostic uses, may be removed in the future.
	HasDamage bool `json:"hasDamage"`

	// ScreenshotData (optional) Base64-encoded image data of the screenshot, if one was requested and successfully taken.
	ScreenshotData []byte `json:"screenshotData,omitempty"`
}

// HeadlessExperimentalDisable Disables headless events for the target.
type HeadlessExperimentalDisable struct {
}

// Call of the command, sessionID is optional.
func (m HeadlessExperimentalDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "HeadlessExperimental.disable", m)
	return err
}

// HeadlessExperimentalEnable Enables headless events for the target.
type HeadlessExperimentalEnable struct {
}

// Call of the command, sessionID is optional.
func (m HeadlessExperimentalEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "HeadlessExperimental.enable", m)
	return err
}

// HeadlessExperimentalNeedsBeginFramesChanged (deprecated) Issued when the target starts or stops needing BeginFrames.
// Deprecated. Issue beginFrame unconditionally instead and use result from
// beginFrame to detect whether the frames were suppressed.
type HeadlessExperimentalNeedsBeginFramesChanged struct {

	// NeedsBeginFrames True if BeginFrames are needed, false otherwise.
	NeedsBeginFrames bool `json:"needsBeginFrames"`
}

// MethodName interface
func (evt HeadlessExperimentalNeedsBeginFramesChanged) MethodName() string {
	return "HeadlessExperimental.needsBeginFramesChanged"
}

// IOStreamHandle This is either obtained from another method or specifed as `blob:&lt;uuid&gt;` where
// `&lt;uuid&gt` is an UUID of a Blob.
type IOStreamHandle string

// IOClose Close the stream, discard any temporary backing storage.
type IOClose struct {

	// Handle Handle of the stream to close.
	Handle IOStreamHandle `json:"handle"`
}

// Call of the command, sessionID is optional.
func (m IOClose) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "IO.close", m)
	return err
}

// IORead Read a chunk of the stream
type IORead struct {

	// Handle Handle of the stream to read.
	Handle IOStreamHandle `json:"handle"`

	// Offset (optional) Seek to the specified offset before reading (if not specificed, proceed with offset
	// following the last read). Some types of streams may only support sequential reads.
	Offset int64 `json:"offset,omitempty"`

	// Size (optional) Maximum number of bytes to read (left upon the agent discretion if not specified).
	Size int64 `json:"size,omitempty"`
}

// Call of the command, sessionID is optional.
func (m IORead) Call(caller Caller) (*IOReadResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "IO.read", m)
	if err != nil {
		return nil, err
	}

	var res IOReadResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// IOReadResult Read a chunk of the stream
type IOReadResult struct {

	// Base64Encoded (optional) Set if the data is base64-encoded
	Base64Encoded bool `json:"base64Encoded,omitempty"`

	// Data Data that were read.
	Data string `json:"data"`

	// EOF Set if the end-of-file condition occured while reading.
	EOF bool `json:"eof"`
}

// IOResolveBlob Return UUID of Blob object specified by a remote object id.
type IOResolveBlob struct {

	// ObjectID Object id of a Blob object wrapper.
	ObjectID RuntimeRemoteObjectID `json:"objectId"`
}

// Call of the command, sessionID is optional.
func (m IOResolveBlob) Call(caller Caller) (*IOResolveBlobResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "IO.resolveBlob", m)
	if err != nil {
		return nil, err
	}

	var res IOResolveBlobResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// IOResolveBlobResult Return UUID of Blob object specified by a remote object id.
type IOResolveBlobResult struct {

	// UUID UUID of the specified Blob.
	UUID string `json:"uuid"`
}

// IndexedDBDatabaseWithObjectStores Database with an array of object stores.
type IndexedDBDatabaseWithObjectStores struct {

	// Name Database name.
	Name string `json:"name"`

	// Version Database version (type is not 'integer', as the standard
	// requires the version number to be 'unsigned long long')
	Version float64 `json:"version"`

	// ObjectStores Object stores in this database.
	ObjectStores []*IndexedDBObjectStore `json:"objectStores"`
}

// IndexedDBObjectStore Object store.
type IndexedDBObjectStore struct {

	// Name Object store name.
	Name string `json:"name"`

	// KeyPath Object store key path.
	KeyPath *IndexedDBKeyPath `json:"keyPath"`

	// AutoIncrement If true, object store has auto increment flag set.
	AutoIncrement bool `json:"autoIncrement"`

	// Indexes Indexes in this object store.
	Indexes []*IndexedDBObjectStoreIndex `json:"indexes"`
}

// IndexedDBObjectStoreIndex Object store index.
type IndexedDBObjectStoreIndex struct {

	// Name Index name.
	Name string `json:"name"`

	// KeyPath Index key path.
	KeyPath *IndexedDBKeyPath `json:"keyPath"`

	// Unique If true, index is unique.
	Unique bool `json:"unique"`

	// MultiEntry If true, index allows multiple entries for a key.
	MultiEntry bool `json:"multiEntry"`
}

// IndexedDBKeyType enum
type IndexedDBKeyType string

const (
	// IndexedDBKeyTypeNumber enum const
	IndexedDBKeyTypeNumber IndexedDBKeyType = "number"

	// IndexedDBKeyTypeString enum const
	IndexedDBKeyTypeString IndexedDBKeyType = "string"

	// IndexedDBKeyTypeDate enum const
	IndexedDBKeyTypeDate IndexedDBKeyType = "date"

	// IndexedDBKeyTypeArray enum const
	IndexedDBKeyTypeArray IndexedDBKeyType = "array"
)

// IndexedDBKey Key.
type IndexedDBKey struct {

	// Type Key type.
	Type IndexedDBKeyType `json:"type"`

	// Number (optional) Number value.
	Number float64 `json:"number,omitempty"`

	// String (optional) String value.
	String string `json:"string,omitempty"`

	// Date (optional) Date value.
	Date float64 `json:"date,omitempty"`

	// Array (optional) Array value.
	Array []*IndexedDBKey `json:"array,omitempty"`
}

// IndexedDBKeyRange Key range.
type IndexedDBKeyRange struct {

	// Lower (optional) Lower bound.
	Lower *IndexedDBKey `json:"lower,omitempty"`

	// Upper (optional) Upper bound.
	Upper *IndexedDBKey `json:"upper,omitempty"`

	// LowerOpen If true lower bound is open.
	LowerOpen bool `json:"lowerOpen"`

	// UpperOpen If true upper bound is open.
	UpperOpen bool `json:"upperOpen"`
}

// IndexedDBDataEntry Data entry.
type IndexedDBDataEntry struct {

	// Key Key object.
	Key *RuntimeRemoteObject `json:"key"`

	// PrimaryKey Primary key object.
	PrimaryKey *RuntimeRemoteObject `json:"primaryKey"`

	// Value Value object.
	Value *RuntimeRemoteObject `json:"value"`
}

// IndexedDBKeyPathType enum
type IndexedDBKeyPathType string

const (
	// IndexedDBKeyPathTypeNull enum const
	IndexedDBKeyPathTypeNull IndexedDBKeyPathType = "null"

	// IndexedDBKeyPathTypeString enum const
	IndexedDBKeyPathTypeString IndexedDBKeyPathType = "string"

	// IndexedDBKeyPathTypeArray enum const
	IndexedDBKeyPathTypeArray IndexedDBKeyPathType = "array"
)

// IndexedDBKeyPath Key path.
type IndexedDBKeyPath struct {

	// Type Key path type.
	Type IndexedDBKeyPathType `json:"type"`

	// String (optional) String value.
	String string `json:"string,omitempty"`

	// Array (optional) Array value.
	Array []string `json:"array,omitempty"`
}

// IndexedDBClearObjectStore Clears all entries from an object store.
type IndexedDBClearObjectStore struct {

	// SecurityOrigin Security origin.
	SecurityOrigin string `json:"securityOrigin"`

	// DatabaseName Database name.
	DatabaseName string `json:"databaseName"`

	// ObjectStoreName Object store name.
	ObjectStoreName string `json:"objectStoreName"`
}

// Call of the command, sessionID is optional.
func (m IndexedDBClearObjectStore) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "IndexedDB.clearObjectStore", m)
	return err
}

// IndexedDBDeleteDatabase Deletes a database.
type IndexedDBDeleteDatabase struct {

	// SecurityOrigin Security origin.
	SecurityOrigin string `json:"securityOrigin"`

	// DatabaseName Database name.
	DatabaseName string `json:"databaseName"`
}

// Call of the command, sessionID is optional.
func (m IndexedDBDeleteDatabase) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "IndexedDB.deleteDatabase", m)
	return err
}

// IndexedDBDeleteObjectStoreEntries Delete a range of entries from an object store
type IndexedDBDeleteObjectStoreEntries struct {

	// SecurityOrigin ...
	SecurityOrigin string `json:"securityOrigin"`

	// DatabaseName ...
	DatabaseName string `json:"databaseName"`

	// ObjectStoreName ...
	ObjectStoreName string `json:"objectStoreName"`

	// KeyRange Range of entry keys to delete
	KeyRange *IndexedDBKeyRange `json:"keyRange"`
}

// Call of the command, sessionID is optional.
func (m IndexedDBDeleteObjectStoreEntries) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "IndexedDB.deleteObjectStoreEntries", m)
	return err
}

// IndexedDBDisable Disables events from backend.
type IndexedDBDisable struct {
}

// Call of the command, sessionID is optional.
func (m IndexedDBDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "IndexedDB.disable", m)
	return err
}

// IndexedDBEnable Enables events from backend.
type IndexedDBEnable struct {
}

// Call of the command, sessionID is optional.
func (m IndexedDBEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "IndexedDB.enable", m)
	return err
}

// IndexedDBRequestData Requests data from object store or index.
type IndexedDBRequestData struct {

	// SecurityOrigin Security origin.
	SecurityOrigin string `json:"securityOrigin"`

	// DatabaseName Database name.
	DatabaseName string `json:"databaseName"`

	// ObjectStoreName Object store name.
	ObjectStoreName string `json:"objectStoreName"`

	// IndexName Index name, empty string for object store data requests.
	IndexName string `json:"indexName"`

	// SkipCount Number of records to skip.
	SkipCount int64 `json:"skipCount"`

	// PageSize Number of records to fetch.
	PageSize int64 `json:"pageSize"`

	// KeyRange (optional) Key range.
	KeyRange *IndexedDBKeyRange `json:"keyRange,omitempty"`
}

// Call of the command, sessionID is optional.
func (m IndexedDBRequestData) Call(caller Caller) (*IndexedDBRequestDataResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "IndexedDB.requestData", m)
	if err != nil {
		return nil, err
	}

	var res IndexedDBRequestDataResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// IndexedDBRequestDataResult Requests data from object store or index.
type IndexedDBRequestDataResult struct {

	// ObjectStoreDataEntries Array of object store data entries.
	ObjectStoreDataEntries []*IndexedDBDataEntry `json:"objectStoreDataEntries"`

	// HasMore If true, there are more entries to fetch in the given range.
	HasMore bool `json:"hasMore"`
}

// IndexedDBGetMetadata Gets metadata of an object store
type IndexedDBGetMetadata struct {

	// SecurityOrigin Security origin.
	SecurityOrigin string `json:"securityOrigin"`

	// DatabaseName Database name.
	DatabaseName string `json:"databaseName"`

	// ObjectStoreName Object store name.
	ObjectStoreName string `json:"objectStoreName"`
}

// Call of the command, sessionID is optional.
func (m IndexedDBGetMetadata) Call(caller Caller) (*IndexedDBGetMetadataResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "IndexedDB.getMetadata", m)
	if err != nil {
		return nil, err
	}

	var res IndexedDBGetMetadataResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// IndexedDBGetMetadataResult Gets metadata of an object store
type IndexedDBGetMetadataResult struct {

	// EntriesCount the entries count
	EntriesCount float64 `json:"entriesCount"`

	// KeyGeneratorValue the current value of key generator, to become the next inserted
	// key into the object store. Valid if objectStore.autoIncrement
	// is true.
	KeyGeneratorValue float64 `json:"keyGeneratorValue"`
}

// IndexedDBRequestDatabase Requests database with given name in given frame.
type IndexedDBRequestDatabase struct {

	// SecurityOrigin Security origin.
	SecurityOrigin string `json:"securityOrigin"`

	// DatabaseName Database name.
	DatabaseName string `json:"databaseName"`
}

// Call of the command, sessionID is optional.
func (m IndexedDBRequestDatabase) Call(caller Caller) (*IndexedDBRequestDatabaseResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "IndexedDB.requestDatabase", m)
	if err != nil {
		return nil, err
	}

	var res IndexedDBRequestDatabaseResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// IndexedDBRequestDatabaseResult Requests database with given name in given frame.
type IndexedDBRequestDatabaseResult struct {

	// DatabaseWithObjectStores Database with an array of object stores.
	DatabaseWithObjectStores *IndexedDBDatabaseWithObjectStores `json:"databaseWithObjectStores"`
}

// IndexedDBRequestDatabaseNames Requests database names for given security origin.
type IndexedDBRequestDatabaseNames struct {

	// SecurityOrigin Security origin.
	SecurityOrigin string `json:"securityOrigin"`
}

// Call of the command, sessionID is optional.
func (m IndexedDBRequestDatabaseNames) Call(caller Caller) (*IndexedDBRequestDatabaseNamesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "IndexedDB.requestDatabaseNames", m)
	if err != nil {
		return nil, err
	}

	var res IndexedDBRequestDatabaseNamesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// IndexedDBRequestDatabaseNamesResult Requests database names for given security origin.
type IndexedDBRequestDatabaseNamesResult struct {

	// DatabaseNames Database names for origin.
	DatabaseNames []string `json:"databaseNames"`
}

// InputTouchPoint ...
type InputTouchPoint struct {

	// X X coordinate of the event relative to the main frame's viewport in CSS pixels.
	X float64 `json:"x"`

	// Y Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
	// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
	Y float64 `json:"y"`

	// RadiusX (optional) X radius of the touch area (default: 1.0).
	RadiusX float64 `json:"radiusX,omitempty"`

	// RadiusY (optional) Y radius of the touch area (default: 1.0).
	RadiusY float64 `json:"radiusY,omitempty"`

	// RotationAngle (optional) Rotation angle (default: 0.0).
	RotationAngle float64 `json:"rotationAngle,omitempty"`

	// Force (optional) Force (default: 1.0).
	Force float64 `json:"force,omitempty"`

	// ID (optional) Identifier used to track touch sources between events, must be unique within an event.
	ID float64 `json:"id,omitempty"`
}

// InputGestureSourceType (experimental) ...
type InputGestureSourceType string

const (
	// InputGestureSourceTypeDefault enum const
	InputGestureSourceTypeDefault InputGestureSourceType = "default"

	// InputGestureSourceTypeTouch enum const
	InputGestureSourceTypeTouch InputGestureSourceType = "touch"

	// InputGestureSourceTypeMouse enum const
	InputGestureSourceTypeMouse InputGestureSourceType = "mouse"
)

// InputMouseButton ...
type InputMouseButton string

const (
	// InputMouseButtonNone enum const
	InputMouseButtonNone InputMouseButton = "none"

	// InputMouseButtonLeft enum const
	InputMouseButtonLeft InputMouseButton = "left"

	// InputMouseButtonMiddle enum const
	InputMouseButtonMiddle InputMouseButton = "middle"

	// InputMouseButtonRight enum const
	InputMouseButtonRight InputMouseButton = "right"

	// InputMouseButtonBack enum const
	InputMouseButtonBack InputMouseButton = "back"

	// InputMouseButtonForward enum const
	InputMouseButtonForward InputMouseButton = "forward"
)

// InputTimeSinceEpoch UTC time in seconds, counted from January 1, 1970.
type InputTimeSinceEpoch float64

// InputDispatchKeyEventType enum
type InputDispatchKeyEventType string

const (
	// InputDispatchKeyEventTypeKeyDown enum const
	InputDispatchKeyEventTypeKeyDown InputDispatchKeyEventType = "keyDown"

	// InputDispatchKeyEventTypeKeyUp enum const
	InputDispatchKeyEventTypeKeyUp InputDispatchKeyEventType = "keyUp"

	// InputDispatchKeyEventTypeRawKeyDown enum const
	InputDispatchKeyEventTypeRawKeyDown InputDispatchKeyEventType = "rawKeyDown"

	// InputDispatchKeyEventTypeChar enum const
	InputDispatchKeyEventTypeChar InputDispatchKeyEventType = "char"
)

// InputDispatchKeyEvent Dispatches a key event to the page.
type InputDispatchKeyEvent struct {

	// Type Type of the key event.
	Type InputDispatchKeyEventType `json:"type"`

	// Modifiers (optional) Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
	// (default: 0).
	Modifiers int64 `json:"modifiers,omitempty"`

	// Timestamp (optional) Time at which the event occurred.
	Timestamp InputTimeSinceEpoch `json:"timestamp,omitempty"`

	// Text (optional) Text as generated by processing a virtual key code with a keyboard layout. Not needed for
	// for `keyUp` and `rawKeyDown` events (default: "")
	Text string `json:"text,omitempty"`

	// UnmodifiedText (optional) Text that would have been generated by the keyboard if no modifiers were pressed (except for
	// shift). Useful for shortcut (accelerator) key handling (default: "").
	UnmodifiedText string `json:"unmodifiedText,omitempty"`

	// KeyIdentifier (optional) Unique key identifier (e.g., 'U+0041') (default: "").
	KeyIdentifier string `json:"keyIdentifier,omitempty"`

	// Code (optional) Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
	Code string `json:"code,omitempty"`

	// Key (optional) Unique DOM defined string value describing the meaning of the key in the context of active
	// modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
	Key string `json:"key,omitempty"`

	// WindowsVirtualKeyCode (optional) Windows virtual key code (default: 0).
	WindowsVirtualKeyCode int64 `json:"windowsVirtualKeyCode,omitempty"`

	// NativeVirtualKeyCode (optional) Native virtual key code (default: 0).
	NativeVirtualKeyCode int64 `json:"nativeVirtualKeyCode,omitempty"`

	// AutoRepeat (optional) Whether the event was generated from auto repeat (default: false).
	AutoRepeat bool `json:"autoRepeat,omitempty"`

	// IsKeypad (optional) Whether the event was generated from the keypad (default: false).
	IsKeypad bool `json:"isKeypad,omitempty"`

	// IsSystemKey (optional) Whether the event was a system key event (default: false).
	IsSystemKey bool `json:"isSystemKey,omitempty"`

	// Location (optional) Whether the event was from the left or right side of the keyboard. 1=Left, 2=Right (default:
	// 0).
	Location int64 `json:"location,omitempty"`
}

// Call of the command, sessionID is optional.
func (m InputDispatchKeyEvent) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Input.dispatchKeyEvent", m)
	return err
}

// InputInsertText (experimental) This method emulates inserting text that doesn't come from a key press,
// for example an emoji keyboard or an IME.
type InputInsertText struct {

	// Text The text to insert.
	Text string `json:"text"`
}

// Call of the command, sessionID is optional.
func (m InputInsertText) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Input.insertText", m)
	return err
}

// InputDispatchMouseEventType enum
type InputDispatchMouseEventType string

const (
	// InputDispatchMouseEventTypeMousePressed enum const
	InputDispatchMouseEventTypeMousePressed InputDispatchMouseEventType = "mousePressed"

	// InputDispatchMouseEventTypeMouseReleased enum const
	InputDispatchMouseEventTypeMouseReleased InputDispatchMouseEventType = "mouseReleased"

	// InputDispatchMouseEventTypeMouseMoved enum const
	InputDispatchMouseEventTypeMouseMoved InputDispatchMouseEventType = "mouseMoved"

	// InputDispatchMouseEventTypeMouseWheel enum const
	InputDispatchMouseEventTypeMouseWheel InputDispatchMouseEventType = "mouseWheel"
)

// InputDispatchMouseEventPointerType enum
type InputDispatchMouseEventPointerType string

const (
	// InputDispatchMouseEventPointerTypeMouse enum const
	InputDispatchMouseEventPointerTypeMouse InputDispatchMouseEventPointerType = "mouse"

	// InputDispatchMouseEventPointerTypePen enum const
	InputDispatchMouseEventPointerTypePen InputDispatchMouseEventPointerType = "pen"
)

// InputDispatchMouseEvent Dispatches a mouse event to the page.
type InputDispatchMouseEvent struct {

	// Type Type of the mouse event.
	Type InputDispatchMouseEventType `json:"type"`

	// X X coordinate of the event relative to the main frame's viewport in CSS pixels.
	X float64 `json:"x"`

	// Y Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to
	// the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
	Y float64 `json:"y"`

	// Modifiers (optional) Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
	// (default: 0).
	Modifiers int64 `json:"modifiers,omitempty"`

	// Timestamp (optional) Time at which the event occurred.
	Timestamp InputTimeSinceEpoch `json:"timestamp,omitempty"`

	// Button (optional) Mouse button (default: "none").
	Button InputMouseButton `json:"button,omitempty"`

	// Buttons (optional) A number indicating which buttons are pressed on the mouse when a mouse event is triggered.
	// Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
	Buttons int64 `json:"buttons,omitempty"`

	// ClickCount (optional) Number of times the mouse button was clicked (default: 0).
	ClickCount int64 `json:"clickCount,omitempty"`

	// DeltaX (optional) X delta in CSS pixels for mouse wheel event (default: 0).
	DeltaX float64 `json:"deltaX,omitempty"`

	// DeltaY (optional) Y delta in CSS pixels for mouse wheel event (default: 0).
	DeltaY float64 `json:"deltaY,omitempty"`

	// PointerType (optional) Pointer type (default: "mouse").
	PointerType InputDispatchMouseEventPointerType `json:"pointerType,omitempty"`
}

// Call of the command, sessionID is optional.
func (m InputDispatchMouseEvent) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Input.dispatchMouseEvent", m)
	return err
}

// InputDispatchTouchEventType enum
type InputDispatchTouchEventType string

const (
	// InputDispatchTouchEventTypeTouchStart enum const
	InputDispatchTouchEventTypeTouchStart InputDispatchTouchEventType = "touchStart"

	// InputDispatchTouchEventTypeTouchEnd enum const
	InputDispatchTouchEventTypeTouchEnd InputDispatchTouchEventType = "touchEnd"

	// InputDispatchTouchEventTypeTouchMove enum const
	InputDispatchTouchEventTypeTouchMove InputDispatchTouchEventType = "touchMove"

	// InputDispatchTouchEventTypeTouchCancel enum const
	InputDispatchTouchEventTypeTouchCancel InputDispatchTouchEventType = "touchCancel"
)

// InputDispatchTouchEvent Dispatches a touch event to the page.
type InputDispatchTouchEvent struct {

	// Type Type of the touch event. TouchEnd and TouchCancel must not contain any touch points, while
	// TouchStart and TouchMove must contains at least one.
	Type InputDispatchTouchEventType `json:"type"`

	// TouchPoints Active touch points on the touch device. One event per any changed point (compared to
	// previous touch event in a sequence) is generated, emulating pressing/moving/releasing points
	// one by one.
	TouchPoints []*InputTouchPoint `json:"touchPoints"`

	// Modifiers (optional) Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
	// (default: 0).
	Modifiers int64 `json:"modifiers,omitempty"`

	// Timestamp (optional) Time at which the event occurred.
	Timestamp InputTimeSinceEpoch `json:"timestamp,omitempty"`
}

// Call of the command, sessionID is optional.
func (m InputDispatchTouchEvent) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Input.dispatchTouchEvent", m)
	return err
}

// InputEmulateTouchFromMouseEventType enum
type InputEmulateTouchFromMouseEventType string

const (
	// InputEmulateTouchFromMouseEventTypeMousePressed enum const
	InputEmulateTouchFromMouseEventTypeMousePressed InputEmulateTouchFromMouseEventType = "mousePressed"

	// InputEmulateTouchFromMouseEventTypeMouseReleased enum const
	InputEmulateTouchFromMouseEventTypeMouseReleased InputEmulateTouchFromMouseEventType = "mouseReleased"

	// InputEmulateTouchFromMouseEventTypeMouseMoved enum const
	InputEmulateTouchFromMouseEventTypeMouseMoved InputEmulateTouchFromMouseEventType = "mouseMoved"

	// InputEmulateTouchFromMouseEventTypeMouseWheel enum const
	InputEmulateTouchFromMouseEventTypeMouseWheel InputEmulateTouchFromMouseEventType = "mouseWheel"
)

// InputEmulateTouchFromMouseEvent (experimental) Emulates touch event from the mouse event parameters.
type InputEmulateTouchFromMouseEvent struct {

	// Type Type of the mouse event.
	Type InputEmulateTouchFromMouseEventType `json:"type"`

	// X X coordinate of the mouse pointer in DIP.
	X int64 `json:"x"`

	// Y Y coordinate of the mouse pointer in DIP.
	Y int64 `json:"y"`

	// Button Mouse button. Only "none", "left", "right" are supported.
	Button InputMouseButton `json:"button"`

	// Timestamp (optional) Time at which the event occurred (default: current time).
	Timestamp InputTimeSinceEpoch `json:"timestamp,omitempty"`

	// DeltaX (optional) X delta in DIP for mouse wheel event (default: 0).
	DeltaX float64 `json:"deltaX,omitempty"`

	// DeltaY (optional) Y delta in DIP for mouse wheel event (default: 0).
	DeltaY float64 `json:"deltaY,omitempty"`

	// Modifiers (optional) Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8
	// (default: 0).
	Modifiers int64 `json:"modifiers,omitempty"`

	// ClickCount (optional) Number of times the mouse button was clicked (default: 0).
	ClickCount int64 `json:"clickCount,omitempty"`
}

// Call of the command, sessionID is optional.
func (m InputEmulateTouchFromMouseEvent) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Input.emulateTouchFromMouseEvent", m)
	return err
}

// InputSetIgnoreInputEvents Ignores input events (useful while auditing page).
type InputSetIgnoreInputEvents struct {

	// Ignore Ignores input events processing when set to true.
	Ignore bool `json:"ignore"`
}

// Call of the command, sessionID is optional.
func (m InputSetIgnoreInputEvents) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Input.setIgnoreInputEvents", m)
	return err
}

// InputSynthesizePinchGesture (experimental) Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
type InputSynthesizePinchGesture struct {

	// X X coordinate of the start of the gesture in CSS pixels.
	X float64 `json:"x"`

	// Y Y coordinate of the start of the gesture in CSS pixels.
	Y float64 `json:"y"`

	// ScaleFactor Relative scale factor after zooming (>1.0 zooms in, <1.0 zooms out).
	ScaleFactor float64 `json:"scaleFactor"`

	// RelativeSpeed (optional) Relative pointer speed in pixels per second (default: 800).
	RelativeSpeed int64 `json:"relativeSpeed,omitempty"`

	// GestureSourceType (optional) Which type of input events to be generated (default: 'default', which queries the platform
	// for the preferred input type).
	GestureSourceType InputGestureSourceType `json:"gestureSourceType,omitempty"`
}

// Call of the command, sessionID is optional.
func (m InputSynthesizePinchGesture) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Input.synthesizePinchGesture", m)
	return err
}

// InputSynthesizeScrollGesture (experimental) Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
type InputSynthesizeScrollGesture struct {

	// X X coordinate of the start of the gesture in CSS pixels.
	X float64 `json:"x"`

	// Y Y coordinate of the start of the gesture in CSS pixels.
	Y float64 `json:"y"`

	// XDistance (optional) The distance to scroll along the X axis (positive to scroll left).
	XDistance float64 `json:"xDistance,omitempty"`

	// YDistance (optional) The distance to scroll along the Y axis (positive to scroll up).
	YDistance float64 `json:"yDistance,omitempty"`

	// XOverscroll (optional) The number of additional pixels to scroll back along the X axis, in addition to the given
	// distance.
	XOverscroll float64 `json:"xOverscroll,omitempty"`

	// YOverscroll (optional) The number of additional pixels to scroll back along the Y axis, in addition to the given
	// distance.
	YOverscroll float64 `json:"yOverscroll,omitempty"`

	// PreventFling (optional) Prevent fling (default: true).
	PreventFling bool `json:"preventFling,omitempty"`

	// Speed (optional) Swipe speed in pixels per second (default: 800).
	Speed int64 `json:"speed,omitempty"`

	// GestureSourceType (optional) Which type of input events to be generated (default: 'default', which queries the platform
	// for the preferred input type).
	GestureSourceType InputGestureSourceType `json:"gestureSourceType,omitempty"`

	// RepeatCount (optional) The number of times to repeat the gesture (default: 0).
	RepeatCount int64 `json:"repeatCount,omitempty"`

	// RepeatDelayMs (optional) The number of milliseconds delay between each repeat. (default: 250).
	RepeatDelayMs int64 `json:"repeatDelayMs,omitempty"`

	// InteractionMarkerName (optional) The name of the interaction markers to generate, if not empty (default: "").
	InteractionMarkerName string `json:"interactionMarkerName,omitempty"`
}

// Call of the command, sessionID is optional.
func (m InputSynthesizeScrollGesture) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Input.synthesizeScrollGesture", m)
	return err
}

// InputSynthesizeTapGesture (experimental) Synthesizes a tap gesture over a time period by issuing appropriate touch events.
type InputSynthesizeTapGesture struct {

	// X X coordinate of the start of the gesture in CSS pixels.
	X float64 `json:"x"`

	// Y Y coordinate of the start of the gesture in CSS pixels.
	Y float64 `json:"y"`

	// Duration (optional) Duration between touchdown and touchup events in ms (default: 50).
	Duration int64 `json:"duration,omitempty"`

	// TapCount (optional) Number of times to perform the tap (e.g. 2 for double tap, default: 1).
	TapCount int64 `json:"tapCount,omitempty"`

	// GestureSourceType (optional) Which type of input events to be generated (default: 'default', which queries the platform
	// for the preferred input type).
	GestureSourceType InputGestureSourceType `json:"gestureSourceType,omitempty"`
}

// Call of the command, sessionID is optional.
func (m InputSynthesizeTapGesture) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Input.synthesizeTapGesture", m)
	return err
}

// InspectorDisable Disables inspector domain notifications.
type InspectorDisable struct {
}

// Call of the command, sessionID is optional.
func (m InspectorDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Inspector.disable", m)
	return err
}

// InspectorEnable Enables inspector domain notifications.
type InspectorEnable struct {
}

// Call of the command, sessionID is optional.
func (m InspectorEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Inspector.enable", m)
	return err
}

// InspectorDetached Fired when remote debugging connection is about to be terminated. Contains detach reason.
type InspectorDetached struct {

	// Reason The reason why connection has been terminated.
	Reason string `json:"reason"`
}

// MethodName interface
func (evt InspectorDetached) MethodName() string {
	return "Inspector.detached"
}

// InspectorTargetCrashed Fired when debugging target has crashed
type InspectorTargetCrashed struct {
}

// MethodName interface
func (evt InspectorTargetCrashed) MethodName() string {
	return "Inspector.targetCrashed"
}

// InspectorTargetReloadedAfterCrash Fired when debugging target has reloaded after crash
type InspectorTargetReloadedAfterCrash struct {
}

// MethodName interface
func (evt InspectorTargetReloadedAfterCrash) MethodName() string {
	return "Inspector.targetReloadedAfterCrash"
}

// LayerTreeLayerID Unique Layer identifier.
type LayerTreeLayerID string

// LayerTreeSnapshotID Unique snapshot identifier.
type LayerTreeSnapshotID string

// LayerTreeScrollRectType enum
type LayerTreeScrollRectType string

const (
	// LayerTreeScrollRectTypeRepaintsOnScroll enum const
	LayerTreeScrollRectTypeRepaintsOnScroll LayerTreeScrollRectType = "RepaintsOnScroll"

	// LayerTreeScrollRectTypeTouchEventHandler enum const
	LayerTreeScrollRectTypeTouchEventHandler LayerTreeScrollRectType = "TouchEventHandler"

	// LayerTreeScrollRectTypeWheelEventHandler enum const
	LayerTreeScrollRectTypeWheelEventHandler LayerTreeScrollRectType = "WheelEventHandler"
)

// LayerTreeScrollRect Rectangle where scrolling happens on the main thread.
type LayerTreeScrollRect struct {

	// Rect Rectangle itself.
	Rect *DOMRect `json:"rect"`

	// Type Reason for rectangle to force scrolling on the main thread
	Type LayerTreeScrollRectType `json:"type"`
}

// LayerTreeStickyPositionConstraint Sticky position constraints.
type LayerTreeStickyPositionConstraint struct {

	// StickyBoxRect Layout rectangle of the sticky element before being shifted
	StickyBoxRect *DOMRect `json:"stickyBoxRect"`

	// ContainingBlockRect Layout rectangle of the containing block of the sticky element
	ContainingBlockRect *DOMRect `json:"containingBlockRect"`

	// NearestLayerShiftingStickyBox (optional) The nearest sticky layer that shifts the sticky box
	NearestLayerShiftingStickyBox LayerTreeLayerID `json:"nearestLayerShiftingStickyBox,omitempty"`

	// NearestLayerShiftingContainingBlock (optional) The nearest sticky layer that shifts the containing block
	NearestLayerShiftingContainingBlock LayerTreeLayerID `json:"nearestLayerShiftingContainingBlock,omitempty"`
}

// LayerTreePictureTile Serialized fragment of layer picture along with its offset within the layer.
type LayerTreePictureTile struct {

	// X Offset from owning layer left boundary
	X float64 `json:"x"`

	// Y Offset from owning layer top boundary
	Y float64 `json:"y"`

	// Picture Base64-encoded snapshot data.
	Picture []byte `json:"picture"`
}

// LayerTreeLayer Information about a compositing layer.
type LayerTreeLayer struct {

	// LayerID The unique id for this layer.
	LayerID LayerTreeLayerID `json:"layerId"`

	// ParentLayerID (optional) The id of parent (not present for root).
	ParentLayerID LayerTreeLayerID `json:"parentLayerId,omitempty"`

	// BackendNodeID (optional) The backend id for the node associated with this layer.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// OffsetX Offset from parent layer, X coordinate.
	OffsetX float64 `json:"offsetX"`

	// OffsetY Offset from parent layer, Y coordinate.
	OffsetY float64 `json:"offsetY"`

	// Width Layer width.
	Width float64 `json:"width"`

	// Height Layer height.
	Height float64 `json:"height"`

	// Transform (optional) Transformation matrix for layer, default is identity matrix
	Transform []float64 `json:"transform,omitempty"`

	// AnchorX (optional) Transform anchor point X, absent if no transform specified
	AnchorX float64 `json:"anchorX,omitempty"`

	// AnchorY (optional) Transform anchor point Y, absent if no transform specified
	AnchorY float64 `json:"anchorY,omitempty"`

	// AnchorZ (optional) Transform anchor point Z, absent if no transform specified
	AnchorZ float64 `json:"anchorZ,omitempty"`

	// PaintCount Indicates how many time this layer has painted.
	PaintCount int64 `json:"paintCount"`

	// DrawsContent Indicates whether this layer hosts any content, rather than being used for
	// transform/scrolling purposes only.
	DrawsContent bool `json:"drawsContent"`

	// Invisible (optional) Set if layer is not visible.
	Invisible bool `json:"invisible,omitempty"`

	// ScrollRects (optional) Rectangles scrolling on main thread only.
	ScrollRects []*LayerTreeScrollRect `json:"scrollRects,omitempty"`

	// StickyPositionConstraint (optional) Sticky position constraint information
	StickyPositionConstraint *LayerTreeStickyPositionConstraint `json:"stickyPositionConstraint,omitempty"`
}

// LayerTreePaintProfile Array of timings, one per paint step.
type LayerTreePaintProfile []float64

// LayerTreeCompositingReasons Provides the reasons why the given layer was composited.
type LayerTreeCompositingReasons struct {

	// LayerID The id of the layer for which we want to get the reasons it was composited.
	LayerID LayerTreeLayerID `json:"layerId"`
}

// Call of the command, sessionID is optional.
func (m LayerTreeCompositingReasons) Call(caller Caller) (*LayerTreeCompositingReasonsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "LayerTree.compositingReasons", m)
	if err != nil {
		return nil, err
	}

	var res LayerTreeCompositingReasonsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// LayerTreeCompositingReasonsResult Provides the reasons why the given layer was composited.
type LayerTreeCompositingReasonsResult struct {

	// CompositingReasons (deprecated) A list of strings specifying reasons for the given layer to become composited.
	CompositingReasons []string `json:"compositingReasons"`

	// CompositingReasonIds A list of strings specifying reason IDs for the given layer to become composited.
	CompositingReasonIds []string `json:"compositingReasonIds"`
}

// LayerTreeDisable Disables compositing tree inspection.
type LayerTreeDisable struct {
}

// Call of the command, sessionID is optional.
func (m LayerTreeDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "LayerTree.disable", m)
	return err
}

// LayerTreeEnable Enables compositing tree inspection.
type LayerTreeEnable struct {
}

// Call of the command, sessionID is optional.
func (m LayerTreeEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "LayerTree.enable", m)
	return err
}

// LayerTreeLoadSnapshot Returns the snapshot identifier.
type LayerTreeLoadSnapshot struct {

	// Tiles An array of tiles composing the snapshot.
	Tiles []*LayerTreePictureTile `json:"tiles"`
}

// Call of the command, sessionID is optional.
func (m LayerTreeLoadSnapshot) Call(caller Caller) (*LayerTreeLoadSnapshotResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "LayerTree.loadSnapshot", m)
	if err != nil {
		return nil, err
	}

	var res LayerTreeLoadSnapshotResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// LayerTreeLoadSnapshotResult Returns the snapshot identifier.
type LayerTreeLoadSnapshotResult struct {

	// SnapshotID The id of the snapshot.
	SnapshotID LayerTreeSnapshotID `json:"snapshotId"`
}

// LayerTreeMakeSnapshot Returns the layer snapshot identifier.
type LayerTreeMakeSnapshot struct {

	// LayerID The id of the layer.
	LayerID LayerTreeLayerID `json:"layerId"`
}

// Call of the command, sessionID is optional.
func (m LayerTreeMakeSnapshot) Call(caller Caller) (*LayerTreeMakeSnapshotResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "LayerTree.makeSnapshot", m)
	if err != nil {
		return nil, err
	}

	var res LayerTreeMakeSnapshotResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// LayerTreeMakeSnapshotResult Returns the layer snapshot identifier.
type LayerTreeMakeSnapshotResult struct {

	// SnapshotID The id of the layer snapshot.
	SnapshotID LayerTreeSnapshotID `json:"snapshotId"`
}

// LayerTreeProfileSnapshot ...
type LayerTreeProfileSnapshot struct {

	// SnapshotID The id of the layer snapshot.
	SnapshotID LayerTreeSnapshotID `json:"snapshotId"`

	// MinRepeatCount (optional) The maximum number of times to replay the snapshot (1, if not specified).
	MinRepeatCount int64 `json:"minRepeatCount,omitempty"`

	// MinDuration (optional) The minimum duration (in seconds) to replay the snapshot.
	MinDuration float64 `json:"minDuration,omitempty"`

	// ClipRect (optional) The clip rectangle to apply when replaying the snapshot.
	ClipRect *DOMRect `json:"clipRect,omitempty"`
}

// Call of the command, sessionID is optional.
func (m LayerTreeProfileSnapshot) Call(caller Caller) (*LayerTreeProfileSnapshotResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "LayerTree.profileSnapshot", m)
	if err != nil {
		return nil, err
	}

	var res LayerTreeProfileSnapshotResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// LayerTreeProfileSnapshotResult ...
type LayerTreeProfileSnapshotResult struct {

	// Timings The array of paint profiles, one per run.
	Timings []LayerTreePaintProfile `json:"timings"`
}

// LayerTreeReleaseSnapshot Releases layer snapshot captured by the back-end.
type LayerTreeReleaseSnapshot struct {

	// SnapshotID The id of the layer snapshot.
	SnapshotID LayerTreeSnapshotID `json:"snapshotId"`
}

// Call of the command, sessionID is optional.
func (m LayerTreeReleaseSnapshot) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "LayerTree.releaseSnapshot", m)
	return err
}

// LayerTreeReplaySnapshot Replays the layer snapshot and returns the resulting bitmap.
type LayerTreeReplaySnapshot struct {

	// SnapshotID The id of the layer snapshot.
	SnapshotID LayerTreeSnapshotID `json:"snapshotId"`

	// FromStep (optional) The first step to replay from (replay from the very start if not specified).
	FromStep int64 `json:"fromStep,omitempty"`

	// ToStep (optional) The last step to replay to (replay till the end if not specified).
	ToStep int64 `json:"toStep,omitempty"`

	// Scale (optional) The scale to apply while replaying (defaults to 1).
	Scale float64 `json:"scale,omitempty"`
}

// Call of the command, sessionID is optional.
func (m LayerTreeReplaySnapshot) Call(caller Caller) (*LayerTreeReplaySnapshotResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "LayerTree.replaySnapshot", m)
	if err != nil {
		return nil, err
	}

	var res LayerTreeReplaySnapshotResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// LayerTreeReplaySnapshotResult Replays the layer snapshot and returns the resulting bitmap.
type LayerTreeReplaySnapshotResult struct {

	// DataURL A data: URL for resulting image.
	DataURL string `json:"dataURL"`
}

// LayerTreeSnapshotCommandLog Replays the layer snapshot and returns canvas log.
type LayerTreeSnapshotCommandLog struct {

	// SnapshotID The id of the layer snapshot.
	SnapshotID LayerTreeSnapshotID `json:"snapshotId"`
}

// Call of the command, sessionID is optional.
func (m LayerTreeSnapshotCommandLog) Call(caller Caller) (*LayerTreeSnapshotCommandLogResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "LayerTree.snapshotCommandLog", m)
	if err != nil {
		return nil, err
	}

	var res LayerTreeSnapshotCommandLogResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// LayerTreeSnapshotCommandLogResult Replays the layer snapshot and returns canvas log.
type LayerTreeSnapshotCommandLogResult struct {

	// CommandLog The array of canvas function calls.
	CommandLog []map[string]JSON `json:"commandLog"`
}

// LayerTreeLayerPainted ...
type LayerTreeLayerPainted struct {

	// LayerID The id of the painted layer.
	LayerID LayerTreeLayerID `json:"layerId"`

	// Clip Clip rectangle.
	Clip *DOMRect `json:"clip"`
}

// MethodName interface
func (evt LayerTreeLayerPainted) MethodName() string {
	return "LayerTree.layerPainted"
}

// LayerTreeLayerTreeDidChange ...
type LayerTreeLayerTreeDidChange struct {

	// Layers (optional) Layer tree, absent if not in the comspositing mode.
	Layers []*LayerTreeLayer `json:"layers,omitempty"`
}

// MethodName interface
func (evt LayerTreeLayerTreeDidChange) MethodName() string {
	return "LayerTree.layerTreeDidChange"
}

// LogLogEntrySource enum
type LogLogEntrySource string

const (
	// LogLogEntrySourceXML enum const
	LogLogEntrySourceXML LogLogEntrySource = "xml"

	// LogLogEntrySourceJavascript enum const
	LogLogEntrySourceJavascript LogLogEntrySource = "javascript"

	// LogLogEntrySourceNetwork enum const
	LogLogEntrySourceNetwork LogLogEntrySource = "network"

	// LogLogEntrySourceStorage enum const
	LogLogEntrySourceStorage LogLogEntrySource = "storage"

	// LogLogEntrySourceAppcache enum const
	LogLogEntrySourceAppcache LogLogEntrySource = "appcache"

	// LogLogEntrySourceRendering enum const
	LogLogEntrySourceRendering LogLogEntrySource = "rendering"

	// LogLogEntrySourceSecurity enum const
	LogLogEntrySourceSecurity LogLogEntrySource = "security"

	// LogLogEntrySourceDeprecation enum const
	LogLogEntrySourceDeprecation LogLogEntrySource = "deprecation"

	// LogLogEntrySourceWorker enum const
	LogLogEntrySourceWorker LogLogEntrySource = "worker"

	// LogLogEntrySourceViolation enum const
	LogLogEntrySourceViolation LogLogEntrySource = "violation"

	// LogLogEntrySourceIntervention enum const
	LogLogEntrySourceIntervention LogLogEntrySource = "intervention"

	// LogLogEntrySourceRecommendation enum const
	LogLogEntrySourceRecommendation LogLogEntrySource = "recommendation"

	// LogLogEntrySourceOther enum const
	LogLogEntrySourceOther LogLogEntrySource = "other"
)

// LogLogEntryLevel enum
type LogLogEntryLevel string

const (
	// LogLogEntryLevelVerbose enum const
	LogLogEntryLevelVerbose LogLogEntryLevel = "verbose"

	// LogLogEntryLevelInfo enum const
	LogLogEntryLevelInfo LogLogEntryLevel = "info"

	// LogLogEntryLevelWarning enum const
	LogLogEntryLevelWarning LogLogEntryLevel = "warning"

	// LogLogEntryLevelError enum const
	LogLogEntryLevelError LogLogEntryLevel = "error"
)

// LogLogEntry Log entry.
type LogLogEntry struct {

	// Source Log entry source.
	Source LogLogEntrySource `json:"source"`

	// Level Log entry severity.
	Level LogLogEntryLevel `json:"level"`

	// Text Logged text.
	Text string `json:"text"`

	// Timestamp Timestamp when this entry was added.
	Timestamp RuntimeTimestamp `json:"timestamp"`

	// URL (optional) URL of the resource if known.
	URL string `json:"url,omitempty"`

	// LineNumber (optional) Line number in the resource.
	LineNumber int64 `json:"lineNumber,omitempty"`

	// StackTrace (optional) JavaScript stack trace.
	StackTrace *RuntimeStackTrace `json:"stackTrace,omitempty"`

	// NetworkRequestID (optional) Identifier of the network request associated with this entry.
	NetworkRequestID NetworkRequestID `json:"networkRequestId,omitempty"`

	// WorkerID (optional) Identifier of the worker associated with this entry.
	WorkerID string `json:"workerId,omitempty"`

	// Args (optional) Call arguments.
	Args []*RuntimeRemoteObject `json:"args,omitempty"`
}

// LogViolationSettingName enum
type LogViolationSettingName string

const (
	// LogViolationSettingNameLongTask enum const
	LogViolationSettingNameLongTask LogViolationSettingName = "longTask"

	// LogViolationSettingNameLongLayout enum const
	LogViolationSettingNameLongLayout LogViolationSettingName = "longLayout"

	// LogViolationSettingNameBlockedEvent enum const
	LogViolationSettingNameBlockedEvent LogViolationSettingName = "blockedEvent"

	// LogViolationSettingNameBlockedParser enum const
	LogViolationSettingNameBlockedParser LogViolationSettingName = "blockedParser"

	// LogViolationSettingNameDiscouragedAPIUse enum const
	LogViolationSettingNameDiscouragedAPIUse LogViolationSettingName = "discouragedAPIUse"

	// LogViolationSettingNameHandler enum const
	LogViolationSettingNameHandler LogViolationSettingName = "handler"

	// LogViolationSettingNameRecurringHandler enum const
	LogViolationSettingNameRecurringHandler LogViolationSettingName = "recurringHandler"
)

// LogViolationSetting Violation configuration setting.
type LogViolationSetting struct {

	// Name Violation type.
	Name LogViolationSettingName `json:"name"`

	// Threshold Time threshold to trigger upon.
	Threshold float64 `json:"threshold"`
}

// LogClear Clears the log.
type LogClear struct {
}

// Call of the command, sessionID is optional.
func (m LogClear) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Log.clear", m)
	return err
}

// LogDisable Disables log domain, prevents further log entries from being reported to the client.
type LogDisable struct {
}

// Call of the command, sessionID is optional.
func (m LogDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Log.disable", m)
	return err
}

// LogEnable Enables log domain, sends the entries collected so far to the client by means of the
// `entryAdded` notification.
type LogEnable struct {
}

// Call of the command, sessionID is optional.
func (m LogEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Log.enable", m)
	return err
}

// LogStartViolationsReport start violation reporting.
type LogStartViolationsReport struct {

	// Config Configuration for violations.
	Config []*LogViolationSetting `json:"config"`
}

// Call of the command, sessionID is optional.
func (m LogStartViolationsReport) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Log.startViolationsReport", m)
	return err
}

// LogStopViolationsReport Stop violation reporting.
type LogStopViolationsReport struct {
}

// Call of the command, sessionID is optional.
func (m LogStopViolationsReport) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Log.stopViolationsReport", m)
	return err
}

// LogEntryAdded Issued when new message was logged.
type LogEntryAdded struct {

	// Entry The entry.
	Entry *LogLogEntry `json:"entry"`
}

// MethodName interface
func (evt LogEntryAdded) MethodName() string {
	return "Log.entryAdded"
}

// MemoryPressureLevel Memory pressure level.
type MemoryPressureLevel string

const (
	// MemoryPressureLevelModerate enum const
	MemoryPressureLevelModerate MemoryPressureLevel = "moderate"

	// MemoryPressureLevelCritical enum const
	MemoryPressureLevelCritical MemoryPressureLevel = "critical"
)

// MemorySamplingProfileNode Heap profile sample.
type MemorySamplingProfileNode struct {

	// Size Size of the sampled allocation.
	Size float64 `json:"size"`

	// Total Total bytes attributed to this sample.
	Total float64 `json:"total"`

	// Stack Execution stack at the point of allocation.
	Stack []string `json:"stack"`
}

// MemorySamplingProfile Array of heap profile samples.
type MemorySamplingProfile struct {

	// Samples ...
	Samples []*MemorySamplingProfileNode `json:"samples"`

	// Modules ...
	Modules []*MemoryModule `json:"modules"`
}

// MemoryModule Executable module information
type MemoryModule struct {

	// Name Name of the module.
	Name string `json:"name"`

	// UUID UUID of the module.
	UUID string `json:"uuid"`

	// BaseAddress Base address where the module is loaded into memory. Encoded as a decimal
	// or hexadecimal (0x prefixed) string.
	BaseAddress string `json:"baseAddress"`

	// Size Size of the module in bytes.
	Size float64 `json:"size"`
}

// MemoryGetDOMCounters ...
type MemoryGetDOMCounters struct {
}

// Call of the command, sessionID is optional.
func (m MemoryGetDOMCounters) Call(caller Caller) (*MemoryGetDOMCountersResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Memory.getDOMCounters", m)
	if err != nil {
		return nil, err
	}

	var res MemoryGetDOMCountersResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// MemoryGetDOMCountersResult ...
type MemoryGetDOMCountersResult struct {

	// Documents ...
	Documents int64 `json:"documents"`

	// Nodes ...
	Nodes int64 `json:"nodes"`

	// JsEventListeners ...
	JsEventListeners int64 `json:"jsEventListeners"`
}

// MemoryPrepareForLeakDetection ...
type MemoryPrepareForLeakDetection struct {
}

// Call of the command, sessionID is optional.
func (m MemoryPrepareForLeakDetection) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Memory.prepareForLeakDetection", m)
	return err
}

// MemoryForciblyPurgeJavaScriptMemory Simulate OomIntervention by purging V8 memory.
type MemoryForciblyPurgeJavaScriptMemory struct {
}

// Call of the command, sessionID is optional.
func (m MemoryForciblyPurgeJavaScriptMemory) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Memory.forciblyPurgeJavaScriptMemory", m)
	return err
}

// MemorySetPressureNotificationsSuppressed Enable/disable suppressing memory pressure notifications in all processes.
type MemorySetPressureNotificationsSuppressed struct {

	// Suppressed If true, memory pressure notifications will be suppressed.
	Suppressed bool `json:"suppressed"`
}

// Call of the command, sessionID is optional.
func (m MemorySetPressureNotificationsSuppressed) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Memory.setPressureNotificationsSuppressed", m)
	return err
}

// MemorySimulatePressureNotification Simulate a memory pressure notification in all processes.
type MemorySimulatePressureNotification struct {

	// Level Memory pressure level of the notification.
	Level MemoryPressureLevel `json:"level"`
}

// Call of the command, sessionID is optional.
func (m MemorySimulatePressureNotification) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Memory.simulatePressureNotification", m)
	return err
}

// MemoryStartSampling Start collecting native memory profile.
type MemoryStartSampling struct {

	// SamplingInterval (optional) Average number of bytes between samples.
	SamplingInterval int64 `json:"samplingInterval,omitempty"`

	// SuppressRandomness (optional) Do not randomize intervals between samples.
	SuppressRandomness bool `json:"suppressRandomness,omitempty"`
}

// Call of the command, sessionID is optional.
func (m MemoryStartSampling) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Memory.startSampling", m)
	return err
}

// MemoryStopSampling Stop collecting native memory profile.
type MemoryStopSampling struct {
}

// Call of the command, sessionID is optional.
func (m MemoryStopSampling) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Memory.stopSampling", m)
	return err
}

// MemoryGetAllTimeSamplingProfile Retrieve native memory allocations profile
// collected since renderer process startup.
type MemoryGetAllTimeSamplingProfile struct {
}

// Call of the command, sessionID is optional.
func (m MemoryGetAllTimeSamplingProfile) Call(caller Caller) (*MemoryGetAllTimeSamplingProfileResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Memory.getAllTimeSamplingProfile", m)
	if err != nil {
		return nil, err
	}

	var res MemoryGetAllTimeSamplingProfileResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// MemoryGetAllTimeSamplingProfileResult Retrieve native memory allocations profile
// collected since renderer process startup.
type MemoryGetAllTimeSamplingProfileResult struct {

	// Profile ...
	Profile *MemorySamplingProfile `json:"profile"`
}

// MemoryGetBrowserSamplingProfile Retrieve native memory allocations profile
// collected since browser process startup.
type MemoryGetBrowserSamplingProfile struct {
}

// Call of the command, sessionID is optional.
func (m MemoryGetBrowserSamplingProfile) Call(caller Caller) (*MemoryGetBrowserSamplingProfileResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Memory.getBrowserSamplingProfile", m)
	if err != nil {
		return nil, err
	}

	var res MemoryGetBrowserSamplingProfileResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// MemoryGetBrowserSamplingProfileResult Retrieve native memory allocations profile
// collected since browser process startup.
type MemoryGetBrowserSamplingProfileResult struct {

	// Profile ...
	Profile *MemorySamplingProfile `json:"profile"`
}

// MemoryGetSamplingProfile Retrieve native memory allocations profile collected since last
// `startSampling` call.
type MemoryGetSamplingProfile struct {
}

// Call of the command, sessionID is optional.
func (m MemoryGetSamplingProfile) Call(caller Caller) (*MemoryGetSamplingProfileResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Memory.getSamplingProfile", m)
	if err != nil {
		return nil, err
	}

	var res MemoryGetSamplingProfileResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// MemoryGetSamplingProfileResult Retrieve native memory allocations profile collected since last
// `startSampling` call.
type MemoryGetSamplingProfileResult struct {

	// Profile ...
	Profile *MemorySamplingProfile `json:"profile"`
}

// NetworkResourceType Resource type as it was perceived by the rendering engine.
type NetworkResourceType string

const (
	// NetworkResourceTypeDocument enum const
	NetworkResourceTypeDocument NetworkResourceType = "Document"

	// NetworkResourceTypeStylesheet enum const
	NetworkResourceTypeStylesheet NetworkResourceType = "Stylesheet"

	// NetworkResourceTypeImage enum const
	NetworkResourceTypeImage NetworkResourceType = "Image"

	// NetworkResourceTypeMedia enum const
	NetworkResourceTypeMedia NetworkResourceType = "Media"

	// NetworkResourceTypeFont enum const
	NetworkResourceTypeFont NetworkResourceType = "Font"

	// NetworkResourceTypeScript enum const
	NetworkResourceTypeScript NetworkResourceType = "Script"

	// NetworkResourceTypeTextTrack enum const
	NetworkResourceTypeTextTrack NetworkResourceType = "TextTrack"

	// NetworkResourceTypeXHR enum const
	NetworkResourceTypeXHR NetworkResourceType = "XHR"

	// NetworkResourceTypeFetch enum const
	NetworkResourceTypeFetch NetworkResourceType = "Fetch"

	// NetworkResourceTypeEventSource enum const
	NetworkResourceTypeEventSource NetworkResourceType = "EventSource"

	// NetworkResourceTypeWebSocket enum const
	NetworkResourceTypeWebSocket NetworkResourceType = "WebSocket"

	// NetworkResourceTypeManifest enum const
	NetworkResourceTypeManifest NetworkResourceType = "Manifest"

	// NetworkResourceTypeSignedExchange enum const
	NetworkResourceTypeSignedExchange NetworkResourceType = "SignedExchange"

	// NetworkResourceTypePing enum const
	NetworkResourceTypePing NetworkResourceType = "Ping"

	// NetworkResourceTypeCSPViolationReport enum const
	NetworkResourceTypeCSPViolationReport NetworkResourceType = "CSPViolationReport"

	// NetworkResourceTypeOther enum const
	NetworkResourceTypeOther NetworkResourceType = "Other"
)

// NetworkLoaderID Unique loader identifier.
type NetworkLoaderID string

// NetworkRequestID Unique request identifier.
type NetworkRequestID string

// NetworkInterceptionID Unique intercepted request identifier.
type NetworkInterceptionID string

// NetworkErrorReason Network level fetch failure reason.
type NetworkErrorReason string

const (
	// NetworkErrorReasonFailed enum const
	NetworkErrorReasonFailed NetworkErrorReason = "Failed"

	// NetworkErrorReasonAborted enum const
	NetworkErrorReasonAborted NetworkErrorReason = "Aborted"

	// NetworkErrorReasonTimedOut enum const
	NetworkErrorReasonTimedOut NetworkErrorReason = "TimedOut"

	// NetworkErrorReasonAccessDenied enum const
	NetworkErrorReasonAccessDenied NetworkErrorReason = "AccessDenied"

	// NetworkErrorReasonConnectionClosed enum const
	NetworkErrorReasonConnectionClosed NetworkErrorReason = "ConnectionClosed"

	// NetworkErrorReasonConnectionReset enum const
	NetworkErrorReasonConnectionReset NetworkErrorReason = "ConnectionReset"

	// NetworkErrorReasonConnectionRefused enum const
	NetworkErrorReasonConnectionRefused NetworkErrorReason = "ConnectionRefused"

	// NetworkErrorReasonConnectionAborted enum const
	NetworkErrorReasonConnectionAborted NetworkErrorReason = "ConnectionAborted"

	// NetworkErrorReasonConnectionFailed enum const
	NetworkErrorReasonConnectionFailed NetworkErrorReason = "ConnectionFailed"

	// NetworkErrorReasonNameNotResolved enum const
	NetworkErrorReasonNameNotResolved NetworkErrorReason = "NameNotResolved"

	// NetworkErrorReasonInternetDisconnected enum const
	NetworkErrorReasonInternetDisconnected NetworkErrorReason = "InternetDisconnected"

	// NetworkErrorReasonAddressUnreachable enum const
	NetworkErrorReasonAddressUnreachable NetworkErrorReason = "AddressUnreachable"

	// NetworkErrorReasonBlockedByClient enum const
	NetworkErrorReasonBlockedByClient NetworkErrorReason = "BlockedByClient"

	// NetworkErrorReasonBlockedByResponse enum const
	NetworkErrorReasonBlockedByResponse NetworkErrorReason = "BlockedByResponse"
)

// NetworkTimeSinceEpoch UTC time in seconds, counted from January 1, 1970.
type NetworkTimeSinceEpoch float64

// NetworkMonotonicTime Monotonically increasing time in seconds since an arbitrary point in the past.
type NetworkMonotonicTime float64

// NetworkHeaders Request / response headers as keys / values of JSON object.
type NetworkHeaders map[string]JSON

// NetworkConnectionType The underlying connection technology that the browser is supposedly using.
type NetworkConnectionType string

const (
	// NetworkConnectionTypeNone enum const
	NetworkConnectionTypeNone NetworkConnectionType = "none"

	// NetworkConnectionTypeCellular2g enum const
	NetworkConnectionTypeCellular2g NetworkConnectionType = "cellular2g"

	// NetworkConnectionTypeCellular3g enum const
	NetworkConnectionTypeCellular3g NetworkConnectionType = "cellular3g"

	// NetworkConnectionTypeCellular4g enum const
	NetworkConnectionTypeCellular4g NetworkConnectionType = "cellular4g"

	// NetworkConnectionTypeBluetooth enum const
	NetworkConnectionTypeBluetooth NetworkConnectionType = "bluetooth"

	// NetworkConnectionTypeEthernet enum const
	NetworkConnectionTypeEthernet NetworkConnectionType = "ethernet"

	// NetworkConnectionTypeWifi enum const
	NetworkConnectionTypeWifi NetworkConnectionType = "wifi"

	// NetworkConnectionTypeWimax enum const
	NetworkConnectionTypeWimax NetworkConnectionType = "wimax"

	// NetworkConnectionTypeOther enum const
	NetworkConnectionTypeOther NetworkConnectionType = "other"
)

// NetworkCookieSameSite Represents the cookie's 'SameSite' status:
// https://tools.ietf.org/html/draft-west-first-party-cookies
type NetworkCookieSameSite string

const (
	// NetworkCookieSameSiteStrict enum const
	NetworkCookieSameSiteStrict NetworkCookieSameSite = "Strict"

	// NetworkCookieSameSiteLax enum const
	NetworkCookieSameSiteLax NetworkCookieSameSite = "Lax"

	// NetworkCookieSameSiteNone enum const
	NetworkCookieSameSiteNone NetworkCookieSameSite = "None"
)

// NetworkCookiePriority (experimental) Represents the cookie's 'Priority' status:
// https://tools.ietf.org/html/draft-west-cookie-priority-00
type NetworkCookiePriority string

const (
	// NetworkCookiePriorityLow enum const
	NetworkCookiePriorityLow NetworkCookiePriority = "Low"

	// NetworkCookiePriorityMedium enum const
	NetworkCookiePriorityMedium NetworkCookiePriority = "Medium"

	// NetworkCookiePriorityHigh enum const
	NetworkCookiePriorityHigh NetworkCookiePriority = "High"
)

// NetworkResourceTiming Timing information for the request.
type NetworkResourceTiming struct {

	// RequestTime Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
	// milliseconds relatively to this requestTime.
	RequestTime float64 `json:"requestTime"`

	// ProxyStart Started resolving proxy.
	ProxyStart float64 `json:"proxyStart"`

	// ProxyEnd Finished resolving proxy.
	ProxyEnd float64 `json:"proxyEnd"`

	// DNSStart Started DNS address resolve.
	DNSStart float64 `json:"dnsStart"`

	// DNSEnd Finished DNS address resolve.
	DNSEnd float64 `json:"dnsEnd"`

	// ConnectStart Started connecting to the remote host.
	ConnectStart float64 `json:"connectStart"`

	// ConnectEnd Connected to the remote host.
	ConnectEnd float64 `json:"connectEnd"`

	// SslStart Started SSL handshake.
	SslStart float64 `json:"sslStart"`

	// SslEnd Finished SSL handshake.
	SslEnd float64 `json:"sslEnd"`

	// WorkerStart (experimental) Started running ServiceWorker.
	WorkerStart float64 `json:"workerStart"`

	// WorkerReady (experimental) Finished Starting ServiceWorker.
	WorkerReady float64 `json:"workerReady"`

	// SendStart Started sending request.
	SendStart float64 `json:"sendStart"`

	// SendEnd Finished sending request.
	SendEnd float64 `json:"sendEnd"`

	// PushStart (experimental) Time the server started pushing request.
	PushStart float64 `json:"pushStart"`

	// PushEnd (experimental) Time the server finished pushing request.
	PushEnd float64 `json:"pushEnd"`

	// ReceiveHeadersEnd Finished receiving response headers.
	ReceiveHeadersEnd float64 `json:"receiveHeadersEnd"`
}

// NetworkResourcePriority Loading priority of a resource request.
type NetworkResourcePriority string

const (
	// NetworkResourcePriorityVeryLow enum const
	NetworkResourcePriorityVeryLow NetworkResourcePriority = "VeryLow"

	// NetworkResourcePriorityLow enum const
	NetworkResourcePriorityLow NetworkResourcePriority = "Low"

	// NetworkResourcePriorityMedium enum const
	NetworkResourcePriorityMedium NetworkResourcePriority = "Medium"

	// NetworkResourcePriorityHigh enum const
	NetworkResourcePriorityHigh NetworkResourcePriority = "High"

	// NetworkResourcePriorityVeryHigh enum const
	NetworkResourcePriorityVeryHigh NetworkResourcePriority = "VeryHigh"
)

// NetworkRequestReferrerPolicy enum
type NetworkRequestReferrerPolicy string

const (
	// NetworkRequestReferrerPolicyUnsafeURL enum const
	NetworkRequestReferrerPolicyUnsafeURL NetworkRequestReferrerPolicy = "unsafe-url"

	// NetworkRequestReferrerPolicyNoReferrerWhenDowngrade enum const
	NetworkRequestReferrerPolicyNoReferrerWhenDowngrade NetworkRequestReferrerPolicy = "no-referrer-when-downgrade"

	// NetworkRequestReferrerPolicyNoReferrer enum const
	NetworkRequestReferrerPolicyNoReferrer NetworkRequestReferrerPolicy = "no-referrer"

	// NetworkRequestReferrerPolicyOrigin enum const
	NetworkRequestReferrerPolicyOrigin NetworkRequestReferrerPolicy = "origin"

	// NetworkRequestReferrerPolicyOriginWhenCrossOrigin enum const
	NetworkRequestReferrerPolicyOriginWhenCrossOrigin NetworkRequestReferrerPolicy = "origin-when-cross-origin"

	// NetworkRequestReferrerPolicySameOrigin enum const
	NetworkRequestReferrerPolicySameOrigin NetworkRequestReferrerPolicy = "same-origin"

	// NetworkRequestReferrerPolicyStrictOrigin enum const
	NetworkRequestReferrerPolicyStrictOrigin NetworkRequestReferrerPolicy = "strict-origin"

	// NetworkRequestReferrerPolicyStrictOriginWhenCrossOrigin enum const
	NetworkRequestReferrerPolicyStrictOriginWhenCrossOrigin NetworkRequestReferrerPolicy = "strict-origin-when-cross-origin"
)

// NetworkRequest HTTP request data.
type NetworkRequest struct {

	// URL Request URL (without fragment).
	URL string `json:"url"`

	// URLFragment (optional) Fragment of the requested URL starting with hash, if present.
	URLFragment string `json:"urlFragment,omitempty"`

	// Method HTTP request method.
	Method string `json:"method"`

	// Headers HTTP request headers.
	Headers NetworkHeaders `json:"headers"`

	// PostData (optional) HTTP POST request data.
	PostData string `json:"postData,omitempty"`

	// HasPostData (optional) True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.
	HasPostData bool `json:"hasPostData,omitempty"`

	// MixedContentType (optional) The mixed content type of the request.
	MixedContentType SecurityMixedContentType `json:"mixedContentType,omitempty"`

	// InitialPriority Priority of the resource request at the time request is sent.
	InitialPriority NetworkResourcePriority `json:"initialPriority"`

	// ReferrerPolicy The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/
	ReferrerPolicy NetworkRequestReferrerPolicy `json:"referrerPolicy"`

	// IsLinkPreload (optional) Whether is loaded via link preload.
	IsLinkPreload bool `json:"isLinkPreload,omitempty"`
}

// NetworkSignedCertificateTimestamp Details of a signed certificate timestamp (SCT).
type NetworkSignedCertificateTimestamp struct {

	// Status Validation status.
	Status string `json:"status"`

	// Origin Origin.
	Origin string `json:"origin"`

	// LogDescription Log name / description.
	LogDescription string `json:"logDescription"`

	// LogID Log ID.
	LogID string `json:"logId"`

	// Timestamp Issuance date.
	Timestamp NetworkTimeSinceEpoch `json:"timestamp"`

	// HashAlgorithm Hash algorithm.
	HashAlgorithm string `json:"hashAlgorithm"`

	// SignatureAlgorithm Signature algorithm.
	SignatureAlgorithm string `json:"signatureAlgorithm"`

	// SignatureData Signature data.
	SignatureData string `json:"signatureData"`
}

// NetworkSecurityDetails Security details about a request.
type NetworkSecurityDetails struct {

	// Protocol Protocol name (e.g. "TLS 1.2" or "QUIC").
	Protocol string `json:"protocol"`

	// KeyExchange Key Exchange used by the connection, or the empty string if not applicable.
	KeyExchange string `json:"keyExchange"`

	// KeyExchangeGroup (optional) (EC)DH group used by the connection, if applicable.
	KeyExchangeGroup string `json:"keyExchangeGroup,omitempty"`

	// Cipher Cipher name.
	Cipher string `json:"cipher"`

	// Mac (optional) TLS MAC. Note that AEAD ciphers do not have separate MACs.
	Mac string `json:"mac,omitempty"`

	// CertificateID Certificate ID value.
	CertificateID SecurityCertificateID `json:"certificateId"`

	// SubjectName Certificate subject name.
	SubjectName string `json:"subjectName"`

	// SanList Subject Alternative Name (SAN) DNS names and IP addresses.
	SanList []string `json:"sanList"`

	// Issuer Name of the issuing CA.
	Issuer string `json:"issuer"`

	// ValidFrom Certificate valid from date.
	ValidFrom NetworkTimeSinceEpoch `json:"validFrom"`

	// ValidTo Certificate valid to (expiration) date
	ValidTo NetworkTimeSinceEpoch `json:"validTo"`

	// SignedCertificateTimestampList List of signed certificate timestamps (SCTs).
	SignedCertificateTimestampList []*NetworkSignedCertificateTimestamp `json:"signedCertificateTimestampList"`

	// CertificateTransparencyCompliance Whether the request complied with Certificate Transparency policy
	CertificateTransparencyCompliance NetworkCertificateTransparencyCompliance `json:"certificateTransparencyCompliance"`
}

// NetworkCertificateTransparencyCompliance Whether the request complied with Certificate Transparency policy.
type NetworkCertificateTransparencyCompliance string

const (
	// NetworkCertificateTransparencyComplianceUnknown enum const
	NetworkCertificateTransparencyComplianceUnknown NetworkCertificateTransparencyCompliance = "unknown"

	// NetworkCertificateTransparencyComplianceNotCompliant enum const
	NetworkCertificateTransparencyComplianceNotCompliant NetworkCertificateTransparencyCompliance = "not-compliant"

	// NetworkCertificateTransparencyComplianceCompliant enum const
	NetworkCertificateTransparencyComplianceCompliant NetworkCertificateTransparencyCompliance = "compliant"
)

// NetworkBlockedReason The reason why request was blocked.
type NetworkBlockedReason string

const (
	// NetworkBlockedReasonOther enum const
	NetworkBlockedReasonOther NetworkBlockedReason = "other"

	// NetworkBlockedReasonCsp enum const
	NetworkBlockedReasonCsp NetworkBlockedReason = "csp"

	// NetworkBlockedReasonMixedContent enum const
	NetworkBlockedReasonMixedContent NetworkBlockedReason = "mixed-content"

	// NetworkBlockedReasonOrigin enum const
	NetworkBlockedReasonOrigin NetworkBlockedReason = "origin"

	// NetworkBlockedReasonInspector enum const
	NetworkBlockedReasonInspector NetworkBlockedReason = "inspector"

	// NetworkBlockedReasonSubresourceFilter enum const
	NetworkBlockedReasonSubresourceFilter NetworkBlockedReason = "subresource-filter"

	// NetworkBlockedReasonContentType enum const
	NetworkBlockedReasonContentType NetworkBlockedReason = "content-type"

	// NetworkBlockedReasonCollapsedByClient enum const
	NetworkBlockedReasonCollapsedByClient NetworkBlockedReason = "collapsed-by-client"
)

// NetworkResponse HTTP response data.
type NetworkResponse struct {

	// URL Response URL. This URL can be different from CachedResource.url in case of redirect.
	URL string `json:"url"`

	// Status HTTP response status code.
	Status int64 `json:"status"`

	// StatusText HTTP response status text.
	StatusText string `json:"statusText"`

	// Headers HTTP response headers.
	Headers NetworkHeaders `json:"headers"`

	// HeadersText (optional) HTTP response headers text.
	HeadersText string `json:"headersText,omitempty"`

	// MIMEType Resource mimeType as determined by the browser.
	MIMEType string `json:"mimeType"`

	// RequestHeaders (optional) Refined HTTP request headers that were actually transmitted over the network.
	RequestHeaders NetworkHeaders `json:"requestHeaders,omitempty"`

	// RequestHeadersText (optional) HTTP request headers text.
	RequestHeadersText string `json:"requestHeadersText,omitempty"`

	// ConnectionReused Specifies whether physical connection was actually reused for this request.
	ConnectionReused bool `json:"connectionReused"`

	// ConnectionID Physical connection id that was actually used for this request.
	ConnectionID float64 `json:"connectionId"`

	// RemoteIPAddress (optional) Remote IP address.
	RemoteIPAddress string `json:"remoteIPAddress,omitempty"`

	// RemotePort (optional) Remote port.
	RemotePort int64 `json:"remotePort,omitempty"`

	// FromDiskCache (optional) Specifies that the request was served from the disk cache.
	FromDiskCache bool `json:"fromDiskCache,omitempty"`

	// FromServiceWorker (optional) Specifies that the request was served from the ServiceWorker.
	FromServiceWorker bool `json:"fromServiceWorker,omitempty"`

	// FromPrefetchCache (optional) Specifies that the request was served from the prefetch cache.
	FromPrefetchCache bool `json:"fromPrefetchCache,omitempty"`

	// EncodedDataLength Total number of bytes received for this request so far.
	EncodedDataLength float64 `json:"encodedDataLength"`

	// Timing (optional) Timing information for the given request.
	Timing *NetworkResourceTiming `json:"timing,omitempty"`

	// Protocol (optional) Protocol used to fetch this request.
	Protocol string `json:"protocol,omitempty"`

	// SecurityState Security state of the request resource.
	SecurityState SecuritySecurityState `json:"securityState"`

	// SecurityDetails (optional) Security details for the request.
	SecurityDetails *NetworkSecurityDetails `json:"securityDetails,omitempty"`
}

// NetworkWebSocketRequest WebSocket request data.
type NetworkWebSocketRequest struct {

	// Headers HTTP request headers.
	Headers NetworkHeaders `json:"headers"`
}

// NetworkWebSocketResponse WebSocket response data.
type NetworkWebSocketResponse struct {

	// Status HTTP response status code.
	Status int64 `json:"status"`

	// StatusText HTTP response status text.
	StatusText string `json:"statusText"`

	// Headers HTTP response headers.
	Headers NetworkHeaders `json:"headers"`

	// HeadersText (optional) HTTP response headers text.
	HeadersText string `json:"headersText,omitempty"`

	// RequestHeaders (optional) HTTP request headers.
	RequestHeaders NetworkHeaders `json:"requestHeaders,omitempty"`

	// RequestHeadersText (optional) HTTP request headers text.
	RequestHeadersText string `json:"requestHeadersText,omitempty"`
}

// NetworkWebSocketFrame WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.
type NetworkWebSocketFrame struct {

	// Opcode WebSocket message opcode.
	Opcode float64 `json:"opcode"`

	// Mask WebSocket message mask.
	Mask bool `json:"mask"`

	// PayloadData WebSocket message payload data.
	// If the opcode is 1, this is a text message and payloadData is a UTF-8 string.
	// If the opcode isn't 1, then payloadData is a base64 encoded string representing binary data.
	PayloadData string `json:"payloadData"`
}

// NetworkCachedResource Information about the cached resource.
type NetworkCachedResource struct {

	// URL Resource URL. This is the url of the original network request.
	URL string `json:"url"`

	// Type Type of this resource.
	Type NetworkResourceType `json:"type"`

	// Response (optional) Cached response data.
	Response *NetworkResponse `json:"response,omitempty"`

	// BodySize Cached response body size.
	BodySize float64 `json:"bodySize"`
}

// NetworkInitiatorType enum
type NetworkInitiatorType string

const (
	// NetworkInitiatorTypeParser enum const
	NetworkInitiatorTypeParser NetworkInitiatorType = "parser"

	// NetworkInitiatorTypeScript enum const
	NetworkInitiatorTypeScript NetworkInitiatorType = "script"

	// NetworkInitiatorTypePreload enum const
	NetworkInitiatorTypePreload NetworkInitiatorType = "preload"

	// NetworkInitiatorTypeSignedExchange enum const
	NetworkInitiatorTypeSignedExchange NetworkInitiatorType = "SignedExchange"

	// NetworkInitiatorTypeOther enum const
	NetworkInitiatorTypeOther NetworkInitiatorType = "other"
)

// NetworkInitiator Information about the request initiator.
type NetworkInitiator struct {

	// Type Type of this initiator.
	Type NetworkInitiatorType `json:"type"`

	// Stack (optional) Initiator JavaScript stack trace, set for Script only.
	Stack *RuntimeStackTrace `json:"stack,omitempty"`

	// URL (optional) Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.
	URL string `json:"url,omitempty"`

	// LineNumber (optional) Initiator line number, set for Parser type or for Script type (when script is importing
	// module) (0-based).
	LineNumber float64 `json:"lineNumber,omitempty"`
}

// NetworkCookie Cookie object
type NetworkCookie struct {

	// Name Cookie name.
	Name string `json:"name"`

	// Value Cookie value.
	Value string `json:"value"`

	// Domain Cookie domain.
	Domain string `json:"domain"`

	// Path Cookie path.
	Path string `json:"path"`

	// Expires Cookie expiration date as the number of seconds since the UNIX epoch.
	Expires float64 `json:"expires"`

	// Size Cookie size.
	Size int64 `json:"size"`

	// HTTPOnly True if cookie is http-only.
	HTTPOnly bool `json:"httpOnly"`

	// Secure True if cookie is secure.
	Secure bool `json:"secure"`

	// Session True in case of session cookie.
	Session bool `json:"session"`

	// SameSite (optional) Cookie SameSite type.
	SameSite NetworkCookieSameSite `json:"sameSite,omitempty"`

	// Priority (experimental) Cookie Priority
	Priority NetworkCookiePriority `json:"priority"`
}

// NetworkSetCookieBlockedReason (experimental) Types of reasons why a cookie may not be stored from a response.
type NetworkSetCookieBlockedReason string

const (
	// NetworkSetCookieBlockedReasonSecureOnly enum const
	NetworkSetCookieBlockedReasonSecureOnly NetworkSetCookieBlockedReason = "SecureOnly"

	// NetworkSetCookieBlockedReasonSameSiteStrict enum const
	NetworkSetCookieBlockedReasonSameSiteStrict NetworkSetCookieBlockedReason = "SameSiteStrict"

	// NetworkSetCookieBlockedReasonSameSiteLax enum const
	NetworkSetCookieBlockedReasonSameSiteLax NetworkSetCookieBlockedReason = "SameSiteLax"

	// NetworkSetCookieBlockedReasonSameSiteUnspecifiedTreatedAsLax enum const
	NetworkSetCookieBlockedReasonSameSiteUnspecifiedTreatedAsLax NetworkSetCookieBlockedReason = "SameSiteUnspecifiedTreatedAsLax"

	// NetworkSetCookieBlockedReasonSameSiteNoneInsecure enum const
	NetworkSetCookieBlockedReasonSameSiteNoneInsecure NetworkSetCookieBlockedReason = "SameSiteNoneInsecure"

	// NetworkSetCookieBlockedReasonUserPreferences enum const
	NetworkSetCookieBlockedReasonUserPreferences NetworkSetCookieBlockedReason = "UserPreferences"

	// NetworkSetCookieBlockedReasonSyntaxError enum const
	NetworkSetCookieBlockedReasonSyntaxError NetworkSetCookieBlockedReason = "SyntaxError"

	// NetworkSetCookieBlockedReasonSchemeNotSupported enum const
	NetworkSetCookieBlockedReasonSchemeNotSupported NetworkSetCookieBlockedReason = "SchemeNotSupported"

	// NetworkSetCookieBlockedReasonOverwriteSecure enum const
	NetworkSetCookieBlockedReasonOverwriteSecure NetworkSetCookieBlockedReason = "OverwriteSecure"

	// NetworkSetCookieBlockedReasonInvalidDomain enum const
	NetworkSetCookieBlockedReasonInvalidDomain NetworkSetCookieBlockedReason = "InvalidDomain"

	// NetworkSetCookieBlockedReasonInvalidPrefix enum const
	NetworkSetCookieBlockedReasonInvalidPrefix NetworkSetCookieBlockedReason = "InvalidPrefix"

	// NetworkSetCookieBlockedReasonUnknownError enum const
	NetworkSetCookieBlockedReasonUnknownError NetworkSetCookieBlockedReason = "UnknownError"
)

// NetworkCookieBlockedReason (experimental) Types of reasons why a cookie may not be sent with a request.
type NetworkCookieBlockedReason string

const (
	// NetworkCookieBlockedReasonSecureOnly enum const
	NetworkCookieBlockedReasonSecureOnly NetworkCookieBlockedReason = "SecureOnly"

	// NetworkCookieBlockedReasonNotOnPath enum const
	NetworkCookieBlockedReasonNotOnPath NetworkCookieBlockedReason = "NotOnPath"

	// NetworkCookieBlockedReasonDomainMismatch enum const
	NetworkCookieBlockedReasonDomainMismatch NetworkCookieBlockedReason = "DomainMismatch"

	// NetworkCookieBlockedReasonSameSiteStrict enum const
	NetworkCookieBlockedReasonSameSiteStrict NetworkCookieBlockedReason = "SameSiteStrict"

	// NetworkCookieBlockedReasonSameSiteLax enum const
	NetworkCookieBlockedReasonSameSiteLax NetworkCookieBlockedReason = "SameSiteLax"

	// NetworkCookieBlockedReasonSameSiteUnspecifiedTreatedAsLax enum const
	NetworkCookieBlockedReasonSameSiteUnspecifiedTreatedAsLax NetworkCookieBlockedReason = "SameSiteUnspecifiedTreatedAsLax"

	// NetworkCookieBlockedReasonSameSiteNoneInsecure enum const
	NetworkCookieBlockedReasonSameSiteNoneInsecure NetworkCookieBlockedReason = "SameSiteNoneInsecure"

	// NetworkCookieBlockedReasonUserPreferences enum const
	NetworkCookieBlockedReasonUserPreferences NetworkCookieBlockedReason = "UserPreferences"

	// NetworkCookieBlockedReasonUnknownError enum const
	NetworkCookieBlockedReasonUnknownError NetworkCookieBlockedReason = "UnknownError"
)

// NetworkBlockedSetCookieWithReason (experimental) A cookie which was not stored from a response with the corresponding reason.
type NetworkBlockedSetCookieWithReason struct {

	// BlockedReasons The reason(s) this cookie was blocked.
	BlockedReasons []NetworkSetCookieBlockedReason `json:"blockedReasons"`

	// CookieLine The string representing this individual cookie as it would appear in the header.
	// This is not the entire "cookie" or "set-cookie" header which could have multiple cookies.
	CookieLine string `json:"cookieLine"`

	// Cookie (optional) The cookie object which represents the cookie which was not stored. It is optional because
	// sometimes complete cookie information is not available, such as in the case of parsing
	// errors.
	Cookie *NetworkCookie `json:"cookie,omitempty"`
}

// NetworkBlockedCookieWithReason (experimental) A cookie with was not sent with a request with the corresponding reason.
type NetworkBlockedCookieWithReason struct {

	// BlockedReasons The reason(s) the cookie was blocked.
	BlockedReasons []NetworkCookieBlockedReason `json:"blockedReasons"`

	// Cookie The cookie object representing the cookie which was not sent.
	Cookie *NetworkCookie `json:"cookie"`
}

// NetworkCookieParam Cookie parameter object
type NetworkCookieParam struct {

	// Name Cookie name.
	Name string `json:"name"`

	// Value Cookie value.
	Value string `json:"value"`

	// URL (optional) The request-URI to associate with the setting of the cookie. This value can affect the
	// default domain and path values of the created cookie.
	URL string `json:"url,omitempty"`

	// Domain (optional) Cookie domain.
	Domain string `json:"domain,omitempty"`

	// Path (optional) Cookie path.
	Path string `json:"path,omitempty"`

	// Secure (optional) True if cookie is secure.
	Secure bool `json:"secure,omitempty"`

	// HTTPOnly (optional) True if cookie is http-only.
	HTTPOnly bool `json:"httpOnly,omitempty"`

	// SameSite (optional) Cookie SameSite type.
	SameSite NetworkCookieSameSite `json:"sameSite,omitempty"`

	// Expires (optional) Cookie expiration date, session cookie if not set
	Expires NetworkTimeSinceEpoch `json:"expires,omitempty"`

	// Priority (experimental) (optional) Cookie Priority.
	Priority NetworkCookiePriority `json:"priority,omitempty"`
}

// NetworkAuthChallengeSource enum
type NetworkAuthChallengeSource string

const (
	// NetworkAuthChallengeSourceServer enum const
	NetworkAuthChallengeSourceServer NetworkAuthChallengeSource = "Server"

	// NetworkAuthChallengeSourceProxy enum const
	NetworkAuthChallengeSourceProxy NetworkAuthChallengeSource = "Proxy"
)

// NetworkAuthChallenge (experimental) Authorization challenge for HTTP status code 401 or 407.
type NetworkAuthChallenge struct {

	// Source (optional) Source of the authentication challenge.
	Source NetworkAuthChallengeSource `json:"source,omitempty"`

	// Origin Origin of the challenger.
	Origin string `json:"origin"`

	// Scheme The authentication scheme used, such as basic or digest
	Scheme string `json:"scheme"`

	// Realm The realm of the challenge. May be empty.
	Realm string `json:"realm"`
}

// NetworkAuthChallengeResponseResponse enum
type NetworkAuthChallengeResponseResponse string

const (
	// NetworkAuthChallengeResponseResponseDefault enum const
	NetworkAuthChallengeResponseResponseDefault NetworkAuthChallengeResponseResponse = "Default"

	// NetworkAuthChallengeResponseResponseCancelAuth enum const
	NetworkAuthChallengeResponseResponseCancelAuth NetworkAuthChallengeResponseResponse = "CancelAuth"

	// NetworkAuthChallengeResponseResponseProvideCredentials enum const
	NetworkAuthChallengeResponseResponseProvideCredentials NetworkAuthChallengeResponseResponse = "ProvideCredentials"
)

// NetworkAuthChallengeResponse (experimental) Response to an AuthChallenge.
type NetworkAuthChallengeResponse struct {

	// Response The decision on what to do in response to the authorization challenge.  Default means
	// deferring to the default behavior of the net stack, which will likely either the Cancel
	// authentication or display a popup dialog box.
	Response NetworkAuthChallengeResponseResponse `json:"response"`

	// Username (optional) The username to provide, possibly empty. Should only be set if response is
	// ProvideCredentials.
	Username string `json:"username,omitempty"`

	// Password (optional) The password to provide, possibly empty. Should only be set if response is
	// ProvideCredentials.
	Password string `json:"password,omitempty"`
}

// NetworkInterceptionStage (experimental) Stages of the interception to begin intercepting. Request will intercept before the request is
// sent. Response will intercept after the response is received.
type NetworkInterceptionStage string

const (
	// NetworkInterceptionStageRequest enum const
	NetworkInterceptionStageRequest NetworkInterceptionStage = "Request"

	// NetworkInterceptionStageHeadersReceived enum const
	NetworkInterceptionStageHeadersReceived NetworkInterceptionStage = "HeadersReceived"
)

// NetworkRequestPattern (experimental) Request pattern for interception.
type NetworkRequestPattern struct {

	// URLPattern (optional) Wildcards ('*' -> zero or more, '?' -> exactly one) are allowed. Escape character is
	// backslash. Omitting is equivalent to "*".
	URLPattern string `json:"urlPattern,omitempty"`

	// ResourceType (optional) If set, only requests for matching resource types will be intercepted.
	ResourceType NetworkResourceType `json:"resourceType,omitempty"`

	// InterceptionStage (optional) Stage at wich to begin intercepting requests. Default is Request.
	InterceptionStage NetworkInterceptionStage `json:"interceptionStage,omitempty"`
}

// NetworkSignedExchangeSignature (experimental) Information about a signed exchange signature.
// https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1
type NetworkSignedExchangeSignature struct {

	// Label Signed exchange signature label.
	Label string `json:"label"`

	// Signature The hex string of signed exchange signature.
	Signature string `json:"signature"`

	// Integrity Signed exchange signature integrity.
	Integrity string `json:"integrity"`

	// CertURL (optional) Signed exchange signature cert Url.
	CertURL string `json:"certUrl,omitempty"`

	// CertSha256 (optional) The hex string of signed exchange signature cert sha256.
	CertSha256 string `json:"certSha256,omitempty"`

	// ValidityURL Signed exchange signature validity Url.
	ValidityURL string `json:"validityUrl"`

	// Date Signed exchange signature date.
	Date int64 `json:"date"`

	// Expires Signed exchange signature expires.
	Expires int64 `json:"expires"`

	// Certificates (optional) The encoded certificates.
	Certificates []string `json:"certificates,omitempty"`
}

// NetworkSignedExchangeHeader (experimental) Information about a signed exchange header.
// https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation
type NetworkSignedExchangeHeader struct {

	// RequestURL Signed exchange request URL.
	RequestURL string `json:"requestUrl"`

	// ResponseCode Signed exchange response code.
	ResponseCode int64 `json:"responseCode"`

	// ResponseHeaders Signed exchange response headers.
	ResponseHeaders NetworkHeaders `json:"responseHeaders"`

	// Signatures Signed exchange response signature.
	Signatures []*NetworkSignedExchangeSignature `json:"signatures"`

	// HeaderIntegrity Signed exchange header integrity hash in the form of "sha256-<base64-hash-value>".
	HeaderIntegrity string `json:"headerIntegrity"`
}

// NetworkSignedExchangeErrorField (experimental) Field type for a signed exchange related error.
type NetworkSignedExchangeErrorField string

const (
	// NetworkSignedExchangeErrorFieldSignatureSig enum const
	NetworkSignedExchangeErrorFieldSignatureSig NetworkSignedExchangeErrorField = "signatureSig"

	// NetworkSignedExchangeErrorFieldSignatureIntegrity enum const
	NetworkSignedExchangeErrorFieldSignatureIntegrity NetworkSignedExchangeErrorField = "signatureIntegrity"

	// NetworkSignedExchangeErrorFieldSignatureCertURL enum const
	NetworkSignedExchangeErrorFieldSignatureCertURL NetworkSignedExchangeErrorField = "signatureCertUrl"

	// NetworkSignedExchangeErrorFieldSignatureCertSha256 enum const
	NetworkSignedExchangeErrorFieldSignatureCertSha256 NetworkSignedExchangeErrorField = "signatureCertSha256"

	// NetworkSignedExchangeErrorFieldSignatureValidityURL enum const
	NetworkSignedExchangeErrorFieldSignatureValidityURL NetworkSignedExchangeErrorField = "signatureValidityUrl"

	// NetworkSignedExchangeErrorFieldSignatureTimestamps enum const
	NetworkSignedExchangeErrorFieldSignatureTimestamps NetworkSignedExchangeErrorField = "signatureTimestamps"
)

// NetworkSignedExchangeError (experimental) Information about a signed exchange response.
type NetworkSignedExchangeError struct {

	// Message Error message.
	Message string `json:"message"`

	// SignatureIndex (optional) The index of the signature which caused the error.
	SignatureIndex int64 `json:"signatureIndex,omitempty"`

	// ErrorField (optional) The field which caused the error.
	ErrorField NetworkSignedExchangeErrorField `json:"errorField,omitempty"`
}

// NetworkSignedExchangeInfo (experimental) Information about a signed exchange response.
type NetworkSignedExchangeInfo struct {

	// OuterResponse The outer response of signed HTTP exchange which was received from network.
	OuterResponse *NetworkResponse `json:"outerResponse"`

	// Header (optional) Information about the signed exchange header.
	Header *NetworkSignedExchangeHeader `json:"header,omitempty"`

	// SecurityDetails (optional) Security details for the signed exchange header.
	SecurityDetails *NetworkSecurityDetails `json:"securityDetails,omitempty"`

	// Errors (optional) Errors occurred while handling the signed exchagne.
	Errors []*NetworkSignedExchangeError `json:"errors,omitempty"`
}

// NetworkCanClearBrowserCache (deprecated) Tells whether clearing browser cache is supported.
type NetworkCanClearBrowserCache struct {
}

// Call of the command, sessionID is optional.
func (m NetworkCanClearBrowserCache) Call(caller Caller) (*NetworkCanClearBrowserCacheResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Network.canClearBrowserCache", m)
	if err != nil {
		return nil, err
	}

	var res NetworkCanClearBrowserCacheResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkCanClearBrowserCacheResult (deprecated) Tells whether clearing browser cache is supported.
type NetworkCanClearBrowserCacheResult struct {

	// Result True if browser cache can be cleared.
	Result bool `json:"result"`
}

// NetworkCanClearBrowserCookies (deprecated) Tells whether clearing browser cookies is supported.
type NetworkCanClearBrowserCookies struct {
}

// Call of the command, sessionID is optional.
func (m NetworkCanClearBrowserCookies) Call(caller Caller) (*NetworkCanClearBrowserCookiesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Network.canClearBrowserCookies", m)
	if err != nil {
		return nil, err
	}

	var res NetworkCanClearBrowserCookiesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkCanClearBrowserCookiesResult (deprecated) Tells whether clearing browser cookies is supported.
type NetworkCanClearBrowserCookiesResult struct {

	// Result True if browser cookies can be cleared.
	Result bool `json:"result"`
}

// NetworkCanEmulateNetworkConditions (deprecated) Tells whether emulation of network conditions is supported.
type NetworkCanEmulateNetworkConditions struct {
}

// Call of the command, sessionID is optional.
func (m NetworkCanEmulateNetworkConditions) Call(caller Caller) (*NetworkCanEmulateNetworkConditionsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Network.canEmulateNetworkConditions", m)
	if err != nil {
		return nil, err
	}

	var res NetworkCanEmulateNetworkConditionsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkCanEmulateNetworkConditionsResult (deprecated) Tells whether emulation of network conditions is supported.
type NetworkCanEmulateNetworkConditionsResult struct {

	// Result True if emulation of network conditions is supported.
	Result bool `json:"result"`
}

// NetworkClearBrowserCache Clears browser cache.
type NetworkClearBrowserCache struct {
}

// Call of the command, sessionID is optional.
func (m NetworkClearBrowserCache) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.clearBrowserCache", m)
	return err
}

// NetworkClearBrowserCookies Clears browser cookies.
type NetworkClearBrowserCookies struct {
}

// Call of the command, sessionID is optional.
func (m NetworkClearBrowserCookies) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.clearBrowserCookies", m)
	return err
}

// NetworkContinueInterceptedRequest (deprecated) (experimental) Response to Network.requestIntercepted which either modifies the request to continue with any
// modifications, or blocks it, or completes it with the provided response bytes. If a network
// fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
// event will be sent with the same InterceptionId.
// Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead.
type NetworkContinueInterceptedRequest struct {

	// InterceptionID ...
	InterceptionID NetworkInterceptionID `json:"interceptionId"`

	// ErrorReason (optional) If set this causes the request to fail with the given reason. Passing `Aborted` for requests
	// marked with `isNavigationRequest` also cancels the navigation. Must not be set in response
	// to an authChallenge.
	ErrorReason NetworkErrorReason `json:"errorReason,omitempty"`

	// RawResponse (optional) If set the requests completes using with the provided base64 encoded raw response, including
	// HTTP status line and headers etc... Must not be set in response to an authChallenge.
	RawResponse []byte `json:"rawResponse,omitempty"`

	// URL (optional) If set the request url will be modified in a way that's not observable by page. Must not be
	// set in response to an authChallenge.
	URL string `json:"url,omitempty"`

	// Method (optional) If set this allows the request method to be overridden. Must not be set in response to an
	// authChallenge.
	Method string `json:"method,omitempty"`

	// PostData (optional) If set this allows postData to be set. Must not be set in response to an authChallenge.
	PostData string `json:"postData,omitempty"`

	// Headers (optional) If set this allows the request headers to be changed. Must not be set in response to an
	// authChallenge.
	Headers NetworkHeaders `json:"headers,omitempty"`

	// AuthChallengeResponse (optional) Response to a requestIntercepted with an authChallenge. Must not be set otherwise.
	AuthChallengeResponse *NetworkAuthChallengeResponse `json:"authChallengeResponse,omitempty"`
}

// Call of the command, sessionID is optional.
func (m NetworkContinueInterceptedRequest) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.continueInterceptedRequest", m)
	return err
}

// NetworkDeleteCookies Deletes browser cookies with matching name and url or domain/path pair.
type NetworkDeleteCookies struct {

	// Name Name of the cookies to remove.
	Name string `json:"name"`

	// URL (optional) If specified, deletes all the cookies with the given name where domain and path match
	// provided URL.
	URL string `json:"url,omitempty"`

	// Domain (optional) If specified, deletes only cookies with the exact domain.
	Domain string `json:"domain,omitempty"`

	// Path (optional) If specified, deletes only cookies with the exact path.
	Path string `json:"path,omitempty"`
}

// Call of the command, sessionID is optional.
func (m NetworkDeleteCookies) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.deleteCookies", m)
	return err
}

// NetworkDisable Disables network tracking, prevents network events from being sent to the client.
type NetworkDisable struct {
}

// Call of the command, sessionID is optional.
func (m NetworkDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.disable", m)
	return err
}

// NetworkEmulateNetworkConditions Activates emulation of network conditions.
type NetworkEmulateNetworkConditions struct {

	// Offline True to emulate internet disconnection.
	Offline bool `json:"offline"`

	// Latency Minimum latency from request sent to response headers received (ms).
	Latency float64 `json:"latency"`

	// DownloadThroughput Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.
	DownloadThroughput float64 `json:"downloadThroughput"`

	// UploadThroughput Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling.
	UploadThroughput float64 `json:"uploadThroughput"`

	// ConnectionType (optional) Connection type if known.
	ConnectionType NetworkConnectionType `json:"connectionType,omitempty"`
}

// Call of the command, sessionID is optional.
func (m NetworkEmulateNetworkConditions) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.emulateNetworkConditions", m)
	return err
}

// NetworkEnable Enables network tracking, network events will now be delivered to the client.
type NetworkEnable struct {

	// MaxTotalBufferSize (experimental) (optional) Buffer size in bytes to use when preserving network payloads (XHRs, etc).
	MaxTotalBufferSize int64 `json:"maxTotalBufferSize,omitempty"`

	// MaxResourceBufferSize (experimental) (optional) Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).
	MaxResourceBufferSize int64 `json:"maxResourceBufferSize,omitempty"`

	// MaxPostDataSize (optional) Longest post body size (in bytes) that would be included in requestWillBeSent notification
	MaxPostDataSize int64 `json:"maxPostDataSize,omitempty"`
}

// Call of the command, sessionID is optional.
func (m NetworkEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.enable", m)
	return err
}

// NetworkGetAllCookies Returns all browser cookies. Depending on the backend support, will return detailed cookie
// information in the `cookies` field.
type NetworkGetAllCookies struct {
}

// Call of the command, sessionID is optional.
func (m NetworkGetAllCookies) Call(caller Caller) (*NetworkGetAllCookiesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Network.getAllCookies", m)
	if err != nil {
		return nil, err
	}

	var res NetworkGetAllCookiesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkGetAllCookiesResult Returns all browser cookies. Depending on the backend support, will return detailed cookie
// information in the `cookies` field.
type NetworkGetAllCookiesResult struct {

	// Cookies Array of cookie objects.
	Cookies []*NetworkCookie `json:"cookies"`
}

// NetworkGetCertificate (experimental) Returns the DER-encoded certificate.
type NetworkGetCertificate struct {

	// Origin Origin to get certificate for.
	Origin string `json:"origin"`
}

// Call of the command, sessionID is optional.
func (m NetworkGetCertificate) Call(caller Caller) (*NetworkGetCertificateResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Network.getCertificate", m)
	if err != nil {
		return nil, err
	}

	var res NetworkGetCertificateResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkGetCertificateResult (experimental) Returns the DER-encoded certificate.
type NetworkGetCertificateResult struct {

	// TableNames ...
	TableNames []string `json:"tableNames"`
}

// NetworkGetCookies Returns all browser cookies for the current URL. Depending on the backend support, will return
// detailed cookie information in the `cookies` field.
type NetworkGetCookies struct {

	// Urls (optional) The list of URLs for which applicable cookies will be fetched
	Urls []string `json:"urls,omitempty"`
}

// Call of the command, sessionID is optional.
func (m NetworkGetCookies) Call(caller Caller) (*NetworkGetCookiesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Network.getCookies", m)
	if err != nil {
		return nil, err
	}

	var res NetworkGetCookiesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkGetCookiesResult Returns all browser cookies for the current URL. Depending on the backend support, will return
// detailed cookie information in the `cookies` field.
type NetworkGetCookiesResult struct {

	// Cookies Array of cookie objects.
	Cookies []*NetworkCookie `json:"cookies"`
}

// NetworkGetResponseBody Returns content served for the given request.
type NetworkGetResponseBody struct {

	// RequestID Identifier of the network request to get content for.
	RequestID NetworkRequestID `json:"requestId"`
}

// Call of the command, sessionID is optional.
func (m NetworkGetResponseBody) Call(caller Caller) (*NetworkGetResponseBodyResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Network.getResponseBody", m)
	if err != nil {
		return nil, err
	}

	var res NetworkGetResponseBodyResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkGetResponseBodyResult Returns content served for the given request.
type NetworkGetResponseBodyResult struct {

	// Body Response body.
	Body string `json:"body"`

	// Base64Encoded True, if content was sent as base64.
	Base64Encoded bool `json:"base64Encoded"`
}

// NetworkGetRequestPostData Returns post data sent with the request. Returns an error when no data was sent with the request.
type NetworkGetRequestPostData struct {

	// RequestID Identifier of the network request to get content for.
	RequestID NetworkRequestID `json:"requestId"`
}

// Call of the command, sessionID is optional.
func (m NetworkGetRequestPostData) Call(caller Caller) (*NetworkGetRequestPostDataResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Network.getRequestPostData", m)
	if err != nil {
		return nil, err
	}

	var res NetworkGetRequestPostDataResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkGetRequestPostDataResult Returns post data sent with the request. Returns an error when no data was sent with the request.
type NetworkGetRequestPostDataResult struct {

	// PostData Request body string, omitting files from multipart requests
	PostData string `json:"postData"`
}

// NetworkGetResponseBodyForInterception (experimental) Returns content served for the given currently intercepted request.
type NetworkGetResponseBodyForInterception struct {

	// InterceptionID Identifier for the intercepted request to get body for.
	InterceptionID NetworkInterceptionID `json:"interceptionId"`
}

// Call of the command, sessionID is optional.
func (m NetworkGetResponseBodyForInterception) Call(caller Caller) (*NetworkGetResponseBodyForInterceptionResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Network.getResponseBodyForInterception", m)
	if err != nil {
		return nil, err
	}

	var res NetworkGetResponseBodyForInterceptionResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkGetResponseBodyForInterceptionResult (experimental) Returns content served for the given currently intercepted request.
type NetworkGetResponseBodyForInterceptionResult struct {

	// Body Response body.
	Body string `json:"body"`

	// Base64Encoded True, if content was sent as base64.
	Base64Encoded bool `json:"base64Encoded"`
}

// NetworkTakeResponseBodyForInterceptionAsStream (experimental) Returns a handle to the stream representing the response body. Note that after this command,
// the intercepted request can't be continued as is -- you either need to cancel it or to provide
// the response body. The stream only supports sequential read, IO.read will fail if the position
// is specified.
type NetworkTakeResponseBodyForInterceptionAsStream struct {

	// InterceptionID ...
	InterceptionID NetworkInterceptionID `json:"interceptionId"`
}

// Call of the command, sessionID is optional.
func (m NetworkTakeResponseBodyForInterceptionAsStream) Call(caller Caller) (*NetworkTakeResponseBodyForInterceptionAsStreamResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Network.takeResponseBodyForInterceptionAsStream", m)
	if err != nil {
		return nil, err
	}

	var res NetworkTakeResponseBodyForInterceptionAsStreamResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkTakeResponseBodyForInterceptionAsStreamResult (experimental) Returns a handle to the stream representing the response body. Note that after this command,
// the intercepted request can't be continued as is -- you either need to cancel it or to provide
// the response body. The stream only supports sequential read, IO.read will fail if the position
// is specified.
type NetworkTakeResponseBodyForInterceptionAsStreamResult struct {

	// Stream ...
	Stream IOStreamHandle `json:"stream"`
}

// NetworkReplayXHR (experimental) This method sends a new XMLHttpRequest which is identical to the original one. The following
// parameters should be identical: method, url, async, request body, extra headers, withCredentials
// attribute, user, password.
type NetworkReplayXHR struct {

	// RequestID Identifier of XHR to replay.
	RequestID NetworkRequestID `json:"requestId"`
}

// Call of the command, sessionID is optional.
func (m NetworkReplayXHR) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.replayXHR", m)
	return err
}

// NetworkSearchInResponseBody (experimental) Searches for given string in response content.
type NetworkSearchInResponseBody struct {

	// RequestID Identifier of the network response to search.
	RequestID NetworkRequestID `json:"requestId"`

	// Query String to search for.
	Query string `json:"query"`

	// CaseSensitive (optional) If true, search is case sensitive.
	CaseSensitive bool `json:"caseSensitive,omitempty"`

	// IsRegex (optional) If true, treats string parameter as regex.
	IsRegex bool `json:"isRegex,omitempty"`
}

// Call of the command, sessionID is optional.
func (m NetworkSearchInResponseBody) Call(caller Caller) (*NetworkSearchInResponseBodyResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Network.searchInResponseBody", m)
	if err != nil {
		return nil, err
	}

	var res NetworkSearchInResponseBodyResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkSearchInResponseBodyResult (experimental) Searches for given string in response content.
type NetworkSearchInResponseBodyResult struct {

	// Result List of search matches.
	Result []*DebuggerSearchMatch `json:"result"`
}

// NetworkSetBlockedURLs (experimental) Blocks URLs from loading.
type NetworkSetBlockedURLs struct {

	// Urls URL patterns to block. Wildcards ('*') are allowed.
	Urls []string `json:"urls"`
}

// Call of the command, sessionID is optional.
func (m NetworkSetBlockedURLs) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.setBlockedURLs", m)
	return err
}

// NetworkSetBypassServiceWorker (experimental) Toggles ignoring of service worker for each request.
type NetworkSetBypassServiceWorker struct {

	// Bypass Bypass service worker and load from network.
	Bypass bool `json:"bypass"`
}

// Call of the command, sessionID is optional.
func (m NetworkSetBypassServiceWorker) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.setBypassServiceWorker", m)
	return err
}

// NetworkSetCacheDisabled Toggles ignoring cache for each request. If `true`, cache will not be used.
type NetworkSetCacheDisabled struct {

	// CacheDisabled Cache disabled state.
	CacheDisabled bool `json:"cacheDisabled"`
}

// Call of the command, sessionID is optional.
func (m NetworkSetCacheDisabled) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.setCacheDisabled", m)
	return err
}

// NetworkSetCookie Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
type NetworkSetCookie struct {

	// Name Cookie name.
	Name string `json:"name"`

	// Value Cookie value.
	Value string `json:"value"`

	// URL (optional) The request-URI to associate with the setting of the cookie. This value can affect the
	// default domain and path values of the created cookie.
	URL string `json:"url,omitempty"`

	// Domain (optional) Cookie domain.
	Domain string `json:"domain,omitempty"`

	// Path (optional) Cookie path.
	Path string `json:"path,omitempty"`

	// Secure (optional) True if cookie is secure.
	Secure bool `json:"secure,omitempty"`

	// HTTPOnly (optional) True if cookie is http-only.
	HTTPOnly bool `json:"httpOnly,omitempty"`

	// SameSite (optional) Cookie SameSite type.
	SameSite NetworkCookieSameSite `json:"sameSite,omitempty"`

	// Expires (optional) Cookie expiration date, session cookie if not set
	Expires NetworkTimeSinceEpoch `json:"expires,omitempty"`

	// Priority (experimental) (optional) Cookie Priority type.
	Priority NetworkCookiePriority `json:"priority,omitempty"`
}

// Call of the command, sessionID is optional.
func (m NetworkSetCookie) Call(caller Caller) (*NetworkSetCookieResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Network.setCookie", m)
	if err != nil {
		return nil, err
	}

	var res NetworkSetCookieResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// NetworkSetCookieResult Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
type NetworkSetCookieResult struct {

	// Success True if successfully set cookie.
	Success bool `json:"success"`
}

// NetworkSetCookies Sets given cookies.
type NetworkSetCookies struct {

	// Cookies Cookies to be set.
	Cookies []*NetworkCookieParam `json:"cookies"`
}

// Call of the command, sessionID is optional.
func (m NetworkSetCookies) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.setCookies", m)
	return err
}

// NetworkSetDataSizeLimitsForTest (experimental) For testing.
type NetworkSetDataSizeLimitsForTest struct {

	// MaxTotalSize Maximum total buffer size.
	MaxTotalSize int64 `json:"maxTotalSize"`

	// MaxResourceSize Maximum per-resource size.
	MaxResourceSize int64 `json:"maxResourceSize"`
}

// Call of the command, sessionID is optional.
func (m NetworkSetDataSizeLimitsForTest) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.setDataSizeLimitsForTest", m)
	return err
}

// NetworkSetExtraHTTPHeaders Specifies whether to always send extra HTTP headers with the requests from this page.
type NetworkSetExtraHTTPHeaders struct {

	// Headers Map with extra HTTP headers.
	Headers NetworkHeaders `json:"headers"`
}

// Call of the command, sessionID is optional.
func (m NetworkSetExtraHTTPHeaders) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.setExtraHTTPHeaders", m)
	return err
}

// NetworkSetRequestInterception (deprecated) (experimental) Sets the requests to intercept that match the provided patterns and optionally resource types.
// Deprecated, please use Fetch.enable instead.
type NetworkSetRequestInterception struct {

	// Patterns Requests matching any of these patterns will be forwarded and wait for the corresponding
	// continueInterceptedRequest call.
	Patterns []*NetworkRequestPattern `json:"patterns"`
}

// Call of the command, sessionID is optional.
func (m NetworkSetRequestInterception) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.setRequestInterception", m)
	return err
}

// NetworkSetUserAgentOverride Allows overriding user agent with the given string.
type NetworkSetUserAgentOverride struct {

	// UserAgent User agent to use.
	UserAgent string `json:"userAgent"`

	// AcceptLanguage (optional) Browser langugage to emulate.
	AcceptLanguage string `json:"acceptLanguage,omitempty"`

	// Platform (optional) The platform navigator.platform should return.
	Platform string `json:"platform,omitempty"`
}

// Call of the command, sessionID is optional.
func (m NetworkSetUserAgentOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Network.setUserAgentOverride", m)
	return err
}

// NetworkDataReceived Fired when data chunk was received over the network.
type NetworkDataReceived struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`

	// Timestamp Timestamp.
	Timestamp NetworkMonotonicTime `json:"timestamp"`

	// DataLength Data chunk length.
	DataLength int64 `json:"dataLength"`

	// EncodedDataLength Actual bytes received (might be less than dataLength for compressed encodings).
	EncodedDataLength int64 `json:"encodedDataLength"`
}

// MethodName interface
func (evt NetworkDataReceived) MethodName() string {
	return "Network.dataReceived"
}

// NetworkEventSourceMessageReceived Fired when EventSource message is received.
type NetworkEventSourceMessageReceived struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`

	// Timestamp Timestamp.
	Timestamp NetworkMonotonicTime `json:"timestamp"`

	// EventName Message type.
	EventName string `json:"eventName"`

	// EventID Message identifier.
	EventID string `json:"eventId"`

	// Data Message content.
	Data string `json:"data"`
}

// MethodName interface
func (evt NetworkEventSourceMessageReceived) MethodName() string {
	return "Network.eventSourceMessageReceived"
}

// NetworkLoadingFailed Fired when HTTP request has failed to load.
type NetworkLoadingFailed struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`

	// Timestamp Timestamp.
	Timestamp NetworkMonotonicTime `json:"timestamp"`

	// Type Resource type.
	Type NetworkResourceType `json:"type"`

	// ErrorText User friendly error message.
	ErrorText string `json:"errorText"`

	// Canceled (optional) True if loading was canceled.
	Canceled bool `json:"canceled,omitempty"`

	// BlockedReason (optional) The reason why loading was blocked, if any.
	BlockedReason NetworkBlockedReason `json:"blockedReason,omitempty"`
}

// MethodName interface
func (evt NetworkLoadingFailed) MethodName() string {
	return "Network.loadingFailed"
}

// NetworkLoadingFinished Fired when HTTP request has finished loading.
type NetworkLoadingFinished struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`

	// Timestamp Timestamp.
	Timestamp NetworkMonotonicTime `json:"timestamp"`

	// EncodedDataLength Total number of bytes received for this request.
	EncodedDataLength float64 `json:"encodedDataLength"`

	// ShouldReportCorbBlocking (optional) Set when 1) response was blocked by Cross-Origin Read Blocking and also
	// 2) this needs to be reported to the DevTools console.
	ShouldReportCorbBlocking bool `json:"shouldReportCorbBlocking,omitempty"`
}

// MethodName interface
func (evt NetworkLoadingFinished) MethodName() string {
	return "Network.loadingFinished"
}

// NetworkRequestIntercepted (deprecated) (experimental) Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
// mocked.
// Deprecated, use Fetch.requestPaused instead.
type NetworkRequestIntercepted struct {

	// InterceptionID Each request the page makes will have a unique id, however if any redirects are encountered
	// while processing that fetch, they will be reported with the same id as the original fetch.
	// Likewise if HTTP authentication is needed then the same fetch id will be used.
	InterceptionID NetworkInterceptionID `json:"interceptionId"`

	// Request ...
	Request *NetworkRequest `json:"request"`

	// FrameID The id of the frame that initiated the request.
	FrameID PageFrameID `json:"frameId"`

	// ResourceType How the requested resource will be used.
	ResourceType NetworkResourceType `json:"resourceType"`

	// IsNavigationRequest Whether this is a navigation request, which can abort the navigation completely.
	IsNavigationRequest bool `json:"isNavigationRequest"`

	// IsDownload (optional) Set if the request is a navigation that will result in a download.
	// Only present after response is received from the server (i.e. HeadersReceived stage).
	IsDownload bool `json:"isDownload,omitempty"`

	// RedirectURL (optional) Redirect location, only sent if a redirect was intercepted.
	RedirectURL string `json:"redirectUrl,omitempty"`

	// AuthChallenge (optional) Details of the Authorization Challenge encountered. If this is set then
	// continueInterceptedRequest must contain an authChallengeResponse.
	AuthChallenge *NetworkAuthChallenge `json:"authChallenge,omitempty"`

	// ResponseErrorReason (optional) Response error if intercepted at response stage or if redirect occurred while intercepting
	// request.
	ResponseErrorReason NetworkErrorReason `json:"responseErrorReason,omitempty"`

	// ResponseStatusCode (optional) Response code if intercepted at response stage or if redirect occurred while intercepting
	// request or auth retry occurred.
	ResponseStatusCode int64 `json:"responseStatusCode,omitempty"`

	// ResponseHeaders (optional) Response headers if intercepted at the response stage or if redirect occurred while
	// intercepting request or auth retry occurred.
	ResponseHeaders NetworkHeaders `json:"responseHeaders,omitempty"`

	// RequestID (optional) If the intercepted request had a corresponding requestWillBeSent event fired for it, then
	// this requestId will be the same as the requestId present in the requestWillBeSent event.
	RequestID NetworkRequestID `json:"requestId,omitempty"`
}

// MethodName interface
func (evt NetworkRequestIntercepted) MethodName() string {
	return "Network.requestIntercepted"
}

// NetworkRequestServedFromCache Fired if request ended up loading from cache.
type NetworkRequestServedFromCache struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`
}

// MethodName interface
func (evt NetworkRequestServedFromCache) MethodName() string {
	return "Network.requestServedFromCache"
}

// NetworkRequestWillBeSent Fired when page is about to send HTTP request.
type NetworkRequestWillBeSent struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`

	// LoaderID Loader identifier. Empty string if the request is fetched from worker.
	LoaderID NetworkLoaderID `json:"loaderId"`

	// DocumentURL URL of the document this request is loaded for.
	DocumentURL string `json:"documentURL"`

	// Request Request data.
	Request *NetworkRequest `json:"request"`

	// Timestamp Timestamp.
	Timestamp NetworkMonotonicTime `json:"timestamp"`

	// WallTime Timestamp.
	WallTime NetworkTimeSinceEpoch `json:"wallTime"`

	// Initiator Request initiator.
	Initiator *NetworkInitiator `json:"initiator"`

	// RedirectResponse (optional) Redirect response data.
	RedirectResponse *NetworkResponse `json:"redirectResponse,omitempty"`

	// Type (optional) Type of this resource.
	Type NetworkResourceType `json:"type,omitempty"`

	// FrameID (optional) Frame identifier.
	FrameID PageFrameID `json:"frameId,omitempty"`

	// HasUserGesture (optional) Whether the request is initiated by a user gesture. Defaults to false.
	HasUserGesture bool `json:"hasUserGesture,omitempty"`
}

// MethodName interface
func (evt NetworkRequestWillBeSent) MethodName() string {
	return "Network.requestWillBeSent"
}

// NetworkResourceChangedPriority (experimental) Fired when resource loading priority is changed
type NetworkResourceChangedPriority struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`

	// NewPriority New priority
	NewPriority NetworkResourcePriority `json:"newPriority"`

	// Timestamp Timestamp.
	Timestamp NetworkMonotonicTime `json:"timestamp"`
}

// MethodName interface
func (evt NetworkResourceChangedPriority) MethodName() string {
	return "Network.resourceChangedPriority"
}

// NetworkSignedExchangeReceived (experimental) Fired when a signed exchange was received over the network
type NetworkSignedExchangeReceived struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`

	// Info Information about the signed exchange response.
	Info *NetworkSignedExchangeInfo `json:"info"`
}

// MethodName interface
func (evt NetworkSignedExchangeReceived) MethodName() string {
	return "Network.signedExchangeReceived"
}

// NetworkResponseReceived Fired when HTTP response is available.
type NetworkResponseReceived struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`

	// LoaderID Loader identifier. Empty string if the request is fetched from worker.
	LoaderID NetworkLoaderID `json:"loaderId"`

	// Timestamp Timestamp.
	Timestamp NetworkMonotonicTime `json:"timestamp"`

	// Type Resource type.
	Type NetworkResourceType `json:"type"`

	// Response Response data.
	Response *NetworkResponse `json:"response"`

	// FrameID (optional) Frame identifier.
	FrameID PageFrameID `json:"frameId,omitempty"`
}

// MethodName interface
func (evt NetworkResponseReceived) MethodName() string {
	return "Network.responseReceived"
}

// NetworkWebSocketClosed Fired when WebSocket is closed.
type NetworkWebSocketClosed struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`

	// Timestamp Timestamp.
	Timestamp NetworkMonotonicTime `json:"timestamp"`
}

// MethodName interface
func (evt NetworkWebSocketClosed) MethodName() string {
	return "Network.webSocketClosed"
}

// NetworkWebSocketCreated Fired upon WebSocket creation.
type NetworkWebSocketCreated struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`

	// URL WebSocket request URL.
	URL string `json:"url"`

	// Initiator (optional) Request initiator.
	Initiator *NetworkInitiator `json:"initiator,omitempty"`
}

// MethodName interface
func (evt NetworkWebSocketCreated) MethodName() string {
	return "Network.webSocketCreated"
}

// NetworkWebSocketFrameError Fired when WebSocket message error occurs.
type NetworkWebSocketFrameError struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`

	// Timestamp Timestamp.
	Timestamp NetworkMonotonicTime `json:"timestamp"`

	// ErrorMessage WebSocket error message.
	ErrorMessage string `json:"errorMessage"`
}

// MethodName interface
func (evt NetworkWebSocketFrameError) MethodName() string {
	return "Network.webSocketFrameError"
}

// NetworkWebSocketFrameReceived Fired when WebSocket message is received.
type NetworkWebSocketFrameReceived struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`

	// Timestamp Timestamp.
	Timestamp NetworkMonotonicTime `json:"timestamp"`

	// Response WebSocket response data.
	Response *NetworkWebSocketFrame `json:"response"`
}

// MethodName interface
func (evt NetworkWebSocketFrameReceived) MethodName() string {
	return "Network.webSocketFrameReceived"
}

// NetworkWebSocketFrameSent Fired when WebSocket message is sent.
type NetworkWebSocketFrameSent struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`

	// Timestamp Timestamp.
	Timestamp NetworkMonotonicTime `json:"timestamp"`

	// Response WebSocket response data.
	Response *NetworkWebSocketFrame `json:"response"`
}

// MethodName interface
func (evt NetworkWebSocketFrameSent) MethodName() string {
	return "Network.webSocketFrameSent"
}

// NetworkWebSocketHandshakeResponseReceived Fired when WebSocket handshake response becomes available.
type NetworkWebSocketHandshakeResponseReceived struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`

	// Timestamp Timestamp.
	Timestamp NetworkMonotonicTime `json:"timestamp"`

	// Response WebSocket response data.
	Response *NetworkWebSocketResponse `json:"response"`
}

// MethodName interface
func (evt NetworkWebSocketHandshakeResponseReceived) MethodName() string {
	return "Network.webSocketHandshakeResponseReceived"
}

// NetworkWebSocketWillSendHandshakeRequest Fired when WebSocket is about to initiate handshake.
type NetworkWebSocketWillSendHandshakeRequest struct {

	// RequestID Request identifier.
	RequestID NetworkRequestID `json:"requestId"`

	// Timestamp Timestamp.
	Timestamp NetworkMonotonicTime `json:"timestamp"`

	// WallTime UTC Timestamp.
	WallTime NetworkTimeSinceEpoch `json:"wallTime"`

	// Request WebSocket request data.
	Request *NetworkWebSocketRequest `json:"request"`
}

// MethodName interface
func (evt NetworkWebSocketWillSendHandshakeRequest) MethodName() string {
	return "Network.webSocketWillSendHandshakeRequest"
}

// NetworkRequestWillBeSentExtraInfo (experimental) Fired when additional information about a requestWillBeSent event is available from the
// network stack. Not every requestWillBeSent event will have an additional
// requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent
// or requestWillBeSentExtraInfo will be fired first for the same request.
type NetworkRequestWillBeSentExtraInfo struct {

	// RequestID Request identifier. Used to match this information to an existing requestWillBeSent event.
	RequestID NetworkRequestID `json:"requestId"`

	// BlockedCookies A list of cookies which will not be sent with this request along with corresponding reasons
	// for blocking.
	BlockedCookies []*NetworkBlockedCookieWithReason `json:"blockedCookies"`

	// Headers Raw request headers as they will be sent over the wire.
	Headers NetworkHeaders `json:"headers"`
}

// MethodName interface
func (evt NetworkRequestWillBeSentExtraInfo) MethodName() string {
	return "Network.requestWillBeSentExtraInfo"
}

// NetworkResponseReceivedExtraInfo (experimental) Fired when additional information about a responseReceived event is available from the network
// stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for
// it, and responseReceivedExtraInfo may be fired before or after responseReceived.
type NetworkResponseReceivedExtraInfo struct {

	// RequestID Request identifier. Used to match this information to another responseReceived event.
	RequestID NetworkRequestID `json:"requestId"`

	// BlockedCookies A list of cookies which were not stored from the response along with the corresponding
	// reasons for blocking. The cookies here may not be valid due to syntax errors, which
	// are represented by the invalid cookie line string instead of a proper cookie.
	BlockedCookies []*NetworkBlockedSetCookieWithReason `json:"blockedCookies"`

	// Headers Raw response headers as they were received over the wire.
	Headers NetworkHeaders `json:"headers"`

	// HeadersText (optional) Raw response header text as it was received over the wire. The raw text may not always be
	// available, such as in the case of HTTP/2 or QUIC.
	HeadersText string `json:"headersText,omitempty"`
}

// MethodName interface
func (evt NetworkResponseReceivedExtraInfo) MethodName() string {
	return "Network.responseReceivedExtraInfo"
}

// OverlayHighlightConfig Configuration data for the highlighting of page elements.
type OverlayHighlightConfig struct {

	// ShowInfo (optional) Whether the node info tooltip should be shown (default: false).
	ShowInfo bool `json:"showInfo,omitempty"`

	// ShowStyles (optional) Whether the node styles in the tooltip (default: false).
	ShowStyles bool `json:"showStyles,omitempty"`

	// ShowRulers (optional) Whether the rulers should be shown (default: false).
	ShowRulers bool `json:"showRulers,omitempty"`

	// ShowExtensionLines (optional) Whether the extension lines from node to the rulers should be shown (default: false).
	ShowExtensionLines bool `json:"showExtensionLines,omitempty"`

	// ContentColor (optional) The content box highlight fill color (default: transparent).
	ContentColor *DOMRGBA `json:"contentColor,omitempty"`

	// PaddingColor (optional) The padding highlight fill color (default: transparent).
	PaddingColor *DOMRGBA `json:"paddingColor,omitempty"`

	// BorderColor (optional) The border highlight fill color (default: transparent).
	BorderColor *DOMRGBA `json:"borderColor,omitempty"`

	// MarginColor (optional) The margin highlight fill color (default: transparent).
	MarginColor *DOMRGBA `json:"marginColor,omitempty"`

	// EventTargetColor (optional) The event target element highlight fill color (default: transparent).
	EventTargetColor *DOMRGBA `json:"eventTargetColor,omitempty"`

	// ShapeColor (optional) The shape outside fill color (default: transparent).
	ShapeColor *DOMRGBA `json:"shapeColor,omitempty"`

	// ShapeMarginColor (optional) The shape margin fill color (default: transparent).
	ShapeMarginColor *DOMRGBA `json:"shapeMarginColor,omitempty"`

	// CSSGridColor (optional) The grid layout color (default: transparent).
	CSSGridColor *DOMRGBA `json:"cssGridColor,omitempty"`
}

// OverlayInspectMode ...
type OverlayInspectMode string

const (
	// OverlayInspectModeSearchForNode enum const
	OverlayInspectModeSearchForNode OverlayInspectMode = "searchForNode"

	// OverlayInspectModeSearchForUAShadowDOM enum const
	OverlayInspectModeSearchForUAShadowDOM OverlayInspectMode = "searchForUAShadowDOM"

	// OverlayInspectModeCaptureAreaScreenshot enum const
	OverlayInspectModeCaptureAreaScreenshot OverlayInspectMode = "captureAreaScreenshot"

	// OverlayInspectModeShowDistances enum const
	OverlayInspectModeShowDistances OverlayInspectMode = "showDistances"

	// OverlayInspectModeNone enum const
	OverlayInspectModeNone OverlayInspectMode = "none"
)

// OverlayDisable Disables domain notifications.
type OverlayDisable struct {
}

// Call of the command, sessionID is optional.
func (m OverlayDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.disable", m)
	return err
}

// OverlayEnable Enables domain notifications.
type OverlayEnable struct {
}

// Call of the command, sessionID is optional.
func (m OverlayEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.enable", m)
	return err
}

// OverlayGetHighlightObjectForTest For testing.
type OverlayGetHighlightObjectForTest struct {

	// NodeID Id of the node to get highlight object for.
	NodeID DOMNodeID `json:"nodeId"`

	// IncludeDistance (optional) Whether to include distance info.
	IncludeDistance bool `json:"includeDistance,omitempty"`

	// IncludeStyle (optional) Whether to include style info.
	IncludeStyle bool `json:"includeStyle,omitempty"`
}

// Call of the command, sessionID is optional.
func (m OverlayGetHighlightObjectForTest) Call(caller Caller) (*OverlayGetHighlightObjectForTestResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Overlay.getHighlightObjectForTest", m)
	if err != nil {
		return nil, err
	}

	var res OverlayGetHighlightObjectForTestResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// OverlayGetHighlightObjectForTestResult For testing.
type OverlayGetHighlightObjectForTestResult struct {

	// Highlight Highlight data for the node.
	Highlight map[string]JSON `json:"highlight"`
}

// OverlayHideHighlight Hides any highlight.
type OverlayHideHighlight struct {
}

// Call of the command, sessionID is optional.
func (m OverlayHideHighlight) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.hideHighlight", m)
	return err
}

// OverlayHighlightFrame Highlights owner element of the frame with given id.
type OverlayHighlightFrame struct {

	// FrameID Identifier of the frame to highlight.
	FrameID PageFrameID `json:"frameId"`

	// ContentColor (optional) The content box highlight fill color (default: transparent).
	ContentColor *DOMRGBA `json:"contentColor,omitempty"`

	// ContentOutlineColor (optional) The content box highlight outline color (default: transparent).
	ContentOutlineColor *DOMRGBA `json:"contentOutlineColor,omitempty"`
}

// Call of the command, sessionID is optional.
func (m OverlayHighlightFrame) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.highlightFrame", m)
	return err
}

// OverlayHighlightNode Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
// objectId must be specified.
type OverlayHighlightNode struct {

	// HighlightConfig A descriptor for the highlight appearance.
	HighlightConfig *OverlayHighlightConfig `json:"highlightConfig"`

	// NodeID (optional) Identifier of the node to highlight.
	NodeID DOMNodeID `json:"nodeId,omitempty"`

	// BackendNodeID (optional) Identifier of the backend node to highlight.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId,omitempty"`

	// ObjectID (optional) JavaScript object id of the node to be highlighted.
	ObjectID RuntimeRemoteObjectID `json:"objectId,omitempty"`

	// Selector (optional) Selectors to highlight relevant nodes.
	Selector string `json:"selector,omitempty"`
}

// Call of the command, sessionID is optional.
func (m OverlayHighlightNode) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.highlightNode", m)
	return err
}

// OverlayHighlightQuad Highlights given quad. Coordinates are absolute with respect to the main frame viewport.
type OverlayHighlightQuad struct {

	// Quad Quad to highlight
	Quad DOMQuad `json:"quad"`

	// Color (optional) The highlight fill color (default: transparent).
	Color *DOMRGBA `json:"color,omitempty"`

	// OutlineColor (optional) The highlight outline color (default: transparent).
	OutlineColor *DOMRGBA `json:"outlineColor,omitempty"`
}

// Call of the command, sessionID is optional.
func (m OverlayHighlightQuad) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.highlightQuad", m)
	return err
}

// OverlayHighlightRect Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.
type OverlayHighlightRect struct {

	// X X coordinate
	X int64 `json:"x"`

	// Y Y coordinate
	Y int64 `json:"y"`

	// Width Rectangle width
	Width int64 `json:"width"`

	// Height Rectangle height
	Height int64 `json:"height"`

	// Color (optional) The highlight fill color (default: transparent).
	Color *DOMRGBA `json:"color,omitempty"`

	// OutlineColor (optional) The highlight outline color (default: transparent).
	OutlineColor *DOMRGBA `json:"outlineColor,omitempty"`
}

// Call of the command, sessionID is optional.
func (m OverlayHighlightRect) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.highlightRect", m)
	return err
}

// OverlaySetInspectMode Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.
// Backend then generates 'inspectNodeRequested' event upon element selection.
type OverlaySetInspectMode struct {

	// Mode Set an inspection mode.
	Mode OverlayInspectMode `json:"mode"`

	// HighlightConfig (optional) A descriptor for the highlight appearance of hovered-over nodes. May be omitted if `enabled
	// == false`.
	HighlightConfig *OverlayHighlightConfig `json:"highlightConfig,omitempty"`
}

// Call of the command, sessionID is optional.
func (m OverlaySetInspectMode) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.setInspectMode", m)
	return err
}

// OverlaySetShowAdHighlights Highlights owner element of all frames detected to be ads.
type OverlaySetShowAdHighlights struct {

	// Show True for showing ad highlights
	Show bool `json:"show"`
}

// Call of the command, sessionID is optional.
func (m OverlaySetShowAdHighlights) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.setShowAdHighlights", m)
	return err
}

// OverlaySetPausedInDebuggerMessage ...
type OverlaySetPausedInDebuggerMessage struct {

	// Message (optional) The message to display, also triggers resume and step over controls.
	Message string `json:"message,omitempty"`
}

// Call of the command, sessionID is optional.
func (m OverlaySetPausedInDebuggerMessage) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.setPausedInDebuggerMessage", m)
	return err
}

// OverlaySetShowDebugBorders Requests that backend shows debug borders on layers
type OverlaySetShowDebugBorders struct {

	// Show True for showing debug borders
	Show bool `json:"show"`
}

// Call of the command, sessionID is optional.
func (m OverlaySetShowDebugBorders) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.setShowDebugBorders", m)
	return err
}

// OverlaySetShowFPSCounter Requests that backend shows the FPS counter
type OverlaySetShowFPSCounter struct {

	// Show True for showing the FPS counter
	Show bool `json:"show"`
}

// Call of the command, sessionID is optional.
func (m OverlaySetShowFPSCounter) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.setShowFPSCounter", m)
	return err
}

// OverlaySetShowPaintRects Requests that backend shows paint rectangles
type OverlaySetShowPaintRects struct {

	// Result True for showing paint rectangles
	Result bool `json:"result"`
}

// Call of the command, sessionID is optional.
func (m OverlaySetShowPaintRects) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.setShowPaintRects", m)
	return err
}

// OverlaySetShowLayoutShiftRegions Requests that backend shows layout shift regions
type OverlaySetShowLayoutShiftRegions struct {

	// Result True for showing layout shift regions
	Result bool `json:"result"`
}

// Call of the command, sessionID is optional.
func (m OverlaySetShowLayoutShiftRegions) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.setShowLayoutShiftRegions", m)
	return err
}

// OverlaySetShowScrollBottleneckRects Requests that backend shows scroll bottleneck rects
type OverlaySetShowScrollBottleneckRects struct {

	// Show True for showing scroll bottleneck rects
	Show bool `json:"show"`
}

// Call of the command, sessionID is optional.
func (m OverlaySetShowScrollBottleneckRects) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.setShowScrollBottleneckRects", m)
	return err
}

// OverlaySetShowHitTestBorders Requests that backend shows hit-test borders on layers
type OverlaySetShowHitTestBorders struct {

	// Show True for showing hit-test borders
	Show bool `json:"show"`
}

// Call of the command, sessionID is optional.
func (m OverlaySetShowHitTestBorders) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.setShowHitTestBorders", m)
	return err
}

// OverlaySetShowViewportSizeOnResize Paints viewport size upon main frame resize.
type OverlaySetShowViewportSizeOnResize struct {

	// Show Whether to paint size or not.
	Show bool `json:"show"`
}

// Call of the command, sessionID is optional.
func (m OverlaySetShowViewportSizeOnResize) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Overlay.setShowViewportSizeOnResize", m)
	return err
}

// OverlayInspectNodeRequested Fired when the node should be inspected. This happens after call to `setInspectMode` or when
// user manually inspects an element.
type OverlayInspectNodeRequested struct {

	// BackendNodeID Id of the node to inspect.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId"`
}

// MethodName interface
func (evt OverlayInspectNodeRequested) MethodName() string {
	return "Overlay.inspectNodeRequested"
}

// OverlayNodeHighlightRequested Fired when the node should be highlighted. This happens after call to `setInspectMode`.
type OverlayNodeHighlightRequested struct {

	// NodeID ...
	NodeID DOMNodeID `json:"nodeId"`
}

// MethodName interface
func (evt OverlayNodeHighlightRequested) MethodName() string {
	return "Overlay.nodeHighlightRequested"
}

// OverlayScreenshotRequested Fired when user asks to capture screenshot of some area on the page.
type OverlayScreenshotRequested struct {

	// Viewport Viewport to capture, in device independent pixels (dip).
	Viewport *PageViewport `json:"viewport"`
}

// MethodName interface
func (evt OverlayScreenshotRequested) MethodName() string {
	return "Overlay.screenshotRequested"
}

// OverlayInspectModeCanceled Fired when user cancels the inspect mode.
type OverlayInspectModeCanceled struct {
}

// MethodName interface
func (evt OverlayInspectModeCanceled) MethodName() string {
	return "Overlay.inspectModeCanceled"
}

// PageFrameID Unique frame identifier.
type PageFrameID string

// PageFrame Information about the Frame on the page.
type PageFrame struct {

	// ID Frame unique identifier.
	ID PageFrameID `json:"id"`

	// ParentID (optional) Parent frame identifier.
	ParentID string `json:"parentId,omitempty"`

	// LoaderID Identifier of the loader associated with this frame.
	LoaderID NetworkLoaderID `json:"loaderId"`

	// Name (optional) Frame's name as specified in the tag.
	Name string `json:"name,omitempty"`

	// URL Frame document's URL without fragment.
	URL string `json:"url"`

	// URLFragment (experimental) (optional) Frame document's URL fragment including the '#'.
	URLFragment string `json:"urlFragment,omitempty"`

	// SecurityOrigin Frame document's security origin.
	SecurityOrigin string `json:"securityOrigin"`

	// MIMEType Frame document's mimeType as determined by the browser.
	MIMEType string `json:"mimeType"`

	// UnreachableURL (experimental) (optional) If the frame failed to load, this contains the URL that could not be loaded. Note that unlike url above, this URL may contain a fragment.
	UnreachableURL string `json:"unreachableUrl,omitempty"`
}

// PageFrameResource (experimental) Information about the Resource on the page.
type PageFrameResource struct {

	// URL Resource URL.
	URL string `json:"url"`

	// Type Type of this resource.
	Type NetworkResourceType `json:"type"`

	// MIMEType Resource mimeType as determined by the browser.
	MIMEType string `json:"mimeType"`

	// LastModified (optional) last-modified timestamp as reported by server.
	LastModified NetworkTimeSinceEpoch `json:"lastModified,omitempty"`

	// ContentSize (optional) Resource content size.
	ContentSize float64 `json:"contentSize,omitempty"`

	// Failed (optional) True if the resource failed to load.
	Failed bool `json:"failed,omitempty"`

	// Canceled (optional) True if the resource was canceled during loading.
	Canceled bool `json:"canceled,omitempty"`
}

// PageFrameResourceTree (experimental) Information about the Frame hierarchy along with their cached resources.
type PageFrameResourceTree struct {

	// Frame Frame information for this tree item.
	Frame *PageFrame `json:"frame"`

	// ChildFrames (optional) Child frames.
	ChildFrames []*PageFrameResourceTree `json:"childFrames,omitempty"`

	// Resources Information about frame resources.
	Resources []*PageFrameResource `json:"resources"`
}

// PageFrameTree Information about the Frame hierarchy.
type PageFrameTree struct {

	// Frame Frame information for this tree item.
	Frame *PageFrame `json:"frame"`

	// ChildFrames (optional) Child frames.
	ChildFrames []*PageFrameTree `json:"childFrames,omitempty"`
}

// PageScriptIdentifier Unique script identifier.
type PageScriptIdentifier string

// PageTransitionType Transition type.
type PageTransitionType string

const (
	// PageTransitionTypeLink enum const
	PageTransitionTypeLink PageTransitionType = "link"

	// PageTransitionTypeTyped enum const
	PageTransitionTypeTyped PageTransitionType = "typed"

	// PageTransitionTypeAddressBar enum const
	PageTransitionTypeAddressBar PageTransitionType = "address_bar"

	// PageTransitionTypeAutoBookmark enum const
	PageTransitionTypeAutoBookmark PageTransitionType = "auto_bookmark"

	// PageTransitionTypeAutoSubframe enum const
	PageTransitionTypeAutoSubframe PageTransitionType = "auto_subframe"

	// PageTransitionTypeManualSubframe enum const
	PageTransitionTypeManualSubframe PageTransitionType = "manual_subframe"

	// PageTransitionTypeGenerated enum const
	PageTransitionTypeGenerated PageTransitionType = "generated"

	// PageTransitionTypeAutoToplevel enum const
	PageTransitionTypeAutoToplevel PageTransitionType = "auto_toplevel"

	// PageTransitionTypeFormSubmit enum const
	PageTransitionTypeFormSubmit PageTransitionType = "form_submit"

	// PageTransitionTypeReload enum const
	PageTransitionTypeReload PageTransitionType = "reload"

	// PageTransitionTypeKeyword enum const
	PageTransitionTypeKeyword PageTransitionType = "keyword"

	// PageTransitionTypeKeywordGenerated enum const
	PageTransitionTypeKeywordGenerated PageTransitionType = "keyword_generated"

	// PageTransitionTypeOther enum const
	PageTransitionTypeOther PageTransitionType = "other"
)

// PageNavigationEntry Navigation history entry.
type PageNavigationEntry struct {

	// ID Unique id of the navigation history entry.
	ID int64 `json:"id"`

	// URL URL of the navigation history entry.
	URL string `json:"url"`

	// UserTypedURL URL that the user typed in the url bar.
	UserTypedURL string `json:"userTypedURL"`

	// Title Title of the navigation history entry.
	Title string `json:"title"`

	// TransitionType Transition type.
	TransitionType PageTransitionType `json:"transitionType"`
}

// PageScreencastFrameMetadata (experimental) Screencast frame metadata.
type PageScreencastFrameMetadata struct {

	// OffsetTop Top offset in DIP.
	OffsetTop float64 `json:"offsetTop"`

	// PageScaleFactor Page scale factor.
	PageScaleFactor float64 `json:"pageScaleFactor"`

	// DeviceWidth Device screen width in DIP.
	DeviceWidth float64 `json:"deviceWidth"`

	// DeviceHeight Device screen height in DIP.
	DeviceHeight float64 `json:"deviceHeight"`

	// ScrollOffsetX Position of horizontal scroll in CSS pixels.
	ScrollOffsetX float64 `json:"scrollOffsetX"`

	// ScrollOffsetY Position of vertical scroll in CSS pixels.
	ScrollOffsetY float64 `json:"scrollOffsetY"`

	// Timestamp (optional) Frame swap timestamp.
	Timestamp NetworkTimeSinceEpoch `json:"timestamp,omitempty"`
}

// PageDialogType Javascript dialog type.
type PageDialogType string

const (
	// PageDialogTypeAlert enum const
	PageDialogTypeAlert PageDialogType = "alert"

	// PageDialogTypeConfirm enum const
	PageDialogTypeConfirm PageDialogType = "confirm"

	// PageDialogTypePrompt enum const
	PageDialogTypePrompt PageDialogType = "prompt"

	// PageDialogTypeBeforeunload enum const
	PageDialogTypeBeforeunload PageDialogType = "beforeunload"
)

// PageAppManifestError Error while paring app manifest.
type PageAppManifestError struct {

	// Message Error message.
	Message string `json:"message"`

	// Critical If criticial, this is a non-recoverable parse error.
	Critical int64 `json:"critical"`

	// Line Error line.
	Line int64 `json:"line"`

	// Column Error column.
	Column int64 `json:"column"`
}

// PageAppManifestParsedProperties (experimental) Parsed app manifest properties.
type PageAppManifestParsedProperties struct {

	// Scope Computed scope value
	Scope string `json:"scope"`
}

// PageLayoutViewport Layout viewport position and dimensions.
type PageLayoutViewport struct {

	// PageX Horizontal offset relative to the document (CSS pixels).
	PageX int64 `json:"pageX"`

	// PageY Vertical offset relative to the document (CSS pixels).
	PageY int64 `json:"pageY"`

	// ClientWidth Width (CSS pixels), excludes scrollbar if present.
	ClientWidth int64 `json:"clientWidth"`

	// ClientHeight Height (CSS pixels), excludes scrollbar if present.
	ClientHeight int64 `json:"clientHeight"`
}

// PageVisualViewport Visual viewport position, dimensions, and scale.
type PageVisualViewport struct {

	// OffsetX Horizontal offset relative to the layout viewport (CSS pixels).
	OffsetX float64 `json:"offsetX"`

	// OffsetY Vertical offset relative to the layout viewport (CSS pixels).
	OffsetY float64 `json:"offsetY"`

	// PageX Horizontal offset relative to the document (CSS pixels).
	PageX float64 `json:"pageX"`

	// PageY Vertical offset relative to the document (CSS pixels).
	PageY float64 `json:"pageY"`

	// ClientWidth Width (CSS pixels), excludes scrollbar if present.
	ClientWidth float64 `json:"clientWidth"`

	// ClientHeight Height (CSS pixels), excludes scrollbar if present.
	ClientHeight float64 `json:"clientHeight"`

	// Scale Scale relative to the ideal viewport (size at width=device-width).
	Scale float64 `json:"scale"`

	// Zoom (optional) Page zoom factor (CSS to device independent pixels ratio).
	Zoom float64 `json:"zoom,omitempty"`
}

// PageViewport Viewport for capturing screenshot.
type PageViewport struct {

	// X X offset in device independent pixels (dip).
	X float64 `json:"x"`

	// Y Y offset in device independent pixels (dip).
	Y float64 `json:"y"`

	// Width Rectangle width in device independent pixels (dip).
	Width float64 `json:"width"`

	// Height Rectangle height in device independent pixels (dip).
	Height float64 `json:"height"`

	// Scale Page scale factor.
	Scale float64 `json:"scale"`
}

// PageFontFamilies (experimental) Generic font families collection.
type PageFontFamilies struct {

	// Standard (optional) The standard font-family.
	Standard string `json:"standard,omitempty"`

	// Fixed (optional) The fixed font-family.
	Fixed string `json:"fixed,omitempty"`

	// Serif (optional) The serif font-family.
	Serif string `json:"serif,omitempty"`

	// SansSerif (optional) The sansSerif font-family.
	SansSerif string `json:"sansSerif,omitempty"`

	// Cursive (optional) The cursive font-family.
	Cursive string `json:"cursive,omitempty"`

	// Fantasy (optional) The fantasy font-family.
	Fantasy string `json:"fantasy,omitempty"`

	// Pictograph (optional) The pictograph font-family.
	Pictograph string `json:"pictograph,omitempty"`
}

// PageFontSizes (experimental) Default font sizes.
type PageFontSizes struct {

	// Standard (optional) Default standard font size.
	Standard int64 `json:"standard,omitempty"`

	// Fixed (optional) Default fixed font size.
	Fixed int64 `json:"fixed,omitempty"`
}

// PageClientNavigationReason (experimental) ...
type PageClientNavigationReason string

const (
	// PageClientNavigationReasonFormSubmissionGet enum const
	PageClientNavigationReasonFormSubmissionGet PageClientNavigationReason = "formSubmissionGet"

	// PageClientNavigationReasonFormSubmissionPost enum const
	PageClientNavigationReasonFormSubmissionPost PageClientNavigationReason = "formSubmissionPost"

	// PageClientNavigationReasonHTTPHeaderRefresh enum const
	PageClientNavigationReasonHTTPHeaderRefresh PageClientNavigationReason = "httpHeaderRefresh"

	// PageClientNavigationReasonScriptInitiated enum const
	PageClientNavigationReasonScriptInitiated PageClientNavigationReason = "scriptInitiated"

	// PageClientNavigationReasonMetaTagRefresh enum const
	PageClientNavigationReasonMetaTagRefresh PageClientNavigationReason = "metaTagRefresh"

	// PageClientNavigationReasonPageBlockInterstitial enum const
	PageClientNavigationReasonPageBlockInterstitial PageClientNavigationReason = "pageBlockInterstitial"

	// PageClientNavigationReasonReload enum const
	PageClientNavigationReasonReload PageClientNavigationReason = "reload"

	// PageClientNavigationReasonAnchorClick enum const
	PageClientNavigationReasonAnchorClick PageClientNavigationReason = "anchorClick"
)

// PageInstallabilityErrorArgument (experimental) ...
type PageInstallabilityErrorArgument struct {

	// Name Argument name (e.g. name:'minimum-icon-size-in-pixels').
	Name string `json:"name"`

	// Value Argument value (e.g. value:'64').
	Value string `json:"value"`
}

// PageInstallabilityError (experimental) The installability error
type PageInstallabilityError struct {

	// ErrorID The error id (e.g. 'manifest-missing-suitable-icon').
	ErrorID string `json:"errorId"`

	// ErrorArguments The list of error arguments (e.g. {name:'minimum-icon-size-in-pixels', value:'64'}).
	ErrorArguments []*PageInstallabilityErrorArgument `json:"errorArguments"`
}

// PageAddScriptToEvaluateOnLoad (deprecated) (experimental) Deprecated, please use addScriptToEvaluateOnNewDocument instead.
type PageAddScriptToEvaluateOnLoad struct {

	// ScriptSource ...
	ScriptSource string `json:"scriptSource"`
}

// Call of the command, sessionID is optional.
func (m PageAddScriptToEvaluateOnLoad) Call(caller Caller) (*PageAddScriptToEvaluateOnLoadResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.addScriptToEvaluateOnLoad", m)
	if err != nil {
		return nil, err
	}

	var res PageAddScriptToEvaluateOnLoadResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageAddScriptToEvaluateOnLoadResult (deprecated) (experimental) Deprecated, please use addScriptToEvaluateOnNewDocument instead.
type PageAddScriptToEvaluateOnLoadResult struct {

	// Identifier Identifier of the added script.
	Identifier PageScriptIdentifier `json:"identifier"`
}

// PageAddScriptToEvaluateOnNewDocument Evaluates given script in every frame upon creation (before loading frame's scripts).
type PageAddScriptToEvaluateOnNewDocument struct {

	// Source ...
	Source string `json:"source"`

	// WorldName (experimental) (optional) If specified, creates an isolated world with the given name and evaluates given script in it.
	// This world name will be used as the ExecutionContextDescription::name when the corresponding
	// event is emitted.
	WorldName string `json:"worldName,omitempty"`
}

// Call of the command, sessionID is optional.
func (m PageAddScriptToEvaluateOnNewDocument) Call(caller Caller) (*PageAddScriptToEvaluateOnNewDocumentResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.addScriptToEvaluateOnNewDocument", m)
	if err != nil {
		return nil, err
	}

	var res PageAddScriptToEvaluateOnNewDocumentResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageAddScriptToEvaluateOnNewDocumentResult Evaluates given script in every frame upon creation (before loading frame's scripts).
type PageAddScriptToEvaluateOnNewDocumentResult struct {

	// Identifier Identifier of the added script.
	Identifier PageScriptIdentifier `json:"identifier"`
}

// PageBringToFront Brings page to front (activates tab).
type PageBringToFront struct {
}

// Call of the command, sessionID is optional.
func (m PageBringToFront) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.bringToFront", m)
	return err
}

// PageCaptureScreenshotFormat enum
type PageCaptureScreenshotFormat string

const (
	// PageCaptureScreenshotFormatJpeg enum const
	PageCaptureScreenshotFormatJpeg PageCaptureScreenshotFormat = "jpeg"

	// PageCaptureScreenshotFormatPng enum const
	PageCaptureScreenshotFormatPng PageCaptureScreenshotFormat = "png"
)

// PageCaptureScreenshot Capture page screenshot.
type PageCaptureScreenshot struct {

	// Format (optional) Image compression format (defaults to png).
	Format PageCaptureScreenshotFormat `json:"format,omitempty"`

	// Quality (optional) Compression quality from range [0..100] (jpeg only).
	Quality int64 `json:"quality,omitempty"`

	// Clip (optional) Capture the screenshot of a given region only.
	Clip *PageViewport `json:"clip,omitempty"`

	// FromSurface (experimental) (optional) Capture the screenshot from the surface, rather than the view. Defaults to true.
	FromSurface bool `json:"fromSurface,omitempty"`
}

// Call of the command, sessionID is optional.
func (m PageCaptureScreenshot) Call(caller Caller) (*PageCaptureScreenshotResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.captureScreenshot", m)
	if err != nil {
		return nil, err
	}

	var res PageCaptureScreenshotResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageCaptureScreenshotResult Capture page screenshot.
type PageCaptureScreenshotResult struct {

	// Data Base64-encoded image data.
	Data []byte `json:"data"`
}

// PageCaptureSnapshotFormat enum
type PageCaptureSnapshotFormat string

const (
	// PageCaptureSnapshotFormatMhtml enum const
	PageCaptureSnapshotFormatMhtml PageCaptureSnapshotFormat = "mhtml"
)

// PageCaptureSnapshot (experimental) Returns a snapshot of the page as a string. For MHTML format, the serialization includes
// iframes, shadow DOM, external resources, and element-inline styles.
type PageCaptureSnapshot struct {

	// Format (optional) Format (defaults to mhtml).
	Format PageCaptureSnapshotFormat `json:"format,omitempty"`
}

// Call of the command, sessionID is optional.
func (m PageCaptureSnapshot) Call(caller Caller) (*PageCaptureSnapshotResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.captureSnapshot", m)
	if err != nil {
		return nil, err
	}

	var res PageCaptureSnapshotResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageCaptureSnapshotResult (experimental) Returns a snapshot of the page as a string. For MHTML format, the serialization includes
// iframes, shadow DOM, external resources, and element-inline styles.
type PageCaptureSnapshotResult struct {

	// Data Serialized page data.
	Data string `json:"data"`
}

// PageClearDeviceMetricsOverride (deprecated) (experimental) Clears the overriden device metrics.
type PageClearDeviceMetricsOverride struct {
}

// Call of the command, sessionID is optional.
func (m PageClearDeviceMetricsOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.clearDeviceMetricsOverride", m)
	return err
}

// PageClearDeviceOrientationOverride (deprecated) (experimental) Clears the overridden Device Orientation.
type PageClearDeviceOrientationOverride struct {
}

// Call of the command, sessionID is optional.
func (m PageClearDeviceOrientationOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.clearDeviceOrientationOverride", m)
	return err
}

// PageClearGeolocationOverride (deprecated) Clears the overriden Geolocation Position and Error.
type PageClearGeolocationOverride struct {
}

// Call of the command, sessionID is optional.
func (m PageClearGeolocationOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.clearGeolocationOverride", m)
	return err
}

// PageCreateIsolatedWorld Creates an isolated world for the given frame.
type PageCreateIsolatedWorld struct {

	// FrameID Id of the frame in which the isolated world should be created.
	FrameID PageFrameID `json:"frameId"`

	// WorldName (optional) An optional name which is reported in the Execution Context.
	WorldName string `json:"worldName,omitempty"`

	// GrantUniveralAccess (optional) Whether or not universal access should be granted to the isolated world. This is a powerful
	// option, use with caution.
	GrantUniveralAccess bool `json:"grantUniveralAccess,omitempty"`
}

// Call of the command, sessionID is optional.
func (m PageCreateIsolatedWorld) Call(caller Caller) (*PageCreateIsolatedWorldResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.createIsolatedWorld", m)
	if err != nil {
		return nil, err
	}

	var res PageCreateIsolatedWorldResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageCreateIsolatedWorldResult Creates an isolated world for the given frame.
type PageCreateIsolatedWorldResult struct {

	// ExecutionContextID Execution context of the isolated world.
	ExecutionContextID RuntimeExecutionContextID `json:"executionContextId"`
}

// PageDeleteCookie (deprecated) (experimental) Deletes browser cookie with given name, domain and path.
type PageDeleteCookie struct {

	// CookieName Name of the cookie to remove.
	CookieName string `json:"cookieName"`

	// URL URL to match cooke domain and path.
	URL string `json:"url"`
}

// Call of the command, sessionID is optional.
func (m PageDeleteCookie) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.deleteCookie", m)
	return err
}

// PageDisable Disables page domain notifications.
type PageDisable struct {
}

// Call of the command, sessionID is optional.
func (m PageDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.disable", m)
	return err
}

// PageEnable Enables page domain notifications.
type PageEnable struct {
}

// Call of the command, sessionID is optional.
func (m PageEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.enable", m)
	return err
}

// PageGetAppManifest ...
type PageGetAppManifest struct {
}

// Call of the command, sessionID is optional.
func (m PageGetAppManifest) Call(caller Caller) (*PageGetAppManifestResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.getAppManifest", m)
	if err != nil {
		return nil, err
	}

	var res PageGetAppManifestResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageGetAppManifestResult ...
type PageGetAppManifestResult struct {

	// URL Manifest location.
	URL string `json:"url"`

	// Errors ...
	Errors []*PageAppManifestError `json:"errors"`

	// Data (optional) Manifest content.
	Data string `json:"data,omitempty"`

	// Parsed (experimental) (optional) Parsed manifest properties
	Parsed *PageAppManifestParsedProperties `json:"parsed,omitempty"`
}

// PageGetInstallabilityErrors (experimental) ...
type PageGetInstallabilityErrors struct {
}

// Call of the command, sessionID is optional.
func (m PageGetInstallabilityErrors) Call(caller Caller) (*PageGetInstallabilityErrorsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.getInstallabilityErrors", m)
	if err != nil {
		return nil, err
	}

	var res PageGetInstallabilityErrorsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageGetInstallabilityErrorsResult (experimental) ...
type PageGetInstallabilityErrorsResult struct {

	// Errors (deprecated) ...
	Errors []string `json:"errors"`

	// InstallabilityErrors (experimental) ...
	InstallabilityErrors []*PageInstallabilityError `json:"installabilityErrors"`
}

// PageGetManifestIcons (experimental) ...
type PageGetManifestIcons struct {
}

// Call of the command, sessionID is optional.
func (m PageGetManifestIcons) Call(caller Caller) (*PageGetManifestIconsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.getManifestIcons", m)
	if err != nil {
		return nil, err
	}

	var res PageGetManifestIconsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageGetManifestIconsResult (experimental) ...
type PageGetManifestIconsResult struct {

	// PrimaryIcon (optional) ...
	PrimaryIcon []byte `json:"primaryIcon,omitempty"`
}

// PageGetCookies (deprecated) (experimental) Returns all browser cookies. Depending on the backend support, will return detailed cookie
// information in the `cookies` field.
type PageGetCookies struct {
}

// Call of the command, sessionID is optional.
func (m PageGetCookies) Call(caller Caller) (*PageGetCookiesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.getCookies", m)
	if err != nil {
		return nil, err
	}

	var res PageGetCookiesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageGetCookiesResult (deprecated) (experimental) Returns all browser cookies. Depending on the backend support, will return detailed cookie
// information in the `cookies` field.
type PageGetCookiesResult struct {

	// Cookies Array of cookie objects.
	Cookies []*NetworkCookie `json:"cookies"`
}

// PageGetFrameTree Returns present frame tree structure.
type PageGetFrameTree struct {
}

// Call of the command, sessionID is optional.
func (m PageGetFrameTree) Call(caller Caller) (*PageGetFrameTreeResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.getFrameTree", m)
	if err != nil {
		return nil, err
	}

	var res PageGetFrameTreeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageGetFrameTreeResult Returns present frame tree structure.
type PageGetFrameTreeResult struct {

	// FrameTree Present frame tree structure.
	FrameTree *PageFrameTree `json:"frameTree"`
}

// PageGetLayoutMetrics Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
type PageGetLayoutMetrics struct {
}

// Call of the command, sessionID is optional.
func (m PageGetLayoutMetrics) Call(caller Caller) (*PageGetLayoutMetricsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.getLayoutMetrics", m)
	if err != nil {
		return nil, err
	}

	var res PageGetLayoutMetricsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageGetLayoutMetricsResult Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
type PageGetLayoutMetricsResult struct {

	// LayoutViewport Metrics relating to the layout viewport.
	LayoutViewport *PageLayoutViewport `json:"layoutViewport"`

	// VisualViewport Metrics relating to the visual viewport.
	VisualViewport *PageVisualViewport `json:"visualViewport"`

	// ContentSize Size of scrollable area.
	ContentSize *DOMRect `json:"contentSize"`
}

// PageGetNavigationHistory Returns navigation history for the current page.
type PageGetNavigationHistory struct {
}

// Call of the command, sessionID is optional.
func (m PageGetNavigationHistory) Call(caller Caller) (*PageGetNavigationHistoryResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.getNavigationHistory", m)
	if err != nil {
		return nil, err
	}

	var res PageGetNavigationHistoryResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageGetNavigationHistoryResult Returns navigation history for the current page.
type PageGetNavigationHistoryResult struct {

	// CurrentIndex Index of the current navigation history entry.
	CurrentIndex int64 `json:"currentIndex"`

	// Entries Array of navigation history entries.
	Entries []*PageNavigationEntry `json:"entries"`
}

// PageResetNavigationHistory Resets navigation history for the current page.
type PageResetNavigationHistory struct {
}

// Call of the command, sessionID is optional.
func (m PageResetNavigationHistory) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.resetNavigationHistory", m)
	return err
}

// PageGetResourceContent (experimental) Returns content of the given resource.
type PageGetResourceContent struct {

	// FrameID Frame id to get resource for.
	FrameID PageFrameID `json:"frameId"`

	// URL URL of the resource to get content for.
	URL string `json:"url"`
}

// Call of the command, sessionID is optional.
func (m PageGetResourceContent) Call(caller Caller) (*PageGetResourceContentResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.getResourceContent", m)
	if err != nil {
		return nil, err
	}

	var res PageGetResourceContentResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageGetResourceContentResult (experimental) Returns content of the given resource.
type PageGetResourceContentResult struct {

	// Content Resource content.
	Content string `json:"content"`

	// Base64Encoded True, if content was served as base64.
	Base64Encoded bool `json:"base64Encoded"`
}

// PageGetResourceTree (experimental) Returns present frame / resource tree structure.
type PageGetResourceTree struct {
}

// Call of the command, sessionID is optional.
func (m PageGetResourceTree) Call(caller Caller) (*PageGetResourceTreeResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.getResourceTree", m)
	if err != nil {
		return nil, err
	}

	var res PageGetResourceTreeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageGetResourceTreeResult (experimental) Returns present frame / resource tree structure.
type PageGetResourceTreeResult struct {

	// FrameTree Present frame / resource tree structure.
	FrameTree *PageFrameResourceTree `json:"frameTree"`
}

// PageHandleJavaScriptDialog Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
type PageHandleJavaScriptDialog struct {

	// Accept Whether to accept or dismiss the dialog.
	Accept bool `json:"accept"`

	// PromptText (optional) The text to enter into the dialog prompt before accepting. Used only if this is a prompt
	// dialog.
	PromptText string `json:"promptText,omitempty"`
}

// Call of the command, sessionID is optional.
func (m PageHandleJavaScriptDialog) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.handleJavaScriptDialog", m)
	return err
}

// PageNavigate Navigates current page to the given URL.
type PageNavigate struct {

	// URL URL to navigate the page to.
	URL string `json:"url"`

	// Referrer (optional) Referrer URL.
	Referrer string `json:"referrer,omitempty"`

	// TransitionType (optional) Intended transition type.
	TransitionType PageTransitionType `json:"transitionType,omitempty"`

	// FrameID (optional) Frame id to navigate, if not specified navigates the top frame.
	FrameID PageFrameID `json:"frameId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m PageNavigate) Call(caller Caller) (*PageNavigateResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.navigate", m)
	if err != nil {
		return nil, err
	}

	var res PageNavigateResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageNavigateResult Navigates current page to the given URL.
type PageNavigateResult struct {

	// FrameID Frame id that has navigated (or failed to navigate)
	FrameID PageFrameID `json:"frameId"`

	// LoaderID (optional) Loader identifier.
	LoaderID NetworkLoaderID `json:"loaderId,omitempty"`

	// ErrorText (optional) User friendly error message, present if and only if navigation has failed.
	ErrorText string `json:"errorText,omitempty"`
}

// PageNavigateToHistoryEntry Navigates current page to the given history entry.
type PageNavigateToHistoryEntry struct {

	// EntryID Unique id of the entry to navigate to.
	EntryID int64 `json:"entryId"`
}

// Call of the command, sessionID is optional.
func (m PageNavigateToHistoryEntry) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.navigateToHistoryEntry", m)
	return err
}

// PagePrintToPDFTransferMode enum
type PagePrintToPDFTransferMode string

const (
	// PagePrintToPDFTransferModeReturnAsBase64 enum const
	PagePrintToPDFTransferModeReturnAsBase64 PagePrintToPDFTransferMode = "ReturnAsBase64"

	// PagePrintToPDFTransferModeReturnAsStream enum const
	PagePrintToPDFTransferModeReturnAsStream PagePrintToPDFTransferMode = "ReturnAsStream"
)

// PagePrintToPDF Print page as PDF.
type PagePrintToPDF struct {

	// Landscape (optional) Paper orientation. Defaults to false.
	Landscape bool `json:"landscape,omitempty"`

	// DisplayHeaderFooter (optional) Display header and footer. Defaults to false.
	DisplayHeaderFooter bool `json:"displayHeaderFooter,omitempty"`

	// PrintBackground (optional) Print background graphics. Defaults to false.
	PrintBackground bool `json:"printBackground,omitempty"`

	// Scale (optional) Scale of the webpage rendering. Defaults to 1.
	Scale float64 `json:"scale,omitempty"`

	// PaperWidth (optional) Paper width in inches. Defaults to 8.5 inches.
	PaperWidth float64 `json:"paperWidth,omitempty"`

	// PaperHeight (optional) Paper height in inches. Defaults to 11 inches.
	PaperHeight float64 `json:"paperHeight,omitempty"`

	// MarginTop (optional) Top margin in inches. Defaults to 1cm (~0.4 inches).
	MarginTop float64 `json:"marginTop,omitempty"`

	// MarginBottom (optional) Bottom margin in inches. Defaults to 1cm (~0.4 inches).
	MarginBottom float64 `json:"marginBottom,omitempty"`

	// MarginLeft (optional) Left margin in inches. Defaults to 1cm (~0.4 inches).
	MarginLeft float64 `json:"marginLeft,omitempty"`

	// MarginRight (optional) Right margin in inches. Defaults to 1cm (~0.4 inches).
	MarginRight float64 `json:"marginRight,omitempty"`

	// PageRanges (optional) Paper ranges to print, e.g., '1-5, 8, 11-13'. Defaults to the empty string, which means
	// print all pages.
	PageRanges string `json:"pageRanges,omitempty"`

	// IgnoreInvalidPageRanges (optional) Whether to silently ignore invalid but successfully parsed page ranges, such as '3-2'.
	// Defaults to false.
	IgnoreInvalidPageRanges bool `json:"ignoreInvalidPageRanges,omitempty"`

	// HeaderTemplate (optional) HTML template for the print header. Should be valid HTML markup with following
	// classes used to inject printing values into them:
	// - `date`: formatted print date
	// - `title`: document title
	// - `url`: document location
	// - `pageNumber`: current page number
	// - `totalPages`: total pages in the document
	//
	// For example, `<span class=title></span>` would generate span containing the title.
	HeaderTemplate string `json:"headerTemplate,omitempty"`

	// FooterTemplate (optional) HTML template for the print footer. Should use the same format as the `headerTemplate`.
	FooterTemplate string `json:"footerTemplate,omitempty"`

	// PreferCSSPageSize (optional) Whether or not to prefer page size as defined by css. Defaults to false,
	// in which case the content will be scaled to fit the paper size.
	PreferCSSPageSize bool `json:"preferCSSPageSize,omitempty"`

	// TransferMode (experimental) (optional) return as stream
	TransferMode PagePrintToPDFTransferMode `json:"transferMode,omitempty"`
}

// Call of the command, sessionID is optional.
func (m PagePrintToPDF) Call(caller Caller) (*PagePrintToPDFResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.printToPDF", m)
	if err != nil {
		return nil, err
	}

	var res PagePrintToPDFResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PagePrintToPDFResult Print page as PDF.
type PagePrintToPDFResult struct {

	// Data Base64-encoded pdf data. Empty if |returnAsStream| is specified.
	Data []byte `json:"data"`

	// Stream (experimental) (optional) A handle of the stream that holds resulting PDF data.
	Stream IOStreamHandle `json:"stream,omitempty"`
}

// PageReload Reloads given page optionally ignoring the cache.
type PageReload struct {

	// IgnoreCache (optional) If true, browser cache is ignored (as if the user pressed Shift+refresh).
	IgnoreCache bool `json:"ignoreCache,omitempty"`

	// ScriptToEvaluateOnLoad (optional) If set, the script will be injected into all frames of the inspected page after reload.
	// Argument will be ignored if reloading dataURL origin.
	ScriptToEvaluateOnLoad string `json:"scriptToEvaluateOnLoad,omitempty"`
}

// Call of the command, sessionID is optional.
func (m PageReload) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.reload", m)
	return err
}

// PageRemoveScriptToEvaluateOnLoad (deprecated) (experimental) Deprecated, please use removeScriptToEvaluateOnNewDocument instead.
type PageRemoveScriptToEvaluateOnLoad struct {

	// Identifier ...
	Identifier PageScriptIdentifier `json:"identifier"`
}

// Call of the command, sessionID is optional.
func (m PageRemoveScriptToEvaluateOnLoad) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.removeScriptToEvaluateOnLoad", m)
	return err
}

// PageRemoveScriptToEvaluateOnNewDocument Removes given script from the list.
type PageRemoveScriptToEvaluateOnNewDocument struct {

	// Identifier ...
	Identifier PageScriptIdentifier `json:"identifier"`
}

// Call of the command, sessionID is optional.
func (m PageRemoveScriptToEvaluateOnNewDocument) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.removeScriptToEvaluateOnNewDocument", m)
	return err
}

// PageScreencastFrameAck (experimental) Acknowledges that a screencast frame has been received by the frontend.
type PageScreencastFrameAck struct {

	// SessionID Frame number.
	SessionID int64 `json:"sessionId"`
}

// Call of the command, sessionID is optional.
func (m PageScreencastFrameAck) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.screencastFrameAck", m)
	return err
}

// PageSearchInResource (experimental) Searches for given string in resource content.
type PageSearchInResource struct {

	// FrameID Frame id for resource to search in.
	FrameID PageFrameID `json:"frameId"`

	// URL URL of the resource to search in.
	URL string `json:"url"`

	// Query String to search for.
	Query string `json:"query"`

	// CaseSensitive (optional) If true, search is case sensitive.
	CaseSensitive bool `json:"caseSensitive,omitempty"`

	// IsRegex (optional) If true, treats string parameter as regex.
	IsRegex bool `json:"isRegex,omitempty"`
}

// Call of the command, sessionID is optional.
func (m PageSearchInResource) Call(caller Caller) (*PageSearchInResourceResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Page.searchInResource", m)
	if err != nil {
		return nil, err
	}

	var res PageSearchInResourceResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PageSearchInResourceResult (experimental) Searches for given string in resource content.
type PageSearchInResourceResult struct {

	// Result List of search matches.
	Result []*DebuggerSearchMatch `json:"result"`
}

// PageSetAdBlockingEnabled (experimental) Enable Chrome's experimental ad filter on all sites.
type PageSetAdBlockingEnabled struct {

	// Enabled Whether to block ads.
	Enabled bool `json:"enabled"`
}

// Call of the command, sessionID is optional.
func (m PageSetAdBlockingEnabled) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.setAdBlockingEnabled", m)
	return err
}

// PageSetBypassCSP (experimental) Enable page Content Security Policy by-passing.
type PageSetBypassCSP struct {

	// Enabled Whether to bypass page CSP.
	Enabled bool `json:"enabled"`
}

// Call of the command, sessionID is optional.
func (m PageSetBypassCSP) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.setBypassCSP", m)
	return err
}

// PageSetDeviceMetricsOverride (deprecated) (experimental) Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
// window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
// query results).
type PageSetDeviceMetricsOverride struct {

	// Width Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override.
	Width int64 `json:"width"`

	// Height Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override.
	Height int64 `json:"height"`

	// DeviceScaleFactor Overriding device scale factor value. 0 disables the override.
	DeviceScaleFactor float64 `json:"deviceScaleFactor"`

	// Mobile Whether to emulate mobile device. This includes viewport meta tag, overlay scrollbars, text
	// autosizing and more.
	Mobile bool `json:"mobile"`

	// Scale (optional) Scale to apply to resulting view image.
	Scale float64 `json:"scale,omitempty"`

	// ScreenWidth (optional) Overriding screen width value in pixels (minimum 0, maximum 10000000).
	ScreenWidth int64 `json:"screenWidth,omitempty"`

	// ScreenHeight (optional) Overriding screen height value in pixels (minimum 0, maximum 10000000).
	ScreenHeight int64 `json:"screenHeight,omitempty"`

	// PositionX (optional) Overriding view X position on screen in pixels (minimum 0, maximum 10000000).
	PositionX int64 `json:"positionX,omitempty"`

	// PositionY (optional) Overriding view Y position on screen in pixels (minimum 0, maximum 10000000).
	PositionY int64 `json:"positionY,omitempty"`

	// DontSetVisibleSize (optional) Do not set visible view size, rely upon explicit setVisibleSize call.
	DontSetVisibleSize bool `json:"dontSetVisibleSize,omitempty"`

	// ScreenOrientation (optional) Screen orientation override.
	ScreenOrientation *EmulationScreenOrientation `json:"screenOrientation,omitempty"`

	// Viewport (optional) The viewport dimensions and scale. If not set, the override is cleared.
	Viewport *PageViewport `json:"viewport,omitempty"`
}

// Call of the command, sessionID is optional.
func (m PageSetDeviceMetricsOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.setDeviceMetricsOverride", m)
	return err
}

// PageSetDeviceOrientationOverride (deprecated) (experimental) Overrides the Device Orientation.
type PageSetDeviceOrientationOverride struct {

	// Alpha Mock alpha
	Alpha float64 `json:"alpha"`

	// Beta Mock beta
	Beta float64 `json:"beta"`

	// Gamma Mock gamma
	Gamma float64 `json:"gamma"`
}

// Call of the command, sessionID is optional.
func (m PageSetDeviceOrientationOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.setDeviceOrientationOverride", m)
	return err
}

// PageSetFontFamilies (experimental) Set generic font families.
type PageSetFontFamilies struct {

	// FontFamilies Specifies font families to set. If a font family is not specified, it won't be changed.
	FontFamilies *PageFontFamilies `json:"fontFamilies"`
}

// Call of the command, sessionID is optional.
func (m PageSetFontFamilies) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.setFontFamilies", m)
	return err
}

// PageSetFontSizes (experimental) Set default font sizes.
type PageSetFontSizes struct {

	// FontSizes Specifies font sizes to set. If a font size is not specified, it won't be changed.
	FontSizes *PageFontSizes `json:"fontSizes"`
}

// Call of the command, sessionID is optional.
func (m PageSetFontSizes) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.setFontSizes", m)
	return err
}

// PageSetDocumentContent Sets given markup as the document's HTML.
type PageSetDocumentContent struct {

	// FrameID Frame id to set HTML for.
	FrameID PageFrameID `json:"frameId"`

	// HTML HTML content to set.
	HTML string `json:"html"`
}

// Call of the command, sessionID is optional.
func (m PageSetDocumentContent) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.setDocumentContent", m)
	return err
}

// PageSetDownloadBehaviorBehavior enum
type PageSetDownloadBehaviorBehavior string

const (
	// PageSetDownloadBehaviorBehaviorDeny enum const
	PageSetDownloadBehaviorBehaviorDeny PageSetDownloadBehaviorBehavior = "deny"

	// PageSetDownloadBehaviorBehaviorAllow enum const
	PageSetDownloadBehaviorBehaviorAllow PageSetDownloadBehaviorBehavior = "allow"

	// PageSetDownloadBehaviorBehaviorDefault enum const
	PageSetDownloadBehaviorBehaviorDefault PageSetDownloadBehaviorBehavior = "default"
)

// PageSetDownloadBehavior (experimental) Set the behavior when downloading a file.
type PageSetDownloadBehavior struct {

	// Behavior Whether to allow all or deny all download requests, or use default Chrome behavior if
	// available (otherwise deny).
	Behavior PageSetDownloadBehaviorBehavior `json:"behavior"`

	// DownloadPath (optional) The default path to save downloaded files to. This is requred if behavior is set to 'allow'
	DownloadPath string `json:"downloadPath,omitempty"`
}

// Call of the command, sessionID is optional.
func (m PageSetDownloadBehavior) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.setDownloadBehavior", m)
	return err
}

// PageSetGeolocationOverride (deprecated) Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
// unavailable.
type PageSetGeolocationOverride struct {

	// Latitude (optional) Mock latitude
	Latitude float64 `json:"latitude,omitempty"`

	// Longitude (optional) Mock longitude
	Longitude float64 `json:"longitude,omitempty"`

	// Accuracy (optional) Mock accuracy
	Accuracy float64 `json:"accuracy,omitempty"`
}

// Call of the command, sessionID is optional.
func (m PageSetGeolocationOverride) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.setGeolocationOverride", m)
	return err
}

// PageSetLifecycleEventsEnabled (experimental) Controls whether page will emit lifecycle events.
type PageSetLifecycleEventsEnabled struct {

	// Enabled If true, starts emitting lifecycle events.
	Enabled bool `json:"enabled"`
}

// Call of the command, sessionID is optional.
func (m PageSetLifecycleEventsEnabled) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.setLifecycleEventsEnabled", m)
	return err
}

// PageSetTouchEmulationEnabledConfiguration enum
type PageSetTouchEmulationEnabledConfiguration string

const (
	// PageSetTouchEmulationEnabledConfigurationMobile enum const
	PageSetTouchEmulationEnabledConfigurationMobile PageSetTouchEmulationEnabledConfiguration = "mobile"

	// PageSetTouchEmulationEnabledConfigurationDesktop enum const
	PageSetTouchEmulationEnabledConfigurationDesktop PageSetTouchEmulationEnabledConfiguration = "desktop"
)

// PageSetTouchEmulationEnabled (deprecated) (experimental) Toggles mouse event-based touch event emulation.
type PageSetTouchEmulationEnabled struct {

	// Enabled Whether the touch event emulation should be enabled.
	Enabled bool `json:"enabled"`

	// Configuration (optional) Touch/gesture events configuration. Default: current platform.
	Configuration PageSetTouchEmulationEnabledConfiguration `json:"configuration,omitempty"`
}

// Call of the command, sessionID is optional.
func (m PageSetTouchEmulationEnabled) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.setTouchEmulationEnabled", m)
	return err
}

// PageStartScreencastFormat enum
type PageStartScreencastFormat string

const (
	// PageStartScreencastFormatJpeg enum const
	PageStartScreencastFormatJpeg PageStartScreencastFormat = "jpeg"

	// PageStartScreencastFormatPng enum const
	PageStartScreencastFormatPng PageStartScreencastFormat = "png"
)

// PageStartScreencast (experimental) Starts sending each frame using the `screencastFrame` event.
type PageStartScreencast struct {

	// Format (optional) Image compression format.
	Format PageStartScreencastFormat `json:"format,omitempty"`

	// Quality (optional) Compression quality from range [0..100].
	Quality int64 `json:"quality,omitempty"`

	// MaxWidth (optional) Maximum screenshot width.
	MaxWidth int64 `json:"maxWidth,omitempty"`

	// MaxHeight (optional) Maximum screenshot height.
	MaxHeight int64 `json:"maxHeight,omitempty"`

	// EveryNthFrame (optional) Send every n-th frame.
	EveryNthFrame int64 `json:"everyNthFrame,omitempty"`
}

// Call of the command, sessionID is optional.
func (m PageStartScreencast) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.startScreencast", m)
	return err
}

// PageStopLoading Force the page stop all navigations and pending resource fetches.
type PageStopLoading struct {
}

// Call of the command, sessionID is optional.
func (m PageStopLoading) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.stopLoading", m)
	return err
}

// PageCrash (experimental) Crashes renderer on the IO thread, generates minidumps.
type PageCrash struct {
}

// Call of the command, sessionID is optional.
func (m PageCrash) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.crash", m)
	return err
}

// PageClose (experimental) Tries to close page, running its beforeunload hooks, if any.
type PageClose struct {
}

// Call of the command, sessionID is optional.
func (m PageClose) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.close", m)
	return err
}

// PageSetWebLifecycleStateState enum
type PageSetWebLifecycleStateState string

const (
	// PageSetWebLifecycleStateStateFrozen enum const
	PageSetWebLifecycleStateStateFrozen PageSetWebLifecycleStateState = "frozen"

	// PageSetWebLifecycleStateStateActive enum const
	PageSetWebLifecycleStateStateActive PageSetWebLifecycleStateState = "active"
)

// PageSetWebLifecycleState (experimental) Tries to update the web lifecycle state of the page.
// It will transition the page to the given state according to:
// https://github.com/WICG/web-lifecycle/
type PageSetWebLifecycleState struct {

	// State Target lifecycle state
	State PageSetWebLifecycleStateState `json:"state"`
}

// Call of the command, sessionID is optional.
func (m PageSetWebLifecycleState) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.setWebLifecycleState", m)
	return err
}

// PageStopScreencast (experimental) Stops sending each frame in the `screencastFrame`.
type PageStopScreencast struct {
}

// Call of the command, sessionID is optional.
func (m PageStopScreencast) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.stopScreencast", m)
	return err
}

// PageSetProduceCompilationCache (experimental) Forces compilation cache to be generated for every subresource script.
type PageSetProduceCompilationCache struct {

	// Enabled ...
	Enabled bool `json:"enabled"`
}

// Call of the command, sessionID is optional.
func (m PageSetProduceCompilationCache) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.setProduceCompilationCache", m)
	return err
}

// PageAddCompilationCache (experimental) Seeds compilation cache for given url. Compilation cache does not survive
// cross-process navigation.
type PageAddCompilationCache struct {

	// URL ...
	URL string `json:"url"`

	// Data Base64-encoded data
	Data []byte `json:"data"`
}

// Call of the command, sessionID is optional.
func (m PageAddCompilationCache) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.addCompilationCache", m)
	return err
}

// PageClearCompilationCache (experimental) Clears seeded compilation cache.
type PageClearCompilationCache struct {
}

// Call of the command, sessionID is optional.
func (m PageClearCompilationCache) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.clearCompilationCache", m)
	return err
}

// PageGenerateTestReport (experimental) Generates a report for testing.
type PageGenerateTestReport struct {

	// Message Message to be displayed in the report.
	Message string `json:"message"`

	// Group (optional) Specifies the endpoint group to deliver the report to.
	Group string `json:"group,omitempty"`
}

// Call of the command, sessionID is optional.
func (m PageGenerateTestReport) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.generateTestReport", m)
	return err
}

// PageWaitForDebugger (experimental) Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger.
type PageWaitForDebugger struct {
}

// Call of the command, sessionID is optional.
func (m PageWaitForDebugger) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.waitForDebugger", m)
	return err
}

// PageSetInterceptFileChooserDialog (experimental) Intercept file chooser requests and transfer control to protocol clients.
// When file chooser interception is enabled, native file chooser dialog is not shown.
// Instead, a protocol event `Page.fileChooserOpened` is emitted.
type PageSetInterceptFileChooserDialog struct {

	// Enabled ...
	Enabled bool `json:"enabled"`
}

// Call of the command, sessionID is optional.
func (m PageSetInterceptFileChooserDialog) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Page.setInterceptFileChooserDialog", m)
	return err
}

// PageDomContentEventFired ...
type PageDomContentEventFired struct {

	// Timestamp ...
	Timestamp NetworkMonotonicTime `json:"timestamp"`
}

// MethodName interface
func (evt PageDomContentEventFired) MethodName() string {
	return "Page.domContentEventFired"
}

// PageFileChooserOpenedMode enum
type PageFileChooserOpenedMode string

const (
	// PageFileChooserOpenedModeSelectSingle enum const
	PageFileChooserOpenedModeSelectSingle PageFileChooserOpenedMode = "selectSingle"

	// PageFileChooserOpenedModeSelectMultiple enum const
	PageFileChooserOpenedModeSelectMultiple PageFileChooserOpenedMode = "selectMultiple"
)

// PageFileChooserOpened Emitted only when `page.interceptFileChooser` is enabled.
type PageFileChooserOpened struct {

	// FrameID (experimental) Id of the frame containing input node.
	FrameID PageFrameID `json:"frameId"`

	// BackendNodeID (experimental) Input node id.
	BackendNodeID DOMBackendNodeID `json:"backendNodeId"`

	// Mode Input mode.
	Mode PageFileChooserOpenedMode `json:"mode"`
}

// MethodName interface
func (evt PageFileChooserOpened) MethodName() string {
	return "Page.fileChooserOpened"
}

// PageFrameAttached Fired when frame has been attached to its parent.
type PageFrameAttached struct {

	// FrameID Id of the frame that has been attached.
	FrameID PageFrameID `json:"frameId"`

	// ParentFrameID Parent frame identifier.
	ParentFrameID PageFrameID `json:"parentFrameId"`

	// Stack (optional) JavaScript stack trace of when frame was attached, only set if frame initiated from script.
	Stack *RuntimeStackTrace `json:"stack,omitempty"`
}

// MethodName interface
func (evt PageFrameAttached) MethodName() string {
	return "Page.frameAttached"
}

// PageFrameClearedScheduledNavigation (deprecated) Fired when frame no longer has a scheduled navigation.
type PageFrameClearedScheduledNavigation struct {

	// FrameID Id of the frame that has cleared its scheduled navigation.
	FrameID PageFrameID `json:"frameId"`
}

// MethodName interface
func (evt PageFrameClearedScheduledNavigation) MethodName() string {
	return "Page.frameClearedScheduledNavigation"
}

// PageFrameDetached Fired when frame has been detached from its parent.
type PageFrameDetached struct {

	// FrameID Id of the frame that has been detached.
	FrameID PageFrameID `json:"frameId"`
}

// MethodName interface
func (evt PageFrameDetached) MethodName() string {
	return "Page.frameDetached"
}

// PageFrameNavigated Fired once navigation of the frame has completed. Frame is now associated with the new loader.
type PageFrameNavigated struct {

	// Frame Frame object.
	Frame *PageFrame `json:"frame"`
}

// MethodName interface
func (evt PageFrameNavigated) MethodName() string {
	return "Page.frameNavigated"
}

// PageFrameResized (experimental) ...
type PageFrameResized struct {
}

// MethodName interface
func (evt PageFrameResized) MethodName() string {
	return "Page.frameResized"
}

// PageFrameRequestedNavigation (experimental) Fired when a renderer-initiated navigation is requested.
// Navigation may still be cancelled after the event is issued.
type PageFrameRequestedNavigation struct {

	// FrameID Id of the frame that is being navigated.
	FrameID PageFrameID `json:"frameId"`

	// Reason The reason for the navigation.
	Reason PageClientNavigationReason `json:"reason"`

	// URL The destination URL for the requested navigation.
	URL string `json:"url"`
}

// MethodName interface
func (evt PageFrameRequestedNavigation) MethodName() string {
	return "Page.frameRequestedNavigation"
}

// PageFrameScheduledNavigation (deprecated) Fired when frame schedules a potential navigation.
type PageFrameScheduledNavigation struct {

	// FrameID Id of the frame that has scheduled a navigation.
	FrameID PageFrameID `json:"frameId"`

	// Delay Delay (in seconds) until the navigation is scheduled to begin. The navigation is not
	// guaranteed to start.
	Delay float64 `json:"delay"`

	// Reason The reason for the navigation.
	Reason PageClientNavigationReason `json:"reason"`

	// URL The destination URL for the scheduled navigation.
	URL string `json:"url"`
}

// MethodName interface
func (evt PageFrameScheduledNavigation) MethodName() string {
	return "Page.frameScheduledNavigation"
}

// PageFrameStartedLoading (experimental) Fired when frame has started loading.
type PageFrameStartedLoading struct {

	// FrameID Id of the frame that has started loading.
	FrameID PageFrameID `json:"frameId"`
}

// MethodName interface
func (evt PageFrameStartedLoading) MethodName() string {
	return "Page.frameStartedLoading"
}

// PageFrameStoppedLoading (experimental) Fired when frame has stopped loading.
type PageFrameStoppedLoading struct {

	// FrameID Id of the frame that has stopped loading.
	FrameID PageFrameID `json:"frameId"`
}

// MethodName interface
func (evt PageFrameStoppedLoading) MethodName() string {
	return "Page.frameStoppedLoading"
}

// PageDownloadWillBegin (experimental) Fired when page is about to start a download.
type PageDownloadWillBegin struct {

	// FrameID Id of the frame that caused download to begin.
	FrameID PageFrameID `json:"frameId"`

	// URL URL of the resource being downloaded.
	URL string `json:"url"`
}

// MethodName interface
func (evt PageDownloadWillBegin) MethodName() string {
	return "Page.downloadWillBegin"
}

// PageInterstitialHidden Fired when interstitial page was hidden
type PageInterstitialHidden struct {
}

// MethodName interface
func (evt PageInterstitialHidden) MethodName() string {
	return "Page.interstitialHidden"
}

// PageInterstitialShown Fired when interstitial page was shown
type PageInterstitialShown struct {
}

// MethodName interface
func (evt PageInterstitialShown) MethodName() string {
	return "Page.interstitialShown"
}

// PageJavascriptDialogClosed Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been
// closed.
type PageJavascriptDialogClosed struct {

	// Result Whether dialog was confirmed.
	Result bool `json:"result"`

	// UserInput User input in case of prompt.
	UserInput string `json:"userInput"`
}

// MethodName interface
func (evt PageJavascriptDialogClosed) MethodName() string {
	return "Page.javascriptDialogClosed"
}

// PageJavascriptDialogOpening Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to
// open.
type PageJavascriptDialogOpening struct {

	// URL Frame url.
	URL string `json:"url"`

	// Message Message that will be displayed by the dialog.
	Message string `json:"message"`

	// Type Dialog type.
	Type PageDialogType `json:"type"`

	// HasBrowserHandler True iff browser is capable showing or acting on the given dialog. When browser has no
	// dialog handler for given target, calling alert while Page domain is engaged will stall
	// the page execution. Execution can be resumed via calling Page.handleJavaScriptDialog.
	HasBrowserHandler bool `json:"hasBrowserHandler"`

	// DefaultPrompt (optional) Default dialog prompt.
	DefaultPrompt string `json:"defaultPrompt,omitempty"`
}

// MethodName interface
func (evt PageJavascriptDialogOpening) MethodName() string {
	return "Page.javascriptDialogOpening"
}

// PageLifecycleEvent Fired for top level page lifecycle events such as navigation, load, paint, etc.
type PageLifecycleEvent struct {

	// FrameID Id of the frame.
	FrameID PageFrameID `json:"frameId"`

	// LoaderID Loader identifier. Empty string if the request is fetched from worker.
	LoaderID NetworkLoaderID `json:"loaderId"`

	// Name ...
	Name string `json:"name"`

	// Timestamp ...
	Timestamp NetworkMonotonicTime `json:"timestamp"`
}

// MethodName interface
func (evt PageLifecycleEvent) MethodName() string {
	return "Page.lifecycleEvent"
}

// PageLoadEventFired ...
type PageLoadEventFired struct {

	// Timestamp ...
	Timestamp NetworkMonotonicTime `json:"timestamp"`
}

// MethodName interface
func (evt PageLoadEventFired) MethodName() string {
	return "Page.loadEventFired"
}

// PageNavigatedWithinDocument (experimental) Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation.
type PageNavigatedWithinDocument struct {

	// FrameID Id of the frame.
	FrameID PageFrameID `json:"frameId"`

	// URL Frame's new url.
	URL string `json:"url"`
}

// MethodName interface
func (evt PageNavigatedWithinDocument) MethodName() string {
	return "Page.navigatedWithinDocument"
}

// PageScreencastFrame (experimental) Compressed image data requested by the `startScreencast`.
type PageScreencastFrame struct {

	// Data Base64-encoded compressed image.
	Data []byte `json:"data"`

	// Metadata Screencast frame metadata.
	Metadata *PageScreencastFrameMetadata `json:"metadata"`

	// SessionID Frame number.
	SessionID int64 `json:"sessionId"`
}

// MethodName interface
func (evt PageScreencastFrame) MethodName() string {
	return "Page.screencastFrame"
}

// PageScreencastVisibilityChanged (experimental) Fired when the page with currently enabled screencast was shown or hidden `.
type PageScreencastVisibilityChanged struct {

	// Visible True if the page is visible.
	Visible bool `json:"visible"`
}

// MethodName interface
func (evt PageScreencastVisibilityChanged) MethodName() string {
	return "Page.screencastVisibilityChanged"
}

// PageWindowOpen Fired when a new window is going to be opened, via window.open(), link click, form submission,
// etc.
type PageWindowOpen struct {

	// URL The URL for the new window.
	URL string `json:"url"`

	// WindowName Window name.
	WindowName string `json:"windowName"`

	// WindowFeatures An array of enabled window features.
	WindowFeatures []string `json:"windowFeatures"`

	// UserGesture Whether or not it was triggered by user gesture.
	UserGesture bool `json:"userGesture"`
}

// MethodName interface
func (evt PageWindowOpen) MethodName() string {
	return "Page.windowOpen"
}

// PageCompilationCacheProduced (experimental) Issued for every compilation cache generated. Is only available
// if Page.setGenerateCompilationCache is enabled.
type PageCompilationCacheProduced struct {

	// URL ...
	URL string `json:"url"`

	// Data Base64-encoded data
	Data []byte `json:"data"`
}

// MethodName interface
func (evt PageCompilationCacheProduced) MethodName() string {
	return "Page.compilationCacheProduced"
}

// PerformanceMetric Run-time execution metric.
type PerformanceMetric struct {

	// Name Metric name.
	Name string `json:"name"`

	// Value Metric value.
	Value float64 `json:"value"`
}

// PerformanceDisable Disable collecting and reporting metrics.
type PerformanceDisable struct {
}

// Call of the command, sessionID is optional.
func (m PerformanceDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Performance.disable", m)
	return err
}

// PerformanceEnable Enable collecting and reporting metrics.
type PerformanceEnable struct {
}

// Call of the command, sessionID is optional.
func (m PerformanceEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Performance.enable", m)
	return err
}

// PerformanceSetTimeDomainTimeDomain enum
type PerformanceSetTimeDomainTimeDomain string

const (
	// PerformanceSetTimeDomainTimeDomainTimeTicks enum const
	PerformanceSetTimeDomainTimeDomainTimeTicks PerformanceSetTimeDomainTimeDomain = "timeTicks"

	// PerformanceSetTimeDomainTimeDomainThreadTicks enum const
	PerformanceSetTimeDomainTimeDomainThreadTicks PerformanceSetTimeDomainTimeDomain = "threadTicks"
)

// PerformanceSetTimeDomain (experimental) Sets time domain to use for collecting and reporting duration metrics.
// Note that this must be called before enabling metrics collection. Calling
// this method while metrics collection is enabled returns an error.
type PerformanceSetTimeDomain struct {

	// TimeDomain Time domain
	TimeDomain PerformanceSetTimeDomainTimeDomain `json:"timeDomain"`
}

// Call of the command, sessionID is optional.
func (m PerformanceSetTimeDomain) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Performance.setTimeDomain", m)
	return err
}

// PerformanceGetMetrics Retrieve current values of run-time metrics.
type PerformanceGetMetrics struct {
}

// Call of the command, sessionID is optional.
func (m PerformanceGetMetrics) Call(caller Caller) (*PerformanceGetMetricsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Performance.getMetrics", m)
	if err != nil {
		return nil, err
	}

	var res PerformanceGetMetricsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// PerformanceGetMetricsResult Retrieve current values of run-time metrics.
type PerformanceGetMetricsResult struct {

	// Metrics Current values for run-time metrics.
	Metrics []*PerformanceMetric `json:"metrics"`
}

// PerformanceMetrics Current values of the metrics.
type PerformanceMetrics struct {

	// Metrics Current values of the metrics.
	Metrics []*PerformanceMetric `json:"metrics"`

	// Title Timestamp title.
	Title string `json:"title"`
}

// MethodName interface
func (evt PerformanceMetrics) MethodName() string {
	return "Performance.metrics"
}

// SecurityCertificateID An internal certificate ID value.
type SecurityCertificateID int64

// SecurityMixedContentType A description of mixed content (HTTP resources on HTTPS pages), as defined by
// https://www.w3.org/TR/mixed-content/#categories
type SecurityMixedContentType string

const (
	// SecurityMixedContentTypeBlockable enum const
	SecurityMixedContentTypeBlockable SecurityMixedContentType = "blockable"

	// SecurityMixedContentTypeOptionallyBlockable enum const
	SecurityMixedContentTypeOptionallyBlockable SecurityMixedContentType = "optionally-blockable"

	// SecurityMixedContentTypeNone enum const
	SecurityMixedContentTypeNone SecurityMixedContentType = "none"
)

// SecuritySecurityState The security level of a page or resource.
type SecuritySecurityState string

const (
	// SecuritySecurityStateUnknown enum const
	SecuritySecurityStateUnknown SecuritySecurityState = "unknown"

	// SecuritySecurityStateNeutral enum const
	SecuritySecurityStateNeutral SecuritySecurityState = "neutral"

	// SecuritySecurityStateInsecure enum const
	SecuritySecurityStateInsecure SecuritySecurityState = "insecure"

	// SecuritySecurityStateSecure enum const
	SecuritySecurityStateSecure SecuritySecurityState = "secure"

	// SecuritySecurityStateInfo enum const
	SecuritySecurityStateInfo SecuritySecurityState = "info"

	// SecuritySecurityStateInsecureBroken enum const
	SecuritySecurityStateInsecureBroken SecuritySecurityState = "insecure-broken"
)

// SecurityCertificateSecurityState (experimental) Details about the security state of the page certificate.
type SecurityCertificateSecurityState struct {

	// Protocol Protocol name (e.g. "TLS 1.2" or "QUIC").
	Protocol string `json:"protocol"`

	// KeyExchange Key Exchange used by the connection, or the empty string if not applicable.
	KeyExchange string `json:"keyExchange"`

	// KeyExchangeGroup (optional) (EC)DH group used by the connection, if applicable.
	KeyExchangeGroup string `json:"keyExchangeGroup,omitempty"`

	// Cipher Cipher name.
	Cipher string `json:"cipher"`

	// Mac (optional) TLS MAC. Note that AEAD ciphers do not have separate MACs.
	Mac string `json:"mac,omitempty"`

	// Certificate Page certificate.
	Certificate []string `json:"certificate"`

	// SubjectName Certificate subject name.
	SubjectName string `json:"subjectName"`

	// Issuer Name of the issuing CA.
	Issuer string `json:"issuer"`

	// ValidFrom Certificate valid from date.
	ValidFrom NetworkTimeSinceEpoch `json:"validFrom"`

	// ValidTo Certificate valid to (expiration) date
	ValidTo NetworkTimeSinceEpoch `json:"validTo"`

	// CertificateNetworkError (optional) The highest priority network error code, if the certificate has an error.
	CertificateNetworkError string `json:"certificateNetworkError,omitempty"`

	// CertificateHasWeakSignature True if the certificate uses a weak signature aglorithm.
	CertificateHasWeakSignature bool `json:"certificateHasWeakSignature"`

	// CertificateHasSha1Signature True if the certificate has a SHA1 signature in the chain.
	CertificateHasSha1Signature bool `json:"certificateHasSha1Signature"`

	// ModernSSL True if modern SSL
	ModernSSL bool `json:"modernSSL"`

	// ObsoleteSslProtocol True if the connection is using an obsolete SSL protocol.
	ObsoleteSslProtocol bool `json:"obsoleteSslProtocol"`

	// ObsoleteSslKeyExchange True if the connection is using an obsolete SSL key exchange.
	ObsoleteSslKeyExchange bool `json:"obsoleteSslKeyExchange"`

	// ObsoleteSslCipher True if the connection is using an obsolete SSL cipher.
	ObsoleteSslCipher bool `json:"obsoleteSslCipher"`

	// ObsoleteSslSignature True if the connection is using an obsolete SSL signature.
	ObsoleteSslSignature bool `json:"obsoleteSslSignature"`
}

// SecuritySafetyTipStatus (experimental) ...
type SecuritySafetyTipStatus string

const (
	// SecuritySafetyTipStatusBadReputation enum const
	SecuritySafetyTipStatusBadReputation SecuritySafetyTipStatus = "badReputation"

	// SecuritySafetyTipStatusLookalike enum const
	SecuritySafetyTipStatusLookalike SecuritySafetyTipStatus = "lookalike"
)

// SecuritySafetyTipInfo (experimental) ...
type SecuritySafetyTipInfo struct {

	// SafetyTipStatus Describes whether the page triggers any safety tips or reputation warnings. Default is unknown.
	SafetyTipStatus SecuritySafetyTipStatus `json:"safetyTipStatus"`

	// SafeURL (optional) The URL the safety tip suggested ("Did you mean?"). Only filled in for lookalike matches.
	SafeURL string `json:"safeUrl,omitempty"`
}

// SecurityVisibleSecurityState (experimental) Security state information about the page.
type SecurityVisibleSecurityState struct {

	// SecurityState The security level of the page.
	SecurityState SecuritySecurityState `json:"securityState"`

	// CertificateSecurityState (optional) Security state details about the page certificate.
	CertificateSecurityState *SecurityCertificateSecurityState `json:"certificateSecurityState,omitempty"`

	// SafetyTipInfo (optional) The type of Safety Tip triggered on the page. Note that this field will be set even if the Safety Tip UI was not actually shown.
	SafetyTipInfo *SecuritySafetyTipInfo `json:"safetyTipInfo,omitempty"`

	// SecurityStateIssueIds Array of security state issues ids.
	SecurityStateIssueIds []string `json:"securityStateIssueIds"`
}

// SecuritySecurityStateExplanation An explanation of an factor contributing to the security state.
type SecuritySecurityStateExplanation struct {

	// SecurityState Security state representing the severity of the factor being explained.
	SecurityState SecuritySecurityState `json:"securityState"`

	// Title Title describing the type of factor.
	Title string `json:"title"`

	// Summary Short phrase describing the type of factor.
	Summary string `json:"summary"`

	// Description Full text explanation of the factor.
	Description string `json:"description"`

	// MixedContentType The type of mixed content described by the explanation.
	MixedContentType SecurityMixedContentType `json:"mixedContentType"`

	// Certificate Page certificate.
	Certificate []string `json:"certificate"`

	// Recommendations (optional) Recommendations to fix any issues.
	Recommendations []string `json:"recommendations,omitempty"`
}

// SecurityInsecureContentStatus (deprecated) Information about insecure content on the page.
type SecurityInsecureContentStatus struct {

	// RanMixedContent Always false.
	RanMixedContent bool `json:"ranMixedContent"`

	// DisplayedMixedContent Always false.
	DisplayedMixedContent bool `json:"displayedMixedContent"`

	// ContainedMixedForm Always false.
	ContainedMixedForm bool `json:"containedMixedForm"`

	// RanContentWithCertErrors Always false.
	RanContentWithCertErrors bool `json:"ranContentWithCertErrors"`

	// DisplayedContentWithCertErrors Always false.
	DisplayedContentWithCertErrors bool `json:"displayedContentWithCertErrors"`

	// RanInsecureContentStyle Always set to unknown.
	RanInsecureContentStyle SecuritySecurityState `json:"ranInsecureContentStyle"`

	// DisplayedInsecureContentStyle Always set to unknown.
	DisplayedInsecureContentStyle SecuritySecurityState `json:"displayedInsecureContentStyle"`
}

// SecurityCertificateErrorAction The action to take when a certificate error occurs. continue will continue processing the
// request and cancel will cancel the request.
type SecurityCertificateErrorAction string

const (
	// SecurityCertificateErrorActionContinue enum const
	SecurityCertificateErrorActionContinue SecurityCertificateErrorAction = "continue"

	// SecurityCertificateErrorActionCancel enum const
	SecurityCertificateErrorActionCancel SecurityCertificateErrorAction = "cancel"
)

// SecurityDisable Disables tracking security state changes.
type SecurityDisable struct {
}

// Call of the command, sessionID is optional.
func (m SecurityDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Security.disable", m)
	return err
}

// SecurityEnable Enables tracking security state changes.
type SecurityEnable struct {
}

// Call of the command, sessionID is optional.
func (m SecurityEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Security.enable", m)
	return err
}

// SecuritySetIgnoreCertificateErrors (experimental) Enable/disable whether all certificate errors should be ignored.
type SecuritySetIgnoreCertificateErrors struct {

	// Ignore If true, all certificate errors will be ignored.
	Ignore bool `json:"ignore"`
}

// Call of the command, sessionID is optional.
func (m SecuritySetIgnoreCertificateErrors) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Security.setIgnoreCertificateErrors", m)
	return err
}

// SecurityHandleCertificateError (deprecated) Handles a certificate error that fired a certificateError event.
type SecurityHandleCertificateError struct {

	// EventID The ID of the event.
	EventID int64 `json:"eventId"`

	// Action The action to take on the certificate error.
	Action SecurityCertificateErrorAction `json:"action"`
}

// Call of the command, sessionID is optional.
func (m SecurityHandleCertificateError) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Security.handleCertificateError", m)
	return err
}

// SecuritySetOverrideCertificateErrors (deprecated) Enable/disable overriding certificate errors. If enabled, all certificate error events need to
// be handled by the DevTools client and should be answered with `handleCertificateError` commands.
type SecuritySetOverrideCertificateErrors struct {

	// Override If true, certificate errors will be overridden.
	Override bool `json:"override"`
}

// Call of the command, sessionID is optional.
func (m SecuritySetOverrideCertificateErrors) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Security.setOverrideCertificateErrors", m)
	return err
}

// SecurityCertificateError (deprecated) There is a certificate error. If overriding certificate errors is enabled, then it should be
// handled with the `handleCertificateError` command. Note: this event does not fire if the
// certificate error has been allowed internally. Only one client per target should override
// certificate errors at the same time.
type SecurityCertificateError struct {

	// EventID The ID of the event.
	EventID int64 `json:"eventId"`

	// ErrorType The type of the error.
	ErrorType string `json:"errorType"`

	// RequestURL The url that was requested.
	RequestURL string `json:"requestURL"`
}

// MethodName interface
func (evt SecurityCertificateError) MethodName() string {
	return "Security.certificateError"
}

// SecurityVisibleSecurityStateChanged (experimental) The security state of the page changed.
type SecurityVisibleSecurityStateChanged struct {

	// VisibleSecurityState Security state information about the page.
	VisibleSecurityState *SecurityVisibleSecurityState `json:"visibleSecurityState"`
}

// MethodName interface
func (evt SecurityVisibleSecurityStateChanged) MethodName() string {
	return "Security.visibleSecurityStateChanged"
}

// SecuritySecurityStateChanged The security state of the page changed.
type SecuritySecurityStateChanged struct {

	// SecurityState Security state.
	SecurityState SecuritySecurityState `json:"securityState"`

	// SchemeIsCryptographic (deprecated) True if the page was loaded over cryptographic transport such as HTTPS.
	SchemeIsCryptographic bool `json:"schemeIsCryptographic"`

	// Explanations List of explanations for the security state. If the overall security state is `insecure` or
	// `warning`, at least one corresponding explanation should be included.
	Explanations []*SecuritySecurityStateExplanation `json:"explanations"`

	// InsecureContentStatus (deprecated) Information about insecure content on the page.
	InsecureContentStatus *SecurityInsecureContentStatus `json:"insecureContentStatus"`

	// Summary (optional) Overrides user-visible description of the state.
	Summary string `json:"summary,omitempty"`
}

// MethodName interface
func (evt SecuritySecurityStateChanged) MethodName() string {
	return "Security.securityStateChanged"
}

// ServiceWorkerRegistrationID ...
type ServiceWorkerRegistrationID string

// ServiceWorkerServiceWorkerRegistration ServiceWorker registration.
type ServiceWorkerServiceWorkerRegistration struct {

	// RegistrationID ...
	RegistrationID ServiceWorkerRegistrationID `json:"registrationId"`

	// ScopeURL ...
	ScopeURL string `json:"scopeURL"`

	// IsDeleted ...
	IsDeleted bool `json:"isDeleted"`
}

// ServiceWorkerServiceWorkerVersionRunningStatus ...
type ServiceWorkerServiceWorkerVersionRunningStatus string

const (
	// ServiceWorkerServiceWorkerVersionRunningStatusStopped enum const
	ServiceWorkerServiceWorkerVersionRunningStatusStopped ServiceWorkerServiceWorkerVersionRunningStatus = "stopped"

	// ServiceWorkerServiceWorkerVersionRunningStatusStarting enum const
	ServiceWorkerServiceWorkerVersionRunningStatusStarting ServiceWorkerServiceWorkerVersionRunningStatus = "starting"

	// ServiceWorkerServiceWorkerVersionRunningStatusRunning enum const
	ServiceWorkerServiceWorkerVersionRunningStatusRunning ServiceWorkerServiceWorkerVersionRunningStatus = "running"

	// ServiceWorkerServiceWorkerVersionRunningStatusStopping enum const
	ServiceWorkerServiceWorkerVersionRunningStatusStopping ServiceWorkerServiceWorkerVersionRunningStatus = "stopping"
)

// ServiceWorkerServiceWorkerVersionStatus ...
type ServiceWorkerServiceWorkerVersionStatus string

const (
	// ServiceWorkerServiceWorkerVersionStatusNew enum const
	ServiceWorkerServiceWorkerVersionStatusNew ServiceWorkerServiceWorkerVersionStatus = "new"

	// ServiceWorkerServiceWorkerVersionStatusInstalling enum const
	ServiceWorkerServiceWorkerVersionStatusInstalling ServiceWorkerServiceWorkerVersionStatus = "installing"

	// ServiceWorkerServiceWorkerVersionStatusInstalled enum const
	ServiceWorkerServiceWorkerVersionStatusInstalled ServiceWorkerServiceWorkerVersionStatus = "installed"

	// ServiceWorkerServiceWorkerVersionStatusActivating enum const
	ServiceWorkerServiceWorkerVersionStatusActivating ServiceWorkerServiceWorkerVersionStatus = "activating"

	// ServiceWorkerServiceWorkerVersionStatusActivated enum const
	ServiceWorkerServiceWorkerVersionStatusActivated ServiceWorkerServiceWorkerVersionStatus = "activated"

	// ServiceWorkerServiceWorkerVersionStatusRedundant enum const
	ServiceWorkerServiceWorkerVersionStatusRedundant ServiceWorkerServiceWorkerVersionStatus = "redundant"
)

// ServiceWorkerServiceWorkerVersion ServiceWorker version.
type ServiceWorkerServiceWorkerVersion struct {

	// VersionID ...
	VersionID string `json:"versionId"`

	// RegistrationID ...
	RegistrationID ServiceWorkerRegistrationID `json:"registrationId"`

	// ScriptURL ...
	ScriptURL string `json:"scriptURL"`

	// RunningStatus ...
	RunningStatus ServiceWorkerServiceWorkerVersionRunningStatus `json:"runningStatus"`

	// Status ...
	Status ServiceWorkerServiceWorkerVersionStatus `json:"status"`

	// ScriptLastModified (optional) The Last-Modified header value of the main script.
	ScriptLastModified float64 `json:"scriptLastModified,omitempty"`

	// ScriptResponseTime (optional) The time at which the response headers of the main script were received from the server.
	// For cached script it is the last time the cache entry was validated.
	ScriptResponseTime float64 `json:"scriptResponseTime,omitempty"`

	// ControlledClients (optional) ...
	ControlledClients []TargetTargetID `json:"controlledClients,omitempty"`

	// TargetID (optional) ...
	TargetID TargetTargetID `json:"targetId,omitempty"`
}

// ServiceWorkerServiceWorkerErrorMessage ServiceWorker error message.
type ServiceWorkerServiceWorkerErrorMessage struct {

	// ErrorMessage ...
	ErrorMessage string `json:"errorMessage"`

	// RegistrationID ...
	RegistrationID ServiceWorkerRegistrationID `json:"registrationId"`

	// VersionID ...
	VersionID string `json:"versionId"`

	// SourceURL ...
	SourceURL string `json:"sourceURL"`

	// LineNumber ...
	LineNumber int64 `json:"lineNumber"`

	// ColumnNumber ...
	ColumnNumber int64 `json:"columnNumber"`
}

// ServiceWorkerDeliverPushMessage ...
type ServiceWorkerDeliverPushMessage struct {

	// Origin ...
	Origin string `json:"origin"`

	// RegistrationID ...
	RegistrationID ServiceWorkerRegistrationID `json:"registrationId"`

	// Data ...
	Data string `json:"data"`
}

// Call of the command, sessionID is optional.
func (m ServiceWorkerDeliverPushMessage) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "ServiceWorker.deliverPushMessage", m)
	return err
}

// ServiceWorkerDisable ...
type ServiceWorkerDisable struct {
}

// Call of the command, sessionID is optional.
func (m ServiceWorkerDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "ServiceWorker.disable", m)
	return err
}

// ServiceWorkerDispatchSyncEvent ...
type ServiceWorkerDispatchSyncEvent struct {

	// Origin ...
	Origin string `json:"origin"`

	// RegistrationID ...
	RegistrationID ServiceWorkerRegistrationID `json:"registrationId"`

	// Tag ...
	Tag string `json:"tag"`

	// LastChance ...
	LastChance bool `json:"lastChance"`
}

// Call of the command, sessionID is optional.
func (m ServiceWorkerDispatchSyncEvent) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "ServiceWorker.dispatchSyncEvent", m)
	return err
}

// ServiceWorkerDispatchPeriodicSyncEvent ...
type ServiceWorkerDispatchPeriodicSyncEvent struct {

	// Origin ...
	Origin string `json:"origin"`

	// RegistrationID ...
	RegistrationID ServiceWorkerRegistrationID `json:"registrationId"`

	// Tag ...
	Tag string `json:"tag"`
}

// Call of the command, sessionID is optional.
func (m ServiceWorkerDispatchPeriodicSyncEvent) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "ServiceWorker.dispatchPeriodicSyncEvent", m)
	return err
}

// ServiceWorkerEnable ...
type ServiceWorkerEnable struct {
}

// Call of the command, sessionID is optional.
func (m ServiceWorkerEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "ServiceWorker.enable", m)
	return err
}

// ServiceWorkerInspectWorker ...
type ServiceWorkerInspectWorker struct {

	// VersionID ...
	VersionID string `json:"versionId"`
}

// Call of the command, sessionID is optional.
func (m ServiceWorkerInspectWorker) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "ServiceWorker.inspectWorker", m)
	return err
}

// ServiceWorkerSetForceUpdateOnPageLoad ...
type ServiceWorkerSetForceUpdateOnPageLoad struct {

	// ForceUpdateOnPageLoad ...
	ForceUpdateOnPageLoad bool `json:"forceUpdateOnPageLoad"`
}

// Call of the command, sessionID is optional.
func (m ServiceWorkerSetForceUpdateOnPageLoad) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "ServiceWorker.setForceUpdateOnPageLoad", m)
	return err
}

// ServiceWorkerSkipWaiting ...
type ServiceWorkerSkipWaiting struct {

	// ScopeURL ...
	ScopeURL string `json:"scopeURL"`
}

// Call of the command, sessionID is optional.
func (m ServiceWorkerSkipWaiting) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "ServiceWorker.skipWaiting", m)
	return err
}

// ServiceWorkerStartWorker ...
type ServiceWorkerStartWorker struct {

	// ScopeURL ...
	ScopeURL string `json:"scopeURL"`
}

// Call of the command, sessionID is optional.
func (m ServiceWorkerStartWorker) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "ServiceWorker.startWorker", m)
	return err
}

// ServiceWorkerStopAllWorkers ...
type ServiceWorkerStopAllWorkers struct {
}

// Call of the command, sessionID is optional.
func (m ServiceWorkerStopAllWorkers) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "ServiceWorker.stopAllWorkers", m)
	return err
}

// ServiceWorkerStopWorker ...
type ServiceWorkerStopWorker struct {

	// VersionID ...
	VersionID string `json:"versionId"`
}

// Call of the command, sessionID is optional.
func (m ServiceWorkerStopWorker) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "ServiceWorker.stopWorker", m)
	return err
}

// ServiceWorkerUnregister ...
type ServiceWorkerUnregister struct {

	// ScopeURL ...
	ScopeURL string `json:"scopeURL"`
}

// Call of the command, sessionID is optional.
func (m ServiceWorkerUnregister) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "ServiceWorker.unregister", m)
	return err
}

// ServiceWorkerUpdateRegistration ...
type ServiceWorkerUpdateRegistration struct {

	// ScopeURL ...
	ScopeURL string `json:"scopeURL"`
}

// Call of the command, sessionID is optional.
func (m ServiceWorkerUpdateRegistration) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "ServiceWorker.updateRegistration", m)
	return err
}

// ServiceWorkerWorkerErrorReported ...
type ServiceWorkerWorkerErrorReported struct {

	// ErrorMessage ...
	ErrorMessage *ServiceWorkerServiceWorkerErrorMessage `json:"errorMessage"`
}

// MethodName interface
func (evt ServiceWorkerWorkerErrorReported) MethodName() string {
	return "ServiceWorker.workerErrorReported"
}

// ServiceWorkerWorkerRegistrationUpdated ...
type ServiceWorkerWorkerRegistrationUpdated struct {

	// Registrations ...
	Registrations []*ServiceWorkerServiceWorkerRegistration `json:"registrations"`
}

// MethodName interface
func (evt ServiceWorkerWorkerRegistrationUpdated) MethodName() string {
	return "ServiceWorker.workerRegistrationUpdated"
}

// ServiceWorkerWorkerVersionUpdated ...
type ServiceWorkerWorkerVersionUpdated struct {

	// Versions ...
	Versions []*ServiceWorkerServiceWorkerVersion `json:"versions"`
}

// MethodName interface
func (evt ServiceWorkerWorkerVersionUpdated) MethodName() string {
	return "ServiceWorker.workerVersionUpdated"
}

// StorageStorageType Enum of possible storage types.
type StorageStorageType string

const (
	// StorageStorageTypeAppcache enum const
	StorageStorageTypeAppcache StorageStorageType = "appcache"

	// StorageStorageTypeCookies enum const
	StorageStorageTypeCookies StorageStorageType = "cookies"

	// StorageStorageTypeFileSystems enum const
	StorageStorageTypeFileSystems StorageStorageType = "file_systems"

	// StorageStorageTypeIndexeddb enum const
	StorageStorageTypeIndexeddb StorageStorageType = "indexeddb"

	// StorageStorageTypeLocalStorage enum const
	StorageStorageTypeLocalStorage StorageStorageType = "local_storage"

	// StorageStorageTypeShaderCache enum const
	StorageStorageTypeShaderCache StorageStorageType = "shader_cache"

	// StorageStorageTypeWebsql enum const
	StorageStorageTypeWebsql StorageStorageType = "websql"

	// StorageStorageTypeServiceWorkers enum const
	StorageStorageTypeServiceWorkers StorageStorageType = "service_workers"

	// StorageStorageTypeCacheStorage enum const
	StorageStorageTypeCacheStorage StorageStorageType = "cache_storage"

	// StorageStorageTypeAll enum const
	StorageStorageTypeAll StorageStorageType = "all"

	// StorageStorageTypeOther enum const
	StorageStorageTypeOther StorageStorageType = "other"
)

// StorageUsageForType Usage for a storage type.
type StorageUsageForType struct {

	// StorageType Name of storage type.
	StorageType StorageStorageType `json:"storageType"`

	// Usage Storage usage (bytes).
	Usage float64 `json:"usage"`
}

// StorageClearDataForOrigin Clears storage for origin.
type StorageClearDataForOrigin struct {

	// Origin Security origin.
	Origin string `json:"origin"`

	// StorageTypes Comma separated list of StorageType to clear.
	StorageTypes string `json:"storageTypes"`
}

// Call of the command, sessionID is optional.
func (m StorageClearDataForOrigin) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Storage.clearDataForOrigin", m)
	return err
}

// StorageGetCookies Returns all browser cookies.
type StorageGetCookies struct {

	// BrowserContextID (optional) Browser context to use when called on the browser endpoint.
	BrowserContextID BrowserBrowserContextID `json:"browserContextId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m StorageGetCookies) Call(caller Caller) (*StorageGetCookiesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Storage.getCookies", m)
	if err != nil {
		return nil, err
	}

	var res StorageGetCookiesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// StorageGetCookiesResult Returns all browser cookies.
type StorageGetCookiesResult struct {

	// Cookies Array of cookie objects.
	Cookies []*NetworkCookie `json:"cookies"`
}

// StorageSetCookies Sets given cookies.
type StorageSetCookies struct {

	// Cookies Cookies to be set.
	Cookies []*NetworkCookieParam `json:"cookies"`

	// BrowserContextID (optional) Browser context to use when called on the browser endpoint.
	BrowserContextID BrowserBrowserContextID `json:"browserContextId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m StorageSetCookies) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Storage.setCookies", m)
	return err
}

// StorageClearCookies Clears cookies.
type StorageClearCookies struct {

	// BrowserContextID (optional) Browser context to use when called on the browser endpoint.
	BrowserContextID BrowserBrowserContextID `json:"browserContextId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m StorageClearCookies) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Storage.clearCookies", m)
	return err
}

// StorageGetUsageAndQuota Returns usage and quota in bytes.
type StorageGetUsageAndQuota struct {

	// Origin Security origin.
	Origin string `json:"origin"`
}

// Call of the command, sessionID is optional.
func (m StorageGetUsageAndQuota) Call(caller Caller) (*StorageGetUsageAndQuotaResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Storage.getUsageAndQuota", m)
	if err != nil {
		return nil, err
	}

	var res StorageGetUsageAndQuotaResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// StorageGetUsageAndQuotaResult Returns usage and quota in bytes.
type StorageGetUsageAndQuotaResult struct {

	// Usage Storage usage (bytes).
	Usage float64 `json:"usage"`

	// Quota Storage quota (bytes).
	Quota float64 `json:"quota"`

	// UsageBreakdown Storage usage per type (bytes).
	UsageBreakdown []*StorageUsageForType `json:"usageBreakdown"`
}

// StorageTrackCacheStorageForOrigin Registers origin to be notified when an update occurs to its cache storage list.
type StorageTrackCacheStorageForOrigin struct {

	// Origin Security origin.
	Origin string `json:"origin"`
}

// Call of the command, sessionID is optional.
func (m StorageTrackCacheStorageForOrigin) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Storage.trackCacheStorageForOrigin", m)
	return err
}

// StorageTrackIndexedDBForOrigin Registers origin to be notified when an update occurs to its IndexedDB.
type StorageTrackIndexedDBForOrigin struct {

	// Origin Security origin.
	Origin string `json:"origin"`
}

// Call of the command, sessionID is optional.
func (m StorageTrackIndexedDBForOrigin) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Storage.trackIndexedDBForOrigin", m)
	return err
}

// StorageUntrackCacheStorageForOrigin Unregisters origin from receiving notifications for cache storage.
type StorageUntrackCacheStorageForOrigin struct {

	// Origin Security origin.
	Origin string `json:"origin"`
}

// Call of the command, sessionID is optional.
func (m StorageUntrackCacheStorageForOrigin) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Storage.untrackCacheStorageForOrigin", m)
	return err
}

// StorageUntrackIndexedDBForOrigin Unregisters origin from receiving notifications for IndexedDB.
type StorageUntrackIndexedDBForOrigin struct {

	// Origin Security origin.
	Origin string `json:"origin"`
}

// Call of the command, sessionID is optional.
func (m StorageUntrackIndexedDBForOrigin) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Storage.untrackIndexedDBForOrigin", m)
	return err
}

// StorageCacheStorageContentUpdated A cache's contents have been modified.
type StorageCacheStorageContentUpdated struct {

	// Origin Origin to update.
	Origin string `json:"origin"`

	// CacheName Name of cache in origin.
	CacheName string `json:"cacheName"`
}

// MethodName interface
func (evt StorageCacheStorageContentUpdated) MethodName() string {
	return "Storage.cacheStorageContentUpdated"
}

// StorageCacheStorageListUpdated A cache has been added/deleted.
type StorageCacheStorageListUpdated struct {

	// Origin Origin to update.
	Origin string `json:"origin"`
}

// MethodName interface
func (evt StorageCacheStorageListUpdated) MethodName() string {
	return "Storage.cacheStorageListUpdated"
}

// StorageIndexedDBContentUpdated The origin's IndexedDB object store has been modified.
type StorageIndexedDBContentUpdated struct {

	// Origin Origin to update.
	Origin string `json:"origin"`

	// DatabaseName Database to update.
	DatabaseName string `json:"databaseName"`

	// ObjectStoreName ObjectStore to update.
	ObjectStoreName string `json:"objectStoreName"`
}

// MethodName interface
func (evt StorageIndexedDBContentUpdated) MethodName() string {
	return "Storage.indexedDBContentUpdated"
}

// StorageIndexedDBListUpdated The origin's IndexedDB database list has been modified.
type StorageIndexedDBListUpdated struct {

	// Origin Origin to update.
	Origin string `json:"origin"`
}

// MethodName interface
func (evt StorageIndexedDBListUpdated) MethodName() string {
	return "Storage.indexedDBListUpdated"
}

// SystemInfoGPUDevice Describes a single graphics processor (GPU).
type SystemInfoGPUDevice struct {

	// VendorID PCI ID of the GPU vendor, if available; 0 otherwise.
	VendorID float64 `json:"vendorId"`

	// DeviceID PCI ID of the GPU device, if available; 0 otherwise.
	DeviceID float64 `json:"deviceId"`

	// SubSysID (optional) Sub sys ID of the GPU, only available on Windows.
	SubSysID float64 `json:"subSysId,omitempty"`

	// Revision (optional) Revision of the GPU, only available on Windows.
	Revision float64 `json:"revision,omitempty"`

	// VendorString String description of the GPU vendor, if the PCI ID is not available.
	VendorString string `json:"vendorString"`

	// DeviceString String description of the GPU device, if the PCI ID is not available.
	DeviceString string `json:"deviceString"`

	// DriverVendor String description of the GPU driver vendor.
	DriverVendor string `json:"driverVendor"`

	// DriverVersion String description of the GPU driver version.
	DriverVersion string `json:"driverVersion"`
}

// SystemInfoSize Describes the width and height dimensions of an entity.
type SystemInfoSize struct {

	// Width Width in pixels.
	Width int64 `json:"width"`

	// Height Height in pixels.
	Height int64 `json:"height"`
}

// SystemInfoVideoDecodeAcceleratorCapability Describes a supported video decoding profile with its associated minimum and
// maximum resolutions.
type SystemInfoVideoDecodeAcceleratorCapability struct {

	// Profile Video codec profile that is supported, e.g. VP9 Profile 2.
	Profile string `json:"profile"`

	// MaxResolution Maximum video dimensions in pixels supported for this |profile|.
	MaxResolution *SystemInfoSize `json:"maxResolution"`

	// MinResolution Minimum video dimensions in pixels supported for this |profile|.
	MinResolution *SystemInfoSize `json:"minResolution"`
}

// SystemInfoVideoEncodeAcceleratorCapability Describes a supported video encoding profile with its associated maximum
// resolution and maximum framerate.
type SystemInfoVideoEncodeAcceleratorCapability struct {

	// Profile Video codec profile that is supported, e.g H264 Main.
	Profile string `json:"profile"`

	// MaxResolution Maximum video dimensions in pixels supported for this |profile|.
	MaxResolution *SystemInfoSize `json:"maxResolution"`

	// MaxFramerateNumerator Maximum encoding framerate in frames per second supported for this
	// |profile|, as fraction's numerator and denominator, e.g. 24/1 fps,
	// 24000/1001 fps, etc.
	MaxFramerateNumerator int64 `json:"maxFramerateNumerator"`

	// MaxFramerateDenominator ...
	MaxFramerateDenominator int64 `json:"maxFramerateDenominator"`
}

// SystemInfoSubsamplingFormat YUV subsampling type of the pixels of a given image.
type SystemInfoSubsamplingFormat string

const (
	// SystemInfoSubsamplingFormatYuv420 enum const
	SystemInfoSubsamplingFormatYuv420 SystemInfoSubsamplingFormat = "yuv420"

	// SystemInfoSubsamplingFormatYuv422 enum const
	SystemInfoSubsamplingFormatYuv422 SystemInfoSubsamplingFormat = "yuv422"

	// SystemInfoSubsamplingFormatYuv444 enum const
	SystemInfoSubsamplingFormatYuv444 SystemInfoSubsamplingFormat = "yuv444"
)

// SystemInfoImageType Image format of a given image.
type SystemInfoImageType string

const (
	// SystemInfoImageTypeJpeg enum const
	SystemInfoImageTypeJpeg SystemInfoImageType = "jpeg"

	// SystemInfoImageTypeWebp enum const
	SystemInfoImageTypeWebp SystemInfoImageType = "webp"

	// SystemInfoImageTypeUnknown enum const
	SystemInfoImageTypeUnknown SystemInfoImageType = "unknown"
)

// SystemInfoImageDecodeAcceleratorCapability Describes a supported image decoding profile with its associated minimum and
// maximum resolutions and subsampling.
type SystemInfoImageDecodeAcceleratorCapability struct {

	// ImageType Image coded, e.g. Jpeg.
	ImageType SystemInfoImageType `json:"imageType"`

	// MaxDimensions Maximum supported dimensions of the image in pixels.
	MaxDimensions *SystemInfoSize `json:"maxDimensions"`

	// MinDimensions Minimum supported dimensions of the image in pixels.
	MinDimensions *SystemInfoSize `json:"minDimensions"`

	// Subsamplings Optional array of supported subsampling formats, e.g. 4:2:0, if known.
	Subsamplings []SystemInfoSubsamplingFormat `json:"subsamplings"`
}

// SystemInfoGPUInfo Provides information about the GPU(s) on the system.
type SystemInfoGPUInfo struct {

	// Devices The graphics devices on the system. Element 0 is the primary GPU.
	Devices []*SystemInfoGPUDevice `json:"devices"`

	// AuxAttributes (optional) An optional dictionary of additional GPU related attributes.
	AuxAttributes map[string]JSON `json:"auxAttributes,omitempty"`

	// FeatureStatus (optional) An optional dictionary of graphics features and their status.
	FeatureStatus map[string]JSON `json:"featureStatus,omitempty"`

	// DriverBugWorkarounds An optional array of GPU driver bug workarounds.
	DriverBugWorkarounds []string `json:"driverBugWorkarounds"`

	// VideoDecoding Supported accelerated video decoding capabilities.
	VideoDecoding []*SystemInfoVideoDecodeAcceleratorCapability `json:"videoDecoding"`

	// VideoEncoding Supported accelerated video encoding capabilities.
	VideoEncoding []*SystemInfoVideoEncodeAcceleratorCapability `json:"videoEncoding"`

	// ImageDecoding Supported accelerated image decoding capabilities.
	ImageDecoding []*SystemInfoImageDecodeAcceleratorCapability `json:"imageDecoding"`
}

// SystemInfoProcessInfo Represents process info.
type SystemInfoProcessInfo struct {

	// Type Specifies process type.
	Type string `json:"type"`

	// ID Specifies process id.
	ID int64 `json:"id"`

	// CPUTime Specifies cumulative CPU usage in seconds across all threads of the
	// process since the process start.
	CPUTime float64 `json:"cpuTime"`
}

// SystemInfoGetInfo Returns information about the system.
type SystemInfoGetInfo struct {
}

// Call of the command, sessionID is optional.
func (m SystemInfoGetInfo) Call(caller Caller) (*SystemInfoGetInfoResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "SystemInfo.getInfo", m)
	if err != nil {
		return nil, err
	}

	var res SystemInfoGetInfoResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// SystemInfoGetInfoResult Returns information about the system.
type SystemInfoGetInfoResult struct {

	// Gpu Information about the GPUs on the system.
	Gpu *SystemInfoGPUInfo `json:"gpu"`

	// ModelName A platform-dependent description of the model of the machine. On Mac OS, this is, for
	// example, 'MacBookPro'. Will be the empty string if not supported.
	ModelName string `json:"modelName"`

	// ModelVersion A platform-dependent description of the version of the machine. On Mac OS, this is, for
	// example, '10.1'. Will be the empty string if not supported.
	ModelVersion string `json:"modelVersion"`

	// CommandLine The command line string used to launch the browser. Will be the empty string if not
	// supported.
	CommandLine string `json:"commandLine"`
}

// SystemInfoGetProcessInfo Returns information about all running processes.
type SystemInfoGetProcessInfo struct {
}

// Call of the command, sessionID is optional.
func (m SystemInfoGetProcessInfo) Call(caller Caller) (*SystemInfoGetProcessInfoResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "SystemInfo.getProcessInfo", m)
	if err != nil {
		return nil, err
	}

	var res SystemInfoGetProcessInfoResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// SystemInfoGetProcessInfoResult Returns information about all running processes.
type SystemInfoGetProcessInfoResult struct {

	// ProcessInfo An array of process info blocks.
	ProcessInfo []*SystemInfoProcessInfo `json:"processInfo"`
}

// TargetTargetID ...
type TargetTargetID string

// TargetSessionID Unique identifier of attached debugging session.
type TargetSessionID string

// TargetTargetInfo ...
type TargetTargetInfo struct {

	// TargetID ...
	TargetID TargetTargetID `json:"targetId"`

	// Type ...
	Type string `json:"type"`

	// Title ...
	Title string `json:"title"`

	// URL ...
	URL string `json:"url"`

	// Attached Whether the target has an attached client.
	Attached bool `json:"attached"`

	// OpenerID (optional) Opener target Id
	OpenerID TargetTargetID `json:"openerId,omitempty"`

	// BrowserContextID (experimental) (optional) ...
	BrowserContextID BrowserBrowserContextID `json:"browserContextId,omitempty"`
}

// TargetRemoteLocation (experimental) ...
type TargetRemoteLocation struct {

	// Host ...
	Host string `json:"host"`

	// Port ...
	Port int64 `json:"port"`
}

// TargetActivateTarget Activates (focuses) the target.
type TargetActivateTarget struct {

	// TargetID ...
	TargetID TargetTargetID `json:"targetId"`
}

// Call of the command, sessionID is optional.
func (m TargetActivateTarget) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Target.activateTarget", m)
	return err
}

// TargetAttachToTarget Attaches to the target with given id.
type TargetAttachToTarget struct {

	// TargetID ...
	TargetID TargetTargetID `json:"targetId"`

	// Flatten (optional) Enables "flat" access to the session via specifying sessionId attribute in the commands.
	// We plan to make this the default, deprecate non-flattened mode,
	// and eventually retire it. See crbug.com/991325.
	Flatten bool `json:"flatten,omitempty"`
}

// Call of the command, sessionID is optional.
func (m TargetAttachToTarget) Call(caller Caller) (*TargetAttachToTargetResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Target.attachToTarget", m)
	if err != nil {
		return nil, err
	}

	var res TargetAttachToTargetResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetAttachToTargetResult Attaches to the target with given id.
type TargetAttachToTargetResult struct {

	// SessionID Id assigned to the session.
	SessionID TargetSessionID `json:"sessionId"`
}

// TargetAttachToBrowserTarget (experimental) Attaches to the browser target, only uses flat sessionId mode.
type TargetAttachToBrowserTarget struct {
}

// Call of the command, sessionID is optional.
func (m TargetAttachToBrowserTarget) Call(caller Caller) (*TargetAttachToBrowserTargetResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Target.attachToBrowserTarget", m)
	if err != nil {
		return nil, err
	}

	var res TargetAttachToBrowserTargetResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetAttachToBrowserTargetResult (experimental) Attaches to the browser target, only uses flat sessionId mode.
type TargetAttachToBrowserTargetResult struct {

	// SessionID Id assigned to the session.
	SessionID TargetSessionID `json:"sessionId"`
}

// TargetCloseTarget Closes the target. If the target is a page that gets closed too.
type TargetCloseTarget struct {

	// TargetID ...
	TargetID TargetTargetID `json:"targetId"`
}

// Call of the command, sessionID is optional.
func (m TargetCloseTarget) Call(caller Caller) (*TargetCloseTargetResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Target.closeTarget", m)
	if err != nil {
		return nil, err
	}

	var res TargetCloseTargetResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetCloseTargetResult Closes the target. If the target is a page that gets closed too.
type TargetCloseTargetResult struct {

	// Success ...
	Success bool `json:"success"`
}

// TargetExposeDevToolsProtocol (experimental) Inject object to the target's main frame that provides a communication
// channel with browser target.
//
// Injected object will be available as `window[bindingName]`.
//
// The object has the follwing API:
// - `binding.send(json)` - a method to send messages over the remote debugging protocol
// - `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses.
type TargetExposeDevToolsProtocol struct {

	// TargetID ...
	TargetID TargetTargetID `json:"targetId"`

	// BindingName (optional) Binding name, 'cdp' if not specified.
	BindingName string `json:"bindingName,omitempty"`
}

// Call of the command, sessionID is optional.
func (m TargetExposeDevToolsProtocol) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Target.exposeDevToolsProtocol", m)
	return err
}

// TargetCreateBrowserContext (experimental) Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
// one.
type TargetCreateBrowserContext struct {
}

// Call of the command, sessionID is optional.
func (m TargetCreateBrowserContext) Call(caller Caller) (*TargetCreateBrowserContextResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Target.createBrowserContext", m)
	if err != nil {
		return nil, err
	}

	var res TargetCreateBrowserContextResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetCreateBrowserContextResult (experimental) Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
// one.
type TargetCreateBrowserContextResult struct {

	// BrowserContextID The id of the context created.
	BrowserContextID BrowserBrowserContextID `json:"browserContextId"`
}

// TargetGetBrowserContexts (experimental) Returns all browser contexts created with `Target.createBrowserContext` method.
type TargetGetBrowserContexts struct {
}

// Call of the command, sessionID is optional.
func (m TargetGetBrowserContexts) Call(caller Caller) (*TargetGetBrowserContextsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Target.getBrowserContexts", m)
	if err != nil {
		return nil, err
	}

	var res TargetGetBrowserContextsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetGetBrowserContextsResult (experimental) Returns all browser contexts created with `Target.createBrowserContext` method.
type TargetGetBrowserContextsResult struct {

	// BrowserContextIds An array of browser context ids.
	BrowserContextIds []BrowserBrowserContextID `json:"browserContextIds"`
}

// TargetCreateTarget Creates a new page.
type TargetCreateTarget struct {

	// URL The initial URL the page will be navigated to.
	URL string `json:"url"`

	// Width (optional) Frame width in DIP (headless chrome only).
	Width int64 `json:"width,omitempty"`

	// Height (optional) Frame height in DIP (headless chrome only).
	Height int64 `json:"height,omitempty"`

	// BrowserContextID (optional) The browser context to create the page in.
	BrowserContextID BrowserBrowserContextID `json:"browserContextId,omitempty"`

	// EnableBeginFrameControl (experimental) (optional) Whether BeginFrames for this target will be controlled via DevTools (headless chrome only,
	// not supported on MacOS yet, false by default).
	EnableBeginFrameControl bool `json:"enableBeginFrameControl,omitempty"`

	// NewWindow (optional) Whether to create a new Window or Tab (chrome-only, false by default).
	NewWindow bool `json:"newWindow,omitempty"`

	// Background (optional) Whether to create the target in background or foreground (chrome-only,
	// false by default).
	Background bool `json:"background,omitempty"`
}

// Call of the command, sessionID is optional.
func (m TargetCreateTarget) Call(caller Caller) (*TargetCreateTargetResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Target.createTarget", m)
	if err != nil {
		return nil, err
	}

	var res TargetCreateTargetResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetCreateTargetResult Creates a new page.
type TargetCreateTargetResult struct {

	// TargetID The id of the page opened.
	TargetID TargetTargetID `json:"targetId"`
}

// TargetDetachFromTarget Detaches session with given id.
type TargetDetachFromTarget struct {

	// SessionID (optional) Session to detach.
	SessionID TargetSessionID `json:"sessionId,omitempty"`

	// TargetID (deprecated) (optional) Deprecated.
	TargetID TargetTargetID `json:"targetId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m TargetDetachFromTarget) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Target.detachFromTarget", m)
	return err
}

// TargetDisposeBrowserContext (experimental) Deletes a BrowserContext. All the belonging pages will be closed without calling their
// beforeunload hooks.
type TargetDisposeBrowserContext struct {

	// BrowserContextID ...
	BrowserContextID BrowserBrowserContextID `json:"browserContextId"`
}

// Call of the command, sessionID is optional.
func (m TargetDisposeBrowserContext) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Target.disposeBrowserContext", m)
	return err
}

// TargetGetTargetInfo (experimental) Returns information about a target.
type TargetGetTargetInfo struct {

	// TargetID (optional) ...
	TargetID TargetTargetID `json:"targetId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m TargetGetTargetInfo) Call(caller Caller) (*TargetGetTargetInfoResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Target.getTargetInfo", m)
	if err != nil {
		return nil, err
	}

	var res TargetGetTargetInfoResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetGetTargetInfoResult (experimental) Returns information about a target.
type TargetGetTargetInfoResult struct {

	// TargetInfo ...
	TargetInfo *TargetTargetInfo `json:"targetInfo"`
}

// TargetGetTargets Retrieves a list of available targets.
type TargetGetTargets struct {
}

// Call of the command, sessionID is optional.
func (m TargetGetTargets) Call(caller Caller) (*TargetGetTargetsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Target.getTargets", m)
	if err != nil {
		return nil, err
	}

	var res TargetGetTargetsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TargetGetTargetsResult Retrieves a list of available targets.
type TargetGetTargetsResult struct {

	// TargetInfos The list of targets.
	TargetInfos []*TargetTargetInfo `json:"targetInfos"`
}

// TargetSendMessageToTarget (deprecated) Sends protocol message over session with given id.
// Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
// and crbug.com/991325.
type TargetSendMessageToTarget struct {

	// Message ...
	Message string `json:"message"`

	// SessionID (optional) Identifier of the session.
	SessionID TargetSessionID `json:"sessionId,omitempty"`

	// TargetID (deprecated) (optional) Deprecated.
	TargetID TargetTargetID `json:"targetId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m TargetSendMessageToTarget) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Target.sendMessageToTarget", m)
	return err
}

// TargetSetAutoAttach (experimental) Controls whether to automatically attach to new targets which are considered to be related to
// this one. When turned on, attaches to all existing related targets as well. When turned off,
// automatically detaches from all currently attached targets.
type TargetSetAutoAttach struct {

	// AutoAttach Whether to auto-attach to related targets.
	AutoAttach bool `json:"autoAttach"`

	// WaitForDebuggerOnStart Whether to pause new targets when attaching to them. Use `Runtime.runIfWaitingForDebugger`
	// to run paused targets.
	WaitForDebuggerOnStart bool `json:"waitForDebuggerOnStart"`

	// Flatten (optional) Enables "flat" access to the session via specifying sessionId attribute in the commands.
	// We plan to make this the default, deprecate non-flattened mode,
	// and eventually retire it. See crbug.com/991325.
	Flatten bool `json:"flatten,omitempty"`

	// WindowOpen (experimental) (optional) Auto-attach to the targets created via window.open from current target.
	WindowOpen bool `json:"windowOpen,omitempty"`
}

// Call of the command, sessionID is optional.
func (m TargetSetAutoAttach) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Target.setAutoAttach", m)
	return err
}

// TargetSetDiscoverTargets Controls whether to discover available targets and notify via
// `targetCreated/targetInfoChanged/targetDestroyed` events.
type TargetSetDiscoverTargets struct {

	// Discover Whether to discover available targets.
	Discover bool `json:"discover"`
}

// Call of the command, sessionID is optional.
func (m TargetSetDiscoverTargets) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Target.setDiscoverTargets", m)
	return err
}

// TargetSetRemoteLocations (experimental) Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
// `true`.
type TargetSetRemoteLocations struct {

	// Locations List of remote locations.
	Locations []*TargetRemoteLocation `json:"locations"`
}

// Call of the command, sessionID is optional.
func (m TargetSetRemoteLocations) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Target.setRemoteLocations", m)
	return err
}

// TargetAttachedToTarget (experimental) Issued when attached to target because of auto-attach or `attachToTarget` command.
type TargetAttachedToTarget struct {

	// SessionID Identifier assigned to the session used to send/receive messages.
	SessionID TargetSessionID `json:"sessionId"`

	// TargetInfo ...
	TargetInfo *TargetTargetInfo `json:"targetInfo"`

	// WaitingForDebugger ...
	WaitingForDebugger bool `json:"waitingForDebugger"`
}

// MethodName interface
func (evt TargetAttachedToTarget) MethodName() string {
	return "Target.attachedToTarget"
}

// TargetDetachedFromTarget (experimental) Issued when detached from target for any reason (including `detachFromTarget` command). Can be
// issued multiple times per target if multiple sessions have been attached to it.
type TargetDetachedFromTarget struct {

	// SessionID Detached session identifier.
	SessionID TargetSessionID `json:"sessionId"`

	// TargetID (deprecated) (optional) Deprecated.
	TargetID TargetTargetID `json:"targetId,omitempty"`
}

// MethodName interface
func (evt TargetDetachedFromTarget) MethodName() string {
	return "Target.detachedFromTarget"
}

// TargetReceivedMessageFromTarget Notifies about a new protocol message received from the session (as reported in
// `attachedToTarget` event).
type TargetReceivedMessageFromTarget struct {

	// SessionID Identifier of a session which sends a message.
	SessionID TargetSessionID `json:"sessionId"`

	// Message ...
	Message string `json:"message"`

	// TargetID (deprecated) (optional) Deprecated.
	TargetID TargetTargetID `json:"targetId,omitempty"`
}

// MethodName interface
func (evt TargetReceivedMessageFromTarget) MethodName() string {
	return "Target.receivedMessageFromTarget"
}

// TargetTargetCreated Issued when a possible inspection target is created.
type TargetTargetCreated struct {

	// TargetInfo ...
	TargetInfo *TargetTargetInfo `json:"targetInfo"`
}

// MethodName interface
func (evt TargetTargetCreated) MethodName() string {
	return "Target.targetCreated"
}

// TargetTargetDestroyed Issued when a target is destroyed.
type TargetTargetDestroyed struct {

	// TargetID ...
	TargetID TargetTargetID `json:"targetId"`
}

// MethodName interface
func (evt TargetTargetDestroyed) MethodName() string {
	return "Target.targetDestroyed"
}

// TargetTargetCrashed Issued when a target has crashed.
type TargetTargetCrashed struct {

	// TargetID ...
	TargetID TargetTargetID `json:"targetId"`

	// Status Termination status type.
	Status string `json:"status"`

	// ErrorCode Termination error code.
	ErrorCode int64 `json:"errorCode"`
}

// MethodName interface
func (evt TargetTargetCrashed) MethodName() string {
	return "Target.targetCrashed"
}

// TargetTargetInfoChanged Issued when some information about a target has changed. This only happens between
// `targetCreated` and `targetDestroyed`.
type TargetTargetInfoChanged struct {

	// TargetInfo ...
	TargetInfo *TargetTargetInfo `json:"targetInfo"`
}

// MethodName interface
func (evt TargetTargetInfoChanged) MethodName() string {
	return "Target.targetInfoChanged"
}

// TetheringBind Request browser port binding.
type TetheringBind struct {

	// Port Port number to bind.
	Port int64 `json:"port"`
}

// Call of the command, sessionID is optional.
func (m TetheringBind) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Tethering.bind", m)
	return err
}

// TetheringUnbind Request browser port unbinding.
type TetheringUnbind struct {

	// Port Port number to unbind.
	Port int64 `json:"port"`
}

// Call of the command, sessionID is optional.
func (m TetheringUnbind) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Tethering.unbind", m)
	return err
}

// TetheringAccepted Informs that port was successfully bound and got a specified connection id.
type TetheringAccepted struct {

	// Port Port number that was successfully bound.
	Port int64 `json:"port"`

	// ConnectionID Connection id to be used.
	ConnectionID string `json:"connectionId"`
}

// MethodName interface
func (evt TetheringAccepted) MethodName() string {
	return "Tethering.accepted"
}

// TracingMemoryDumpConfig Configuration for memory dump. Used only when "memory-infra" category is enabled.
type TracingMemoryDumpConfig map[string]JSON

// TracingTraceConfigRecordMode enum
type TracingTraceConfigRecordMode string

const (
	// TracingTraceConfigRecordModeRecordUntilFull enum const
	TracingTraceConfigRecordModeRecordUntilFull TracingTraceConfigRecordMode = "recordUntilFull"

	// TracingTraceConfigRecordModeRecordContinuously enum const
	TracingTraceConfigRecordModeRecordContinuously TracingTraceConfigRecordMode = "recordContinuously"

	// TracingTraceConfigRecordModeRecordAsMuchAsPossible enum const
	TracingTraceConfigRecordModeRecordAsMuchAsPossible TracingTraceConfigRecordMode = "recordAsMuchAsPossible"

	// TracingTraceConfigRecordModeEchoToConsole enum const
	TracingTraceConfigRecordModeEchoToConsole TracingTraceConfigRecordMode = "echoToConsole"
)

// TracingTraceConfig ...
type TracingTraceConfig struct {

	// RecordMode (optional) Controls how the trace buffer stores data.
	RecordMode TracingTraceConfigRecordMode `json:"recordMode,omitempty"`

	// EnableSampling (optional) Turns on JavaScript stack sampling.
	EnableSampling bool `json:"enableSampling,omitempty"`

	// EnableSystrace (optional) Turns on system tracing.
	EnableSystrace bool `json:"enableSystrace,omitempty"`

	// EnableArgumentFilter (optional) Turns on argument filter.
	EnableArgumentFilter bool `json:"enableArgumentFilter,omitempty"`

	// IncludedCategories (optional) Included category filters.
	IncludedCategories []string `json:"includedCategories,omitempty"`

	// ExcludedCategories (optional) Excluded category filters.
	ExcludedCategories []string `json:"excludedCategories,omitempty"`

	// SyntheticDelays (optional) Configuration to synthesize the delays in tracing.
	SyntheticDelays []string `json:"syntheticDelays,omitempty"`

	// MemoryDumpConfig (optional) Configuration for memory dump triggers. Used only when "memory-infra" category is enabled.
	MemoryDumpConfig TracingMemoryDumpConfig `json:"memoryDumpConfig,omitempty"`
}

// TracingStreamFormat Data format of a trace. Can be either the legacy JSON format or the
// protocol buffer format. Note that the JSON format will be deprecated soon.
type TracingStreamFormat string

const (
	// TracingStreamFormatJSON enum const
	TracingStreamFormatJSON TracingStreamFormat = "json"

	// TracingStreamFormatProto enum const
	TracingStreamFormatProto TracingStreamFormat = "proto"
)

// TracingStreamCompression Compression type to use for traces returned via streams.
type TracingStreamCompression string

const (
	// TracingStreamCompressionNone enum const
	TracingStreamCompressionNone TracingStreamCompression = "none"

	// TracingStreamCompressionGzip enum const
	TracingStreamCompressionGzip TracingStreamCompression = "gzip"
)

// TracingEnd Stop trace events collection.
type TracingEnd struct {
}

// Call of the command, sessionID is optional.
func (m TracingEnd) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Tracing.end", m)
	return err
}

// TracingGetCategories Gets supported tracing categories.
type TracingGetCategories struct {
}

// Call of the command, sessionID is optional.
func (m TracingGetCategories) Call(caller Caller) (*TracingGetCategoriesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Tracing.getCategories", m)
	if err != nil {
		return nil, err
	}

	var res TracingGetCategoriesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TracingGetCategoriesResult Gets supported tracing categories.
type TracingGetCategoriesResult struct {

	// Categories A list of supported tracing categories.
	Categories []string `json:"categories"`
}

// TracingRecordClockSyncMarker Record a clock sync marker in the trace.
type TracingRecordClockSyncMarker struct {

	// SyncID The ID of this clock sync marker
	SyncID string `json:"syncId"`
}

// Call of the command, sessionID is optional.
func (m TracingRecordClockSyncMarker) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Tracing.recordClockSyncMarker", m)
	return err
}

// TracingRequestMemoryDump Request a global memory dump.
type TracingRequestMemoryDump struct {

	// Deterministic (optional) Enables more deterministic results by forcing garbage collection
	Deterministic bool `json:"deterministic,omitempty"`
}

// Call of the command, sessionID is optional.
func (m TracingRequestMemoryDump) Call(caller Caller) (*TracingRequestMemoryDumpResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Tracing.requestMemoryDump", m)
	if err != nil {
		return nil, err
	}

	var res TracingRequestMemoryDumpResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// TracingRequestMemoryDumpResult Request a global memory dump.
type TracingRequestMemoryDumpResult struct {

	// DumpGUID GUID of the resulting global memory dump.
	DumpGUID string `json:"dumpGuid"`

	// Success True iff the global memory dump succeeded.
	Success bool `json:"success"`
}

// TracingStartTransferMode enum
type TracingStartTransferMode string

const (
	// TracingStartTransferModeReportEvents enum const
	TracingStartTransferModeReportEvents TracingStartTransferMode = "ReportEvents"

	// TracingStartTransferModeReturnAsStream enum const
	TracingStartTransferModeReturnAsStream TracingStartTransferMode = "ReturnAsStream"
)

// TracingStart Start trace events collection.
type TracingStart struct {

	// Categories (deprecated) (optional) Category/tag filter
	Categories string `json:"categories,omitempty"`

	// Options (deprecated) (optional) Tracing options
	Options string `json:"options,omitempty"`

	// BufferUsageReportingInterval (optional) If set, the agent will issue bufferUsage events at this interval, specified in milliseconds
	BufferUsageReportingInterval float64 `json:"bufferUsageReportingInterval,omitempty"`

	// TransferMode (optional) Whether to report trace events as series of dataCollected events or to save trace to a
	// stream (defaults to `ReportEvents`).
	TransferMode TracingStartTransferMode `json:"transferMode,omitempty"`

	// StreamFormat (optional) Trace data format to use. This only applies when using `ReturnAsStream`
	// transfer mode (defaults to `json`).
	StreamFormat TracingStreamFormat `json:"streamFormat,omitempty"`

	// StreamCompression (optional) Compression format to use. This only applies when using `ReturnAsStream`
	// transfer mode (defaults to `none`)
	StreamCompression TracingStreamCompression `json:"streamCompression,omitempty"`

	// TraceConfig (optional) ...
	TraceConfig *TracingTraceConfig `json:"traceConfig,omitempty"`
}

// Call of the command, sessionID is optional.
func (m TracingStart) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Tracing.start", m)
	return err
}

// TracingBufferUsage ...
type TracingBufferUsage struct {

	// PercentFull (optional) A number in range [0..1] that indicates the used size of event buffer as a fraction of its
	// total size.
	PercentFull float64 `json:"percentFull,omitempty"`

	// EventCount (optional) An approximate number of events in the trace log.
	EventCount float64 `json:"eventCount,omitempty"`

	// Value (optional) A number in range [0..1] that indicates the used size of event buffer as a fraction of its
	// total size.
	Value float64 `json:"value,omitempty"`
}

// MethodName interface
func (evt TracingBufferUsage) MethodName() string {
	return "Tracing.bufferUsage"
}

// TracingDataCollected Contains an bucket of collected trace events. When tracing is stopped collected events will be
// send as a sequence of dataCollected events followed by tracingComplete event.
type TracingDataCollected struct {

	// Value ...
	Value []map[string]JSON `json:"value"`
}

// MethodName interface
func (evt TracingDataCollected) MethodName() string {
	return "Tracing.dataCollected"
}

// TracingTracingComplete Signals that tracing is stopped and there is no trace buffers pending flush, all data were
// delivered via dataCollected events.
type TracingTracingComplete struct {

	// DataLossOccurred Indicates whether some trace data is known to have been lost, e.g. because the trace ring
	// buffer wrapped around.
	DataLossOccurred bool `json:"dataLossOccurred"`

	// Stream (optional) A handle of the stream that holds resulting trace data.
	Stream IOStreamHandle `json:"stream,omitempty"`

	// TraceFormat (optional) Trace data format of returned stream.
	TraceFormat TracingStreamFormat `json:"traceFormat,omitempty"`

	// StreamCompression (optional) Compression format of returned stream.
	StreamCompression TracingStreamCompression `json:"streamCompression,omitempty"`
}

// MethodName interface
func (evt TracingTracingComplete) MethodName() string {
	return "Tracing.tracingComplete"
}

// FetchRequestID Unique request identifier.
type FetchRequestID string

// FetchRequestStage (experimental) Stages of the request to handle. Request will intercept before the request is
// sent. Response will intercept after the response is received (but before response
// body is received.
type FetchRequestStage string

const (
	// FetchRequestStageRequest enum const
	FetchRequestStageRequest FetchRequestStage = "Request"

	// FetchRequestStageResponse enum const
	FetchRequestStageResponse FetchRequestStage = "Response"
)

// FetchRequestPattern (experimental) ...
type FetchRequestPattern struct {

	// URLPattern (optional) Wildcards ('*' -> zero or more, '?' -> exactly one) are allowed. Escape character is
	// backslash. Omitting is equivalent to "*".
	URLPattern string `json:"urlPattern,omitempty"`

	// ResourceType (optional) If set, only requests for matching resource types will be intercepted.
	ResourceType NetworkResourceType `json:"resourceType,omitempty"`

	// RequestStage (optional) Stage at wich to begin intercepting requests. Default is Request.
	RequestStage FetchRequestStage `json:"requestStage,omitempty"`
}

// FetchHeaderEntry Response HTTP header entry
type FetchHeaderEntry struct {

	// Name ...
	Name string `json:"name"`

	// Value ...
	Value string `json:"value"`
}

// FetchAuthChallengeSource enum
type FetchAuthChallengeSource string

const (
	// FetchAuthChallengeSourceServer enum const
	FetchAuthChallengeSourceServer FetchAuthChallengeSource = "Server"

	// FetchAuthChallengeSourceProxy enum const
	FetchAuthChallengeSourceProxy FetchAuthChallengeSource = "Proxy"
)

// FetchAuthChallenge (experimental) Authorization challenge for HTTP status code 401 or 407.
type FetchAuthChallenge struct {

	// Source (optional) Source of the authentication challenge.
	Source FetchAuthChallengeSource `json:"source,omitempty"`

	// Origin Origin of the challenger.
	Origin string `json:"origin"`

	// Scheme The authentication scheme used, such as basic or digest
	Scheme string `json:"scheme"`

	// Realm The realm of the challenge. May be empty.
	Realm string `json:"realm"`
}

// FetchAuthChallengeResponseResponse enum
type FetchAuthChallengeResponseResponse string

const (
	// FetchAuthChallengeResponseResponseDefault enum const
	FetchAuthChallengeResponseResponseDefault FetchAuthChallengeResponseResponse = "Default"

	// FetchAuthChallengeResponseResponseCancelAuth enum const
	FetchAuthChallengeResponseResponseCancelAuth FetchAuthChallengeResponseResponse = "CancelAuth"

	// FetchAuthChallengeResponseResponseProvideCredentials enum const
	FetchAuthChallengeResponseResponseProvideCredentials FetchAuthChallengeResponseResponse = "ProvideCredentials"
)

// FetchAuthChallengeResponse (experimental) Response to an AuthChallenge.
type FetchAuthChallengeResponse struct {

	// Response The decision on what to do in response to the authorization challenge.  Default means
	// deferring to the default behavior of the net stack, which will likely either the Cancel
	// authentication or display a popup dialog box.
	Response FetchAuthChallengeResponseResponse `json:"response"`

	// Username (optional) The username to provide, possibly empty. Should only be set if response is
	// ProvideCredentials.
	Username string `json:"username,omitempty"`

	// Password (optional) The password to provide, possibly empty. Should only be set if response is
	// ProvideCredentials.
	Password string `json:"password,omitempty"`
}

// FetchDisable Disables the fetch domain.
type FetchDisable struct {
}

// Call of the command, sessionID is optional.
func (m FetchDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Fetch.disable", m)
	return err
}

// FetchEnable Enables issuing of requestPaused events. A request will be paused until client
// calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth.
type FetchEnable struct {

	// Patterns (optional) If specified, only requests matching any of these patterns will produce
	// fetchRequested event and will be paused until clients response. If not set,
	// all requests will be affected.
	Patterns []*FetchRequestPattern `json:"patterns,omitempty"`

	// HandleAuthRequests (optional) If true, authRequired events will be issued and requests will be paused
	// expecting a call to continueWithAuth.
	HandleAuthRequests bool `json:"handleAuthRequests,omitempty"`
}

// Call of the command, sessionID is optional.
func (m FetchEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Fetch.enable", m)
	return err
}

// FetchFailRequest Causes the request to fail with specified reason.
type FetchFailRequest struct {

	// RequestID An id the client received in requestPaused event.
	RequestID FetchRequestID `json:"requestId"`

	// ErrorReason Causes the request to fail with the given reason.
	ErrorReason NetworkErrorReason `json:"errorReason"`
}

// Call of the command, sessionID is optional.
func (m FetchFailRequest) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Fetch.failRequest", m)
	return err
}

// FetchFulfillRequest Provides response to the request.
type FetchFulfillRequest struct {

	// RequestID An id the client received in requestPaused event.
	RequestID FetchRequestID `json:"requestId"`

	// ResponseCode An HTTP response code.
	ResponseCode int64 `json:"responseCode"`

	// ResponseHeaders (optional) Response headers.
	ResponseHeaders []*FetchHeaderEntry `json:"responseHeaders,omitempty"`

	// BinaryResponseHeaders (optional) Alternative way of specifying response headers as a \0-separated
	// series of name: value pairs. Prefer the above method unless you
	// need to represent some non-UTF8 values that can't be transmitted
	// over the protocol as text.
	BinaryResponseHeaders []byte `json:"binaryResponseHeaders,omitempty"`

	// Body (optional) A response body.
	Body []byte `json:"body,omitempty"`

	// ResponsePhrase (optional) A textual representation of responseCode.
	// If absent, a standard phrase matching responseCode is used.
	ResponsePhrase string `json:"responsePhrase,omitempty"`
}

// Call of the command, sessionID is optional.
func (m FetchFulfillRequest) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Fetch.fulfillRequest", m)
	return err
}

// FetchContinueRequest Continues the request, optionally modifying some of its parameters.
type FetchContinueRequest struct {

	// RequestID An id the client received in requestPaused event.
	RequestID FetchRequestID `json:"requestId"`

	// URL (optional) If set, the request url will be modified in a way that's not observable by page.
	URL string `json:"url,omitempty"`

	// Method (optional) If set, the request method is overridden.
	Method string `json:"method,omitempty"`

	// PostData (optional) If set, overrides the post data in the request.
	PostData string `json:"postData,omitempty"`

	// Headers (optional) If set, overrides the request headrts.
	Headers []*FetchHeaderEntry `json:"headers,omitempty"`
}

// Call of the command, sessionID is optional.
func (m FetchContinueRequest) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Fetch.continueRequest", m)
	return err
}

// FetchContinueWithAuth Continues a request supplying authChallengeResponse following authRequired event.
type FetchContinueWithAuth struct {

	// RequestID An id the client received in authRequired event.
	RequestID FetchRequestID `json:"requestId"`

	// AuthChallengeResponse Response to  with an authChallenge.
	AuthChallengeResponse *FetchAuthChallengeResponse `json:"authChallengeResponse"`
}

// Call of the command, sessionID is optional.
func (m FetchContinueWithAuth) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Fetch.continueWithAuth", m)
	return err
}

// FetchGetResponseBody Causes the body of the response to be received from the server and
// returned as a single string. May only be issued for a request that
// is paused in the Response stage and is mutually exclusive with
// takeResponseBodyForInterceptionAsStream. Calling other methods that
// affect the request or disabling fetch domain before body is received
// results in an undefined behavior.
type FetchGetResponseBody struct {

	// RequestID Identifier for the intercepted request to get body for.
	RequestID FetchRequestID `json:"requestId"`
}

// Call of the command, sessionID is optional.
func (m FetchGetResponseBody) Call(caller Caller) (*FetchGetResponseBodyResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Fetch.getResponseBody", m)
	if err != nil {
		return nil, err
	}

	var res FetchGetResponseBodyResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// FetchGetResponseBodyResult Causes the body of the response to be received from the server and
// returned as a single string. May only be issued for a request that
// is paused in the Response stage and is mutually exclusive with
// takeResponseBodyForInterceptionAsStream. Calling other methods that
// affect the request or disabling fetch domain before body is received
// results in an undefined behavior.
type FetchGetResponseBodyResult struct {

	// Body Response body.
	Body string `json:"body"`

	// Base64Encoded True, if content was sent as base64.
	Base64Encoded bool `json:"base64Encoded"`
}

// FetchTakeResponseBodyAsStream Returns a handle to the stream representing the response body.
// The request must be paused in the HeadersReceived stage.
// Note that after this command the request can't be continued
// as is -- client either needs to cancel it or to provide the
// response body.
// The stream only supports sequential read, IO.read will fail if the position
// is specified.
// This method is mutually exclusive with getResponseBody.
// Calling other methods that affect the request or disabling fetch
// domain before body is received results in an undefined behavior.
type FetchTakeResponseBodyAsStream struct {

	// RequestID ...
	RequestID FetchRequestID `json:"requestId"`
}

// Call of the command, sessionID is optional.
func (m FetchTakeResponseBodyAsStream) Call(caller Caller) (*FetchTakeResponseBodyAsStreamResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Fetch.takeResponseBodyAsStream", m)
	if err != nil {
		return nil, err
	}

	var res FetchTakeResponseBodyAsStreamResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// FetchTakeResponseBodyAsStreamResult Returns a handle to the stream representing the response body.
// The request must be paused in the HeadersReceived stage.
// Note that after this command the request can't be continued
// as is -- client either needs to cancel it or to provide the
// response body.
// The stream only supports sequential read, IO.read will fail if the position
// is specified.
// This method is mutually exclusive with getResponseBody.
// Calling other methods that affect the request or disabling fetch
// domain before body is received results in an undefined behavior.
type FetchTakeResponseBodyAsStreamResult struct {

	// Stream ...
	Stream IOStreamHandle `json:"stream"`
}

// FetchRequestPaused Issued when the domain is enabled and the request URL matches the
// specified filter. The request is paused until the client responds
// with one of continueRequest, failRequest or fulfillRequest.
// The stage of the request can be determined by presence of responseErrorReason
// and responseStatusCode -- the request is at the response stage if either
// of these fields is present and in the request stage otherwise.
type FetchRequestPaused struct {

	// RequestID Each request the page makes will have a unique id.
	RequestID FetchRequestID `json:"requestId"`

	// Request The details of the request.
	Request *NetworkRequest `json:"request"`

	// FrameID The id of the frame that initiated the request.
	FrameID PageFrameID `json:"frameId"`

	// ResourceType How the requested resource will be used.
	ResourceType NetworkResourceType `json:"resourceType"`

	// ResponseErrorReason (optional) Response error if intercepted at response stage.
	ResponseErrorReason NetworkErrorReason `json:"responseErrorReason,omitempty"`

	// ResponseStatusCode (optional) Response code if intercepted at response stage.
	ResponseStatusCode int64 `json:"responseStatusCode,omitempty"`

	// ResponseHeaders (optional) Response headers if intercepted at the response stage.
	ResponseHeaders []*FetchHeaderEntry `json:"responseHeaders,omitempty"`

	// NetworkID (optional) If the intercepted request had a corresponding Network.requestWillBeSent event fired for it,
	// then this networkId will be the same as the requestId present in the requestWillBeSent event.
	NetworkID FetchRequestID `json:"networkId,omitempty"`
}

// MethodName interface
func (evt FetchRequestPaused) MethodName() string {
	return "Fetch.requestPaused"
}

// FetchAuthRequired Issued when the domain is enabled with handleAuthRequests set to true.
// The request is paused until client responds with continueWithAuth.
type FetchAuthRequired struct {

	// RequestID Each request the page makes will have a unique id.
	RequestID FetchRequestID `json:"requestId"`

	// Request The details of the request.
	Request *NetworkRequest `json:"request"`

	// FrameID The id of the frame that initiated the request.
	FrameID PageFrameID `json:"frameId"`

	// ResourceType How the requested resource will be used.
	ResourceType NetworkResourceType `json:"resourceType"`

	// AuthChallenge Details of the Authorization Challenge encountered.
	// If this is set, client should respond with continueRequest that
	// contains AuthChallengeResponse.
	AuthChallenge *FetchAuthChallenge `json:"authChallenge"`
}

// MethodName interface
func (evt FetchAuthRequired) MethodName() string {
	return "Fetch.authRequired"
}

// WebAudioGraphObjectID An unique ID for a graph object (AudioContext, AudioNode, AudioParam) in Web Audio API
type WebAudioGraphObjectID string

// WebAudioContextType Enum of BaseAudioContext types
type WebAudioContextType string

const (
	// WebAudioContextTypeRealtime enum const
	WebAudioContextTypeRealtime WebAudioContextType = "realtime"

	// WebAudioContextTypeOffline enum const
	WebAudioContextTypeOffline WebAudioContextType = "offline"
)

// WebAudioContextState Enum of AudioContextState from the spec
type WebAudioContextState string

const (
	// WebAudioContextStateSuspended enum const
	WebAudioContextStateSuspended WebAudioContextState = "suspended"

	// WebAudioContextStateRunning enum const
	WebAudioContextStateRunning WebAudioContextState = "running"

	// WebAudioContextStateClosed enum const
	WebAudioContextStateClosed WebAudioContextState = "closed"
)

// WebAudioNodeType Enum of AudioNode types
type WebAudioNodeType string

// WebAudioChannelCountMode Enum of AudioNode::ChannelCountMode from the spec
type WebAudioChannelCountMode string

const (
	// WebAudioChannelCountModeClampedMax enum const
	WebAudioChannelCountModeClampedMax WebAudioChannelCountMode = "clamped-max"

	// WebAudioChannelCountModeExplicit enum const
	WebAudioChannelCountModeExplicit WebAudioChannelCountMode = "explicit"

	// WebAudioChannelCountModeMax enum const
	WebAudioChannelCountModeMax WebAudioChannelCountMode = "max"
)

// WebAudioChannelInterpretation Enum of AudioNode::ChannelInterpretation from the spec
type WebAudioChannelInterpretation string

const (
	// WebAudioChannelInterpretationDiscrete enum const
	WebAudioChannelInterpretationDiscrete WebAudioChannelInterpretation = "discrete"

	// WebAudioChannelInterpretationSpeakers enum const
	WebAudioChannelInterpretationSpeakers WebAudioChannelInterpretation = "speakers"
)

// WebAudioParamType Enum of AudioParam types
type WebAudioParamType string

// WebAudioAutomationRate Enum of AudioParam::AutomationRate from the spec
type WebAudioAutomationRate string

const (
	// WebAudioAutomationRateARate enum const
	WebAudioAutomationRateARate WebAudioAutomationRate = "a-rate"

	// WebAudioAutomationRateKRate enum const
	WebAudioAutomationRateKRate WebAudioAutomationRate = "k-rate"
)

// WebAudioContextRealtimeData Fields in AudioContext that change in real-time.
type WebAudioContextRealtimeData struct {

	// CurrentTime The current context time in second in BaseAudioContext.
	CurrentTime float64 `json:"currentTime"`

	// RenderCapacity The time spent on rendering graph divided by render qunatum duration,
	// and multiplied by 100. 100 means the audio renderer reached the full
	// capacity and glitch may occur.
	RenderCapacity float64 `json:"renderCapacity"`

	// CallbackIntervalMean A running mean of callback interval.
	CallbackIntervalMean float64 `json:"callbackIntervalMean"`

	// CallbackIntervalVariance A running variance of callback interval.
	CallbackIntervalVariance float64 `json:"callbackIntervalVariance"`
}

// WebAudioBaseAudioContext Protocol object for BaseAudioContext
type WebAudioBaseAudioContext struct {

	// ContextID ...
	ContextID WebAudioGraphObjectID `json:"contextId"`

	// ContextType ...
	ContextType WebAudioContextType `json:"contextType"`

	// ContextState ...
	ContextState WebAudioContextState `json:"contextState"`

	// RealtimeData (optional) ...
	RealtimeData *WebAudioContextRealtimeData `json:"realtimeData,omitempty"`

	// CallbackBufferSize Platform-dependent callback buffer size.
	CallbackBufferSize float64 `json:"callbackBufferSize"`

	// MaxOutputChannelCount Number of output channels supported by audio hardware in use.
	MaxOutputChannelCount float64 `json:"maxOutputChannelCount"`

	// SampleRate Context sample rate.
	SampleRate float64 `json:"sampleRate"`
}

// WebAudioAudioListener Protocol object for AudioListner
type WebAudioAudioListener struct {

	// ListenerID ...
	ListenerID WebAudioGraphObjectID `json:"listenerId"`

	// ContextID ...
	ContextID WebAudioGraphObjectID `json:"contextId"`
}

// WebAudioAudioNode Protocol object for AudioNode
type WebAudioAudioNode struct {

	// NodeID ...
	NodeID WebAudioGraphObjectID `json:"nodeId"`

	// ContextID ...
	ContextID WebAudioGraphObjectID `json:"contextId"`

	// NodeType ...
	NodeType WebAudioNodeType `json:"nodeType"`

	// NumberOfInputs ...
	NumberOfInputs float64 `json:"numberOfInputs"`

	// NumberOfOutputs ...
	NumberOfOutputs float64 `json:"numberOfOutputs"`

	// ChannelCount ...
	ChannelCount float64 `json:"channelCount"`

	// ChannelCountMode ...
	ChannelCountMode WebAudioChannelCountMode `json:"channelCountMode"`

	// ChannelInterpretation ...
	ChannelInterpretation WebAudioChannelInterpretation `json:"channelInterpretation"`
}

// WebAudioAudioParam Protocol object for AudioParam
type WebAudioAudioParam struct {

	// ParamID ...
	ParamID WebAudioGraphObjectID `json:"paramId"`

	// NodeID ...
	NodeID WebAudioGraphObjectID `json:"nodeId"`

	// ContextID ...
	ContextID WebAudioGraphObjectID `json:"contextId"`

	// ParamType ...
	ParamType WebAudioParamType `json:"paramType"`

	// Rate ...
	Rate WebAudioAutomationRate `json:"rate"`

	// DefaultValue ...
	DefaultValue float64 `json:"defaultValue"`

	// MinValue ...
	MinValue float64 `json:"minValue"`

	// MaxValue ...
	MaxValue float64 `json:"maxValue"`
}

// WebAudioEnable Enables the WebAudio domain and starts sending context lifetime events.
type WebAudioEnable struct {
}

// Call of the command, sessionID is optional.
func (m WebAudioEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "WebAudio.enable", m)
	return err
}

// WebAudioDisable Disables the WebAudio domain.
type WebAudioDisable struct {
}

// Call of the command, sessionID is optional.
func (m WebAudioDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "WebAudio.disable", m)
	return err
}

// WebAudioGetRealtimeData Fetch the realtime data from the registered contexts.
type WebAudioGetRealtimeData struct {

	// ContextID ...
	ContextID WebAudioGraphObjectID `json:"contextId"`
}

// Call of the command, sessionID is optional.
func (m WebAudioGetRealtimeData) Call(caller Caller) (*WebAudioGetRealtimeDataResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "WebAudio.getRealtimeData", m)
	if err != nil {
		return nil, err
	}

	var res WebAudioGetRealtimeDataResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// WebAudioGetRealtimeDataResult Fetch the realtime data from the registered contexts.
type WebAudioGetRealtimeDataResult struct {

	// RealtimeData ...
	RealtimeData *WebAudioContextRealtimeData `json:"realtimeData"`
}

// WebAudioContextCreated Notifies that a new BaseAudioContext has been created.
type WebAudioContextCreated struct {

	// Context ...
	Context *WebAudioBaseAudioContext `json:"context"`
}

// MethodName interface
func (evt WebAudioContextCreated) MethodName() string {
	return "WebAudio.contextCreated"
}

// WebAudioContextWillBeDestroyed Notifies that an existing BaseAudioContext will be destroyed.
type WebAudioContextWillBeDestroyed struct {

	// ContextID ...
	ContextID WebAudioGraphObjectID `json:"contextId"`
}

// MethodName interface
func (evt WebAudioContextWillBeDestroyed) MethodName() string {
	return "WebAudio.contextWillBeDestroyed"
}

// WebAudioContextChanged Notifies that existing BaseAudioContext has changed some properties (id stays the same)..
type WebAudioContextChanged struct {

	// Context ...
	Context *WebAudioBaseAudioContext `json:"context"`
}

// MethodName interface
func (evt WebAudioContextChanged) MethodName() string {
	return "WebAudio.contextChanged"
}

// WebAudioAudioListenerCreated Notifies that the construction of an AudioListener has finished.
type WebAudioAudioListenerCreated struct {

	// Listener ...
	Listener *WebAudioAudioListener `json:"listener"`
}

// MethodName interface
func (evt WebAudioAudioListenerCreated) MethodName() string {
	return "WebAudio.audioListenerCreated"
}

// WebAudioAudioListenerWillBeDestroyed Notifies that a new AudioListener has been created.
type WebAudioAudioListenerWillBeDestroyed struct {

	// ContextID ...
	ContextID WebAudioGraphObjectID `json:"contextId"`

	// ListenerID ...
	ListenerID WebAudioGraphObjectID `json:"listenerId"`
}

// MethodName interface
func (evt WebAudioAudioListenerWillBeDestroyed) MethodName() string {
	return "WebAudio.audioListenerWillBeDestroyed"
}

// WebAudioAudioNodeCreated Notifies that a new AudioNode has been created.
type WebAudioAudioNodeCreated struct {

	// Node ...
	Node *WebAudioAudioNode `json:"node"`
}

// MethodName interface
func (evt WebAudioAudioNodeCreated) MethodName() string {
	return "WebAudio.audioNodeCreated"
}

// WebAudioAudioNodeWillBeDestroyed Notifies that an existing AudioNode has been destroyed.
type WebAudioAudioNodeWillBeDestroyed struct {

	// ContextID ...
	ContextID WebAudioGraphObjectID `json:"contextId"`

	// NodeID ...
	NodeID WebAudioGraphObjectID `json:"nodeId"`
}

// MethodName interface
func (evt WebAudioAudioNodeWillBeDestroyed) MethodName() string {
	return "WebAudio.audioNodeWillBeDestroyed"
}

// WebAudioAudioParamCreated Notifies that a new AudioParam has been created.
type WebAudioAudioParamCreated struct {

	// Param ...
	Param *WebAudioAudioParam `json:"param"`
}

// MethodName interface
func (evt WebAudioAudioParamCreated) MethodName() string {
	return "WebAudio.audioParamCreated"
}

// WebAudioAudioParamWillBeDestroyed Notifies that an existing AudioParam has been destroyed.
type WebAudioAudioParamWillBeDestroyed struct {

	// ContextID ...
	ContextID WebAudioGraphObjectID `json:"contextId"`

	// NodeID ...
	NodeID WebAudioGraphObjectID `json:"nodeId"`

	// ParamID ...
	ParamID WebAudioGraphObjectID `json:"paramId"`
}

// MethodName interface
func (evt WebAudioAudioParamWillBeDestroyed) MethodName() string {
	return "WebAudio.audioParamWillBeDestroyed"
}

// WebAudioNodesConnected Notifies that two AudioNodes are connected.
type WebAudioNodesConnected struct {

	// ContextID ...
	ContextID WebAudioGraphObjectID `json:"contextId"`

	// SourceID ...
	SourceID WebAudioGraphObjectID `json:"sourceId"`

	// DestinationID ...
	DestinationID WebAudioGraphObjectID `json:"destinationId"`

	// SourceOutputIndex (optional) ...
	SourceOutputIndex float64 `json:"sourceOutputIndex,omitempty"`

	// DestinationInputIndex (optional) ...
	DestinationInputIndex float64 `json:"destinationInputIndex,omitempty"`
}

// MethodName interface
func (evt WebAudioNodesConnected) MethodName() string {
	return "WebAudio.nodesConnected"
}

// WebAudioNodesDisconnected Notifies that AudioNodes are disconnected. The destination can be null, and it means all the outgoing connections from the source are disconnected.
type WebAudioNodesDisconnected struct {

	// ContextID ...
	ContextID WebAudioGraphObjectID `json:"contextId"`

	// SourceID ...
	SourceID WebAudioGraphObjectID `json:"sourceId"`

	// DestinationID ...
	DestinationID WebAudioGraphObjectID `json:"destinationId"`

	// SourceOutputIndex (optional) ...
	SourceOutputIndex float64 `json:"sourceOutputIndex,omitempty"`

	// DestinationInputIndex (optional) ...
	DestinationInputIndex float64 `json:"destinationInputIndex,omitempty"`
}

// MethodName interface
func (evt WebAudioNodesDisconnected) MethodName() string {
	return "WebAudio.nodesDisconnected"
}

// WebAudioNodeParamConnected Notifies that an AudioNode is connected to an AudioParam.
type WebAudioNodeParamConnected struct {

	// ContextID ...
	ContextID WebAudioGraphObjectID `json:"contextId"`

	// SourceID ...
	SourceID WebAudioGraphObjectID `json:"sourceId"`

	// DestinationID ...
	DestinationID WebAudioGraphObjectID `json:"destinationId"`

	// SourceOutputIndex (optional) ...
	SourceOutputIndex float64 `json:"sourceOutputIndex,omitempty"`
}

// MethodName interface
func (evt WebAudioNodeParamConnected) MethodName() string {
	return "WebAudio.nodeParamConnected"
}

// WebAudioNodeParamDisconnected Notifies that an AudioNode is disconnected to an AudioParam.
type WebAudioNodeParamDisconnected struct {

	// ContextID ...
	ContextID WebAudioGraphObjectID `json:"contextId"`

	// SourceID ...
	SourceID WebAudioGraphObjectID `json:"sourceId"`

	// DestinationID ...
	DestinationID WebAudioGraphObjectID `json:"destinationId"`

	// SourceOutputIndex (optional) ...
	SourceOutputIndex float64 `json:"sourceOutputIndex,omitempty"`
}

// MethodName interface
func (evt WebAudioNodeParamDisconnected) MethodName() string {
	return "WebAudio.nodeParamDisconnected"
}

// WebAuthnAuthenticatorID ...
type WebAuthnAuthenticatorID string

// WebAuthnAuthenticatorProtocol ...
type WebAuthnAuthenticatorProtocol string

const (
	// WebAuthnAuthenticatorProtocolU2f enum const
	WebAuthnAuthenticatorProtocolU2f WebAuthnAuthenticatorProtocol = "u2f"

	// WebAuthnAuthenticatorProtocolCtap2 enum const
	WebAuthnAuthenticatorProtocolCtap2 WebAuthnAuthenticatorProtocol = "ctap2"
)

// WebAuthnAuthenticatorTransport ...
type WebAuthnAuthenticatorTransport string

const (
	// WebAuthnAuthenticatorTransportUsb enum const
	WebAuthnAuthenticatorTransportUsb WebAuthnAuthenticatorTransport = "usb"

	// WebAuthnAuthenticatorTransportNfc enum const
	WebAuthnAuthenticatorTransportNfc WebAuthnAuthenticatorTransport = "nfc"

	// WebAuthnAuthenticatorTransportBle enum const
	WebAuthnAuthenticatorTransportBle WebAuthnAuthenticatorTransport = "ble"

	// WebAuthnAuthenticatorTransportCable enum const
	WebAuthnAuthenticatorTransportCable WebAuthnAuthenticatorTransport = "cable"

	// WebAuthnAuthenticatorTransportInternal enum const
	WebAuthnAuthenticatorTransportInternal WebAuthnAuthenticatorTransport = "internal"
)

// WebAuthnVirtualAuthenticatorOptions ...
type WebAuthnVirtualAuthenticatorOptions struct {

	// Protocol ...
	Protocol WebAuthnAuthenticatorProtocol `json:"protocol"`

	// Transport ...
	Transport WebAuthnAuthenticatorTransport `json:"transport"`

	// HasResidentKey (optional) Defaults to false.
	HasResidentKey bool `json:"hasResidentKey,omitempty"`

	// HasUserVerification (optional) Defaults to false.
	HasUserVerification bool `json:"hasUserVerification,omitempty"`

	// AutomaticPresenceSimulation (optional) If set to true, tests of user presence will succeed immediately.
	// Otherwise, they will not be resolved. Defaults to true.
	AutomaticPresenceSimulation bool `json:"automaticPresenceSimulation,omitempty"`

	// IsUserVerified (optional) Sets whether User Verification succeeds or fails for an authenticator.
	// Defaults to false.
	IsUserVerified bool `json:"isUserVerified,omitempty"`
}

// WebAuthnCredential ...
type WebAuthnCredential struct {

	// CredentialID ...
	CredentialID []byte `json:"credentialId"`

	// IsResidentCredential ...
	IsResidentCredential bool `json:"isResidentCredential"`

	// RpID (optional) Relying Party ID the credential is scoped to. Must be set when adding a
	// credential.
	RpID string `json:"rpId,omitempty"`

	// PrivateKey The ECDSA P-256 private key in PKCS#8 format.
	PrivateKey []byte `json:"privateKey"`

	// UserHandle (optional) An opaque byte sequence with a maximum size of 64 bytes mapping the
	// credential to a specific user.
	UserHandle []byte `json:"userHandle,omitempty"`

	// SignCount Signature counter. This is incremented by one for each successful
	// assertion.
	// See https://w3c.github.io/webauthn/#signature-counter
	SignCount int64 `json:"signCount"`
}

// WebAuthnEnable Enable the WebAuthn domain and start intercepting credential storage and
// retrieval with a virtual authenticator.
type WebAuthnEnable struct {
}

// Call of the command, sessionID is optional.
func (m WebAuthnEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "WebAuthn.enable", m)
	return err
}

// WebAuthnDisable Disable the WebAuthn domain.
type WebAuthnDisable struct {
}

// Call of the command, sessionID is optional.
func (m WebAuthnDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "WebAuthn.disable", m)
	return err
}

// WebAuthnAddVirtualAuthenticator Creates and adds a virtual authenticator.
type WebAuthnAddVirtualAuthenticator struct {

	// Options ...
	Options *WebAuthnVirtualAuthenticatorOptions `json:"options"`
}

// Call of the command, sessionID is optional.
func (m WebAuthnAddVirtualAuthenticator) Call(caller Caller) (*WebAuthnAddVirtualAuthenticatorResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "WebAuthn.addVirtualAuthenticator", m)
	if err != nil {
		return nil, err
	}

	var res WebAuthnAddVirtualAuthenticatorResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// WebAuthnAddVirtualAuthenticatorResult Creates and adds a virtual authenticator.
type WebAuthnAddVirtualAuthenticatorResult struct {

	// AuthenticatorID ...
	AuthenticatorID WebAuthnAuthenticatorID `json:"authenticatorId"`
}

// WebAuthnRemoveVirtualAuthenticator Removes the given authenticator.
type WebAuthnRemoveVirtualAuthenticator struct {

	// AuthenticatorID ...
	AuthenticatorID WebAuthnAuthenticatorID `json:"authenticatorId"`
}

// Call of the command, sessionID is optional.
func (m WebAuthnRemoveVirtualAuthenticator) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "WebAuthn.removeVirtualAuthenticator", m)
	return err
}

// WebAuthnAddCredential Adds the credential to the specified authenticator.
type WebAuthnAddCredential struct {

	// AuthenticatorID ...
	AuthenticatorID WebAuthnAuthenticatorID `json:"authenticatorId"`

	// Credential ...
	Credential *WebAuthnCredential `json:"credential"`
}

// Call of the command, sessionID is optional.
func (m WebAuthnAddCredential) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "WebAuthn.addCredential", m)
	return err
}

// WebAuthnGetCredential Returns a single credential stored in the given virtual authenticator that
// matches the credential ID.
type WebAuthnGetCredential struct {

	// AuthenticatorID ...
	AuthenticatorID WebAuthnAuthenticatorID `json:"authenticatorId"`

	// CredentialID ...
	CredentialID []byte `json:"credentialId"`
}

// Call of the command, sessionID is optional.
func (m WebAuthnGetCredential) Call(caller Caller) (*WebAuthnGetCredentialResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "WebAuthn.getCredential", m)
	if err != nil {
		return nil, err
	}

	var res WebAuthnGetCredentialResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// WebAuthnGetCredentialResult Returns a single credential stored in the given virtual authenticator that
// matches the credential ID.
type WebAuthnGetCredentialResult struct {

	// Credential ...
	Credential *WebAuthnCredential `json:"credential"`
}

// WebAuthnGetCredentials Returns all the credentials stored in the given virtual authenticator.
type WebAuthnGetCredentials struct {

	// AuthenticatorID ...
	AuthenticatorID WebAuthnAuthenticatorID `json:"authenticatorId"`
}

// Call of the command, sessionID is optional.
func (m WebAuthnGetCredentials) Call(caller Caller) (*WebAuthnGetCredentialsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "WebAuthn.getCredentials", m)
	if err != nil {
		return nil, err
	}

	var res WebAuthnGetCredentialsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// WebAuthnGetCredentialsResult Returns all the credentials stored in the given virtual authenticator.
type WebAuthnGetCredentialsResult struct {

	// Credentials ...
	Credentials []*WebAuthnCredential `json:"credentials"`
}

// WebAuthnRemoveCredential Removes a credential from the authenticator.
type WebAuthnRemoveCredential struct {

	// AuthenticatorID ...
	AuthenticatorID WebAuthnAuthenticatorID `json:"authenticatorId"`

	// CredentialID ...
	CredentialID []byte `json:"credentialId"`
}

// Call of the command, sessionID is optional.
func (m WebAuthnRemoveCredential) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "WebAuthn.removeCredential", m)
	return err
}

// WebAuthnClearCredentials Clears all the credentials from the specified device.
type WebAuthnClearCredentials struct {

	// AuthenticatorID ...
	AuthenticatorID WebAuthnAuthenticatorID `json:"authenticatorId"`
}

// Call of the command, sessionID is optional.
func (m WebAuthnClearCredentials) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "WebAuthn.clearCredentials", m)
	return err
}

// WebAuthnSetUserVerified Sets whether User Verification succeeds or fails for an authenticator.
// The default is true.
type WebAuthnSetUserVerified struct {

	// AuthenticatorID ...
	AuthenticatorID WebAuthnAuthenticatorID `json:"authenticatorId"`

	// IsUserVerified ...
	IsUserVerified bool `json:"isUserVerified"`
}

// Call of the command, sessionID is optional.
func (m WebAuthnSetUserVerified) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "WebAuthn.setUserVerified", m)
	return err
}

// MediaPlayerID Players will get an ID that is unique within the agent context.
type MediaPlayerID string

// MediaTimestamp ...
type MediaTimestamp float64

// MediaPlayerProperty Player Property type
type MediaPlayerProperty struct {

	// Name ...
	Name string `json:"name"`

	// Value (optional) ...
	Value string `json:"value,omitempty"`
}

// MediaPlayerEventType Break out events into different types
type MediaPlayerEventType string

const (
	// MediaPlayerEventTypeErrorEvent enum const
	MediaPlayerEventTypeErrorEvent MediaPlayerEventType = "errorEvent"

	// MediaPlayerEventTypeTriggeredEvent enum const
	MediaPlayerEventTypeTriggeredEvent MediaPlayerEventType = "triggeredEvent"

	// MediaPlayerEventTypeMessageEvent enum const
	MediaPlayerEventTypeMessageEvent MediaPlayerEventType = "messageEvent"
)

// MediaPlayerEvent ...
type MediaPlayerEvent struct {

	// Type ...
	Type MediaPlayerEventType `json:"type"`

	// Timestamp Events are timestamped relative to the start of the player creation
	// not relative to the start of playback.
	Timestamp MediaTimestamp `json:"timestamp"`

	// Name ...
	Name string `json:"name"`

	// Value ...
	Value string `json:"value"`
}

// MediaEnable Enables the Media domain
type MediaEnable struct {
}

// Call of the command, sessionID is optional.
func (m MediaEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Media.enable", m)
	return err
}

// MediaDisable Disables the Media domain.
type MediaDisable struct {
}

// Call of the command, sessionID is optional.
func (m MediaDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Media.disable", m)
	return err
}

// MediaPlayerPropertiesChanged This can be called multiple times, and can be used to set / override /
// remove player properties. A null propValue indicates removal.
type MediaPlayerPropertiesChanged struct {

	// PlayerID ...
	PlayerID MediaPlayerID `json:"playerId"`

	// Properties ...
	Properties []*MediaPlayerProperty `json:"properties"`
}

// MethodName interface
func (evt MediaPlayerPropertiesChanged) MethodName() string {
	return "Media.playerPropertiesChanged"
}

// MediaPlayerEventsAdded Send events as a list, allowing them to be batched on the browser for less
// congestion. If batched, events must ALWAYS be in chronological order.
type MediaPlayerEventsAdded struct {

	// PlayerID ...
	PlayerID MediaPlayerID `json:"playerId"`

	// Events ...
	Events []*MediaPlayerEvent `json:"events"`
}

// MethodName interface
func (evt MediaPlayerEventsAdded) MethodName() string {
	return "Media.playerEventsAdded"
}

// MediaPlayersCreated Called whenever a player is created, or when a new agent joins and recieves
// a list of active players. If an agent is restored, it will recieve the full
// list of player ids and all events again.
type MediaPlayersCreated struct {

	// Players ...
	Players []MediaPlayerID `json:"players"`
}

// MethodName interface
func (evt MediaPlayersCreated) MethodName() string {
	return "Media.playersCreated"
}

// ConsoleConsoleMessageSource enum
type ConsoleConsoleMessageSource string

const (
	// ConsoleConsoleMessageSourceXML enum const
	ConsoleConsoleMessageSourceXML ConsoleConsoleMessageSource = "xml"

	// ConsoleConsoleMessageSourceJavascript enum const
	ConsoleConsoleMessageSourceJavascript ConsoleConsoleMessageSource = "javascript"

	// ConsoleConsoleMessageSourceNetwork enum const
	ConsoleConsoleMessageSourceNetwork ConsoleConsoleMessageSource = "network"

	// ConsoleConsoleMessageSourceConsoleAPI enum const
	ConsoleConsoleMessageSourceConsoleAPI ConsoleConsoleMessageSource = "console-api"

	// ConsoleConsoleMessageSourceStorage enum const
	ConsoleConsoleMessageSourceStorage ConsoleConsoleMessageSource = "storage"

	// ConsoleConsoleMessageSourceAppcache enum const
	ConsoleConsoleMessageSourceAppcache ConsoleConsoleMessageSource = "appcache"

	// ConsoleConsoleMessageSourceRendering enum const
	ConsoleConsoleMessageSourceRendering ConsoleConsoleMessageSource = "rendering"

	// ConsoleConsoleMessageSourceSecurity enum const
	ConsoleConsoleMessageSourceSecurity ConsoleConsoleMessageSource = "security"

	// ConsoleConsoleMessageSourceOther enum const
	ConsoleConsoleMessageSourceOther ConsoleConsoleMessageSource = "other"

	// ConsoleConsoleMessageSourceDeprecation enum const
	ConsoleConsoleMessageSourceDeprecation ConsoleConsoleMessageSource = "deprecation"

	// ConsoleConsoleMessageSourceWorker enum const
	ConsoleConsoleMessageSourceWorker ConsoleConsoleMessageSource = "worker"
)

// ConsoleConsoleMessageLevel enum
type ConsoleConsoleMessageLevel string

const (
	// ConsoleConsoleMessageLevelLog enum const
	ConsoleConsoleMessageLevelLog ConsoleConsoleMessageLevel = "log"

	// ConsoleConsoleMessageLevelWarning enum const
	ConsoleConsoleMessageLevelWarning ConsoleConsoleMessageLevel = "warning"

	// ConsoleConsoleMessageLevelError enum const
	ConsoleConsoleMessageLevelError ConsoleConsoleMessageLevel = "error"

	// ConsoleConsoleMessageLevelDebug enum const
	ConsoleConsoleMessageLevelDebug ConsoleConsoleMessageLevel = "debug"

	// ConsoleConsoleMessageLevelInfo enum const
	ConsoleConsoleMessageLevelInfo ConsoleConsoleMessageLevel = "info"
)

// ConsoleConsoleMessage Console message.
type ConsoleConsoleMessage struct {

	// Source Message source.
	Source ConsoleConsoleMessageSource `json:"source"`

	// Level Message severity.
	Level ConsoleConsoleMessageLevel `json:"level"`

	// Text Message text.
	Text string `json:"text"`

	// URL (optional) URL of the message origin.
	URL string `json:"url,omitempty"`

	// Line (optional) Line number in the resource that generated this message (1-based).
	Line int64 `json:"line,omitempty"`

	// Column (optional) Column number in the resource that generated this message (1-based).
	Column int64 `json:"column,omitempty"`
}

// ConsoleClearMessages Does nothing.
type ConsoleClearMessages struct {
}

// Call of the command, sessionID is optional.
func (m ConsoleClearMessages) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Console.clearMessages", m)
	return err
}

// ConsoleDisable Disables console domain, prevents further console messages from being reported to the client.
type ConsoleDisable struct {
}

// Call of the command, sessionID is optional.
func (m ConsoleDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Console.disable", m)
	return err
}

// ConsoleEnable Enables console domain, sends the messages collected so far to the client by means of the
// `messageAdded` notification.
type ConsoleEnable struct {
}

// Call of the command, sessionID is optional.
func (m ConsoleEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Console.enable", m)
	return err
}

// ConsoleMessageAdded Issued when new console message is added.
type ConsoleMessageAdded struct {

	// Message Console message that has been added.
	Message *ConsoleConsoleMessage `json:"message"`
}

// MethodName interface
func (evt ConsoleMessageAdded) MethodName() string {
	return "Console.messageAdded"
}

// DebuggerBreakpointID Breakpoint identifier.
type DebuggerBreakpointID string

// DebuggerCallFrameID Call frame identifier.
type DebuggerCallFrameID string

// DebuggerLocation Location in the source code.
type DebuggerLocation struct {

	// ScriptID Script identifier as reported in the `Debugger.scriptParsed`.
	ScriptID RuntimeScriptID `json:"scriptId"`

	// LineNumber Line number in the script (0-based).
	LineNumber int64 `json:"lineNumber"`

	// ColumnNumber (optional) Column number in the script (0-based).
	ColumnNumber int64 `json:"columnNumber,omitempty"`
}

// DebuggerScriptPosition (experimental) Location in the source code.
type DebuggerScriptPosition struct {

	// LineNumber ...
	LineNumber int64 `json:"lineNumber"`

	// ColumnNumber ...
	ColumnNumber int64 `json:"columnNumber"`
}

// DebuggerCallFrame JavaScript call frame. Array of call frames form the call stack.
type DebuggerCallFrame struct {

	// CallFrameID Call frame identifier. This identifier is only valid while the virtual machine is paused.
	CallFrameID DebuggerCallFrameID `json:"callFrameId"`

	// FunctionName Name of the JavaScript function called on this call frame.
	FunctionName string `json:"functionName"`

	// FunctionLocation (optional) Location in the source code.
	FunctionLocation *DebuggerLocation `json:"functionLocation,omitempty"`

	// Location Location in the source code.
	Location *DebuggerLocation `json:"location"`

	// URL JavaScript script name or url.
	URL string `json:"url"`

	// ScopeChain Scope chain for this call frame.
	ScopeChain []*DebuggerScope `json:"scopeChain"`

	// This `this` object for this call frame.
	This *RuntimeRemoteObject `json:"this"`

	// ReturnValue (optional) The value being returned, if the function is at return point.
	ReturnValue *RuntimeRemoteObject `json:"returnValue,omitempty"`
}

// DebuggerScopeType enum
type DebuggerScopeType string

const (
	// DebuggerScopeTypeGlobal enum const
	DebuggerScopeTypeGlobal DebuggerScopeType = "global"

	// DebuggerScopeTypeLocal enum const
	DebuggerScopeTypeLocal DebuggerScopeType = "local"

	// DebuggerScopeTypeWith enum const
	DebuggerScopeTypeWith DebuggerScopeType = "with"

	// DebuggerScopeTypeClosure enum const
	DebuggerScopeTypeClosure DebuggerScopeType = "closure"

	// DebuggerScopeTypeCatch enum const
	DebuggerScopeTypeCatch DebuggerScopeType = "catch"

	// DebuggerScopeTypeBlock enum const
	DebuggerScopeTypeBlock DebuggerScopeType = "block"

	// DebuggerScopeTypeScript enum const
	DebuggerScopeTypeScript DebuggerScopeType = "script"

	// DebuggerScopeTypeEval enum const
	DebuggerScopeTypeEval DebuggerScopeType = "eval"

	// DebuggerScopeTypeModule enum const
	DebuggerScopeTypeModule DebuggerScopeType = "module"
)

// DebuggerScope Scope description.
type DebuggerScope struct {

	// Type Scope type.
	Type DebuggerScopeType `json:"type"`

	// Object Object representing the scope. For `global` and `with` scopes it represents the actual
	// object; for the rest of the scopes, it is artificial transient object enumerating scope
	// variables as its properties.
	Object *RuntimeRemoteObject `json:"object"`

	// Name (optional) ...
	Name string `json:"name,omitempty"`

	// StartLocation (optional) Location in the source code where scope starts
	StartLocation *DebuggerLocation `json:"startLocation,omitempty"`

	// EndLocation (optional) Location in the source code where scope ends
	EndLocation *DebuggerLocation `json:"endLocation,omitempty"`
}

// DebuggerSearchMatch Search match for resource.
type DebuggerSearchMatch struct {

	// LineNumber Line number in resource content.
	LineNumber float64 `json:"lineNumber"`

	// LineContent Line with match content.
	LineContent string `json:"lineContent"`
}

// DebuggerBreakLocationType enum
type DebuggerBreakLocationType string

const (
	// DebuggerBreakLocationTypeDebuggerStatement enum const
	DebuggerBreakLocationTypeDebuggerStatement DebuggerBreakLocationType = "debuggerStatement"

	// DebuggerBreakLocationTypeCall enum const
	DebuggerBreakLocationTypeCall DebuggerBreakLocationType = "call"

	// DebuggerBreakLocationTypeReturn enum const
	DebuggerBreakLocationTypeReturn DebuggerBreakLocationType = "return"
)

// DebuggerBreakLocation ...
type DebuggerBreakLocation struct {

	// ScriptID Script identifier as reported in the `Debugger.scriptParsed`.
	ScriptID RuntimeScriptID `json:"scriptId"`

	// LineNumber Line number in the script (0-based).
	LineNumber int64 `json:"lineNumber"`

	// ColumnNumber (optional) Column number in the script (0-based).
	ColumnNumber int64 `json:"columnNumber,omitempty"`

	// Type (optional) ...
	Type DebuggerBreakLocationType `json:"type,omitempty"`
}

// DebuggerContinueToLocationTargetCallFrames enum
type DebuggerContinueToLocationTargetCallFrames string

const (
	// DebuggerContinueToLocationTargetCallFramesAny enum const
	DebuggerContinueToLocationTargetCallFramesAny DebuggerContinueToLocationTargetCallFrames = "any"

	// DebuggerContinueToLocationTargetCallFramesCurrent enum const
	DebuggerContinueToLocationTargetCallFramesCurrent DebuggerContinueToLocationTargetCallFrames = "current"
)

// DebuggerContinueToLocation Continues execution until specific location is reached.
type DebuggerContinueToLocation struct {

	// Location Location to continue to.
	Location *DebuggerLocation `json:"location"`

	// TargetCallFrames (optional) ...
	TargetCallFrames DebuggerContinueToLocationTargetCallFrames `json:"targetCallFrames,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DebuggerContinueToLocation) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.continueToLocation", m)
	return err
}

// DebuggerDisable Disables debugger for given page.
type DebuggerDisable struct {
}

// Call of the command, sessionID is optional.
func (m DebuggerDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.disable", m)
	return err
}

// DebuggerEnable Enables debugger for the given page. Clients should not assume that the debugging has been
// enabled until the result for this command is received.
type DebuggerEnable struct {

	// MaxScriptsCacheSize (experimental) (optional) The maximum size in bytes of collected scripts (not referenced by other heap objects)
	// the debugger can hold. Puts no limit if paramter is omitted.
	MaxScriptsCacheSize float64 `json:"maxScriptsCacheSize,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DebuggerEnable) Call(caller Caller) (*DebuggerEnableResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Debugger.enable", m)
	if err != nil {
		return nil, err
	}

	var res DebuggerEnableResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DebuggerEnableResult Enables debugger for the given page. Clients should not assume that the debugging has been
// enabled until the result for this command is received.
type DebuggerEnableResult struct {

	// DebuggerID (experimental) Unique identifier of the debugger.
	DebuggerID RuntimeUniqueDebuggerID `json:"debuggerId"`
}

// DebuggerEvaluateOnCallFrame Evaluates expression on a given call frame.
type DebuggerEvaluateOnCallFrame struct {

	// CallFrameID Call frame identifier to evaluate on.
	CallFrameID DebuggerCallFrameID `json:"callFrameId"`

	// Expression Expression to evaluate.
	Expression string `json:"expression"`

	// ObjectGroup (optional) String object group name to put result into (allows rapid releasing resulting object handles
	// using `releaseObjectGroup`).
	ObjectGroup string `json:"objectGroup,omitempty"`

	// IncludeCommandLineAPI (optional) Specifies whether command line API should be available to the evaluated expression, defaults
	// to false.
	IncludeCommandLineAPI bool `json:"includeCommandLineAPI,omitempty"`

	// Silent (optional) In silent mode exceptions thrown during evaluation are not reported and do not pause
	// execution. Overrides `setPauseOnException` state.
	Silent bool `json:"silent,omitempty"`

	// ReturnByValue (optional) Whether the result is expected to be a JSON object that should be sent by value.
	ReturnByValue bool `json:"returnByValue,omitempty"`

	// GeneratePreview (experimental) (optional) Whether preview should be generated for the result.
	GeneratePreview bool `json:"generatePreview,omitempty"`

	// ThrowOnSideEffect (optional) Whether to throw an exception if side effect cannot be ruled out during evaluation.
	ThrowOnSideEffect bool `json:"throwOnSideEffect,omitempty"`

	// Timeout (experimental) (optional) Terminate execution after timing out (number of milliseconds).
	Timeout RuntimeTimeDelta `json:"timeout,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DebuggerEvaluateOnCallFrame) Call(caller Caller) (*DebuggerEvaluateOnCallFrameResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Debugger.evaluateOnCallFrame", m)
	if err != nil {
		return nil, err
	}

	var res DebuggerEvaluateOnCallFrameResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DebuggerEvaluateOnCallFrameResult Evaluates expression on a given call frame.
type DebuggerEvaluateOnCallFrameResult struct {

	// Result Object wrapper for the evaluation result.
	Result *RuntimeRemoteObject `json:"result"`

	// ExceptionDetails (optional) Exception details.
	ExceptionDetails *RuntimeExceptionDetails `json:"exceptionDetails,omitempty"`
}

// DebuggerGetPossibleBreakpoints Returns possible locations for breakpoint. scriptId in start and end range locations should be
// the same.
type DebuggerGetPossibleBreakpoints struct {

	// Start Start of range to search possible breakpoint locations in.
	Start *DebuggerLocation `json:"start"`

	// End (optional) End of range to search possible breakpoint locations in (excluding). When not specified, end
	// of scripts is used as end of range.
	End *DebuggerLocation `json:"end,omitempty"`

	// RestrictToFunction (optional) Only consider locations which are in the same (non-nested) function as start.
	RestrictToFunction bool `json:"restrictToFunction,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DebuggerGetPossibleBreakpoints) Call(caller Caller) (*DebuggerGetPossibleBreakpointsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Debugger.getPossibleBreakpoints", m)
	if err != nil {
		return nil, err
	}

	var res DebuggerGetPossibleBreakpointsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DebuggerGetPossibleBreakpointsResult Returns possible locations for breakpoint. scriptId in start and end range locations should be
// the same.
type DebuggerGetPossibleBreakpointsResult struct {

	// Locations List of the possible breakpoint locations.
	Locations []*DebuggerBreakLocation `json:"locations"`
}

// DebuggerGetScriptSource Returns source for the script with given id.
type DebuggerGetScriptSource struct {

	// ScriptID Id of the script to get source for.
	ScriptID RuntimeScriptID `json:"scriptId"`
}

// Call of the command, sessionID is optional.
func (m DebuggerGetScriptSource) Call(caller Caller) (*DebuggerGetScriptSourceResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Debugger.getScriptSource", m)
	if err != nil {
		return nil, err
	}

	var res DebuggerGetScriptSourceResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DebuggerGetScriptSourceResult Returns source for the script with given id.
type DebuggerGetScriptSourceResult struct {

	// ScriptSource Script source (empty in case of Wasm bytecode).
	ScriptSource string `json:"scriptSource"`

	// Bytecode (optional) Wasm bytecode.
	Bytecode []byte `json:"bytecode,omitempty"`
}

// DebuggerGetWasmBytecode (deprecated) This command is deprecated. Use getScriptSource instead.
type DebuggerGetWasmBytecode struct {

	// ScriptID Id of the Wasm script to get source for.
	ScriptID RuntimeScriptID `json:"scriptId"`
}

// Call of the command, sessionID is optional.
func (m DebuggerGetWasmBytecode) Call(caller Caller) (*DebuggerGetWasmBytecodeResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Debugger.getWasmBytecode", m)
	if err != nil {
		return nil, err
	}

	var res DebuggerGetWasmBytecodeResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DebuggerGetWasmBytecodeResult (deprecated) This command is deprecated. Use getScriptSource instead.
type DebuggerGetWasmBytecodeResult struct {

	// Bytecode Script source.
	Bytecode []byte `json:"bytecode"`
}

// DebuggerGetStackTrace (experimental) Returns stack trace with given `stackTraceId`.
type DebuggerGetStackTrace struct {

	// StackTraceID ...
	StackTraceID *RuntimeStackTraceID `json:"stackTraceId"`
}

// Call of the command, sessionID is optional.
func (m DebuggerGetStackTrace) Call(caller Caller) (*DebuggerGetStackTraceResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Debugger.getStackTrace", m)
	if err != nil {
		return nil, err
	}

	var res DebuggerGetStackTraceResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DebuggerGetStackTraceResult (experimental) Returns stack trace with given `stackTraceId`.
type DebuggerGetStackTraceResult struct {

	// StackTrace ...
	StackTrace *RuntimeStackTrace `json:"stackTrace"`
}

// DebuggerPause Stops on the next JavaScript statement.
type DebuggerPause struct {
}

// Call of the command, sessionID is optional.
func (m DebuggerPause) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.pause", m)
	return err
}

// DebuggerPauseOnAsyncCall (deprecated) (experimental) ...
type DebuggerPauseOnAsyncCall struct {

	// ParentStackTraceID Debugger will pause when async call with given stack trace is started.
	ParentStackTraceID *RuntimeStackTraceID `json:"parentStackTraceId"`
}

// Call of the command, sessionID is optional.
func (m DebuggerPauseOnAsyncCall) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.pauseOnAsyncCall", m)
	return err
}

// DebuggerRemoveBreakpoint Removes JavaScript breakpoint.
type DebuggerRemoveBreakpoint struct {

	// BreakpointID ...
	BreakpointID DebuggerBreakpointID `json:"breakpointId"`
}

// Call of the command, sessionID is optional.
func (m DebuggerRemoveBreakpoint) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.removeBreakpoint", m)
	return err
}

// DebuggerRestartFrame Restarts particular call frame from the beginning.
type DebuggerRestartFrame struct {

	// CallFrameID Call frame identifier to evaluate on.
	CallFrameID DebuggerCallFrameID `json:"callFrameId"`
}

// Call of the command, sessionID is optional.
func (m DebuggerRestartFrame) Call(caller Caller) (*DebuggerRestartFrameResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Debugger.restartFrame", m)
	if err != nil {
		return nil, err
	}

	var res DebuggerRestartFrameResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DebuggerRestartFrameResult Restarts particular call frame from the beginning.
type DebuggerRestartFrameResult struct {

	// CallFrames New stack trace.
	CallFrames []*DebuggerCallFrame `json:"callFrames"`

	// AsyncStackTrace (optional) Async stack trace, if any.
	AsyncStackTrace *RuntimeStackTrace `json:"asyncStackTrace,omitempty"`

	// AsyncStackTraceID (experimental) (optional) Async stack trace, if any.
	AsyncStackTraceID *RuntimeStackTraceID `json:"asyncStackTraceId,omitempty"`
}

// DebuggerResume Resumes JavaScript execution.
type DebuggerResume struct {
}

// Call of the command, sessionID is optional.
func (m DebuggerResume) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.resume", m)
	return err
}

// DebuggerSearchInContent Searches for given string in script content.
type DebuggerSearchInContent struct {

	// ScriptID Id of the script to search in.
	ScriptID RuntimeScriptID `json:"scriptId"`

	// Query String to search for.
	Query string `json:"query"`

	// CaseSensitive (optional) If true, search is case sensitive.
	CaseSensitive bool `json:"caseSensitive,omitempty"`

	// IsRegex (optional) If true, treats string parameter as regex.
	IsRegex bool `json:"isRegex,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DebuggerSearchInContent) Call(caller Caller) (*DebuggerSearchInContentResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Debugger.searchInContent", m)
	if err != nil {
		return nil, err
	}

	var res DebuggerSearchInContentResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DebuggerSearchInContentResult Searches for given string in script content.
type DebuggerSearchInContentResult struct {

	// Result List of search matches.
	Result []*DebuggerSearchMatch `json:"result"`
}

// DebuggerSetAsyncCallStackDepth Enables or disables async call stacks tracking.
type DebuggerSetAsyncCallStackDepth struct {

	// MaxDepth Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
	// call stacks (default).
	MaxDepth int64 `json:"maxDepth"`
}

// Call of the command, sessionID is optional.
func (m DebuggerSetAsyncCallStackDepth) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.setAsyncCallStackDepth", m)
	return err
}

// DebuggerSetBlackboxPatterns (experimental) Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
// scripts with url matching one of the patterns. VM will try to leave blackboxed script by
// performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
type DebuggerSetBlackboxPatterns struct {

	// Patterns Array of regexps that will be used to check script url for blackbox state.
	Patterns []string `json:"patterns"`
}

// Call of the command, sessionID is optional.
func (m DebuggerSetBlackboxPatterns) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.setBlackboxPatterns", m)
	return err
}

// DebuggerSetBlackboxedRanges (experimental) Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
// scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
// Positions array contains positions where blackbox state is changed. First interval isn't
// blackboxed. Array should be sorted.
type DebuggerSetBlackboxedRanges struct {

	// ScriptID Id of the script.
	ScriptID RuntimeScriptID `json:"scriptId"`

	// Positions ...
	Positions []*DebuggerScriptPosition `json:"positions"`
}

// Call of the command, sessionID is optional.
func (m DebuggerSetBlackboxedRanges) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.setBlackboxedRanges", m)
	return err
}

// DebuggerSetBreakpoint Sets JavaScript breakpoint at a given location.
type DebuggerSetBreakpoint struct {

	// Location Location to set breakpoint in.
	Location *DebuggerLocation `json:"location"`

	// Condition (optional) Expression to use as a breakpoint condition. When specified, debugger will only stop on the
	// breakpoint if this expression evaluates to true.
	Condition string `json:"condition,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DebuggerSetBreakpoint) Call(caller Caller) (*DebuggerSetBreakpointResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Debugger.setBreakpoint", m)
	if err != nil {
		return nil, err
	}

	var res DebuggerSetBreakpointResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DebuggerSetBreakpointResult Sets JavaScript breakpoint at a given location.
type DebuggerSetBreakpointResult struct {

	// BreakpointID Id of the created breakpoint for further reference.
	BreakpointID DebuggerBreakpointID `json:"breakpointId"`

	// ActualLocation Location this breakpoint resolved into.
	ActualLocation *DebuggerLocation `json:"actualLocation"`
}

// DebuggerSetInstrumentationBreakpointInstrumentation enum
type DebuggerSetInstrumentationBreakpointInstrumentation string

const (
	// DebuggerSetInstrumentationBreakpointInstrumentationBeforeScriptExecution enum const
	DebuggerSetInstrumentationBreakpointInstrumentationBeforeScriptExecution DebuggerSetInstrumentationBreakpointInstrumentation = "beforeScriptExecution"

	// DebuggerSetInstrumentationBreakpointInstrumentationBeforeScriptWithSourceMapExecution enum const
	DebuggerSetInstrumentationBreakpointInstrumentationBeforeScriptWithSourceMapExecution DebuggerSetInstrumentationBreakpointInstrumentation = "beforeScriptWithSourceMapExecution"
)

// DebuggerSetInstrumentationBreakpoint Sets instrumentation breakpoint.
type DebuggerSetInstrumentationBreakpoint struct {

	// Instrumentation Instrumentation name.
	Instrumentation DebuggerSetInstrumentationBreakpointInstrumentation `json:"instrumentation"`
}

// Call of the command, sessionID is optional.
func (m DebuggerSetInstrumentationBreakpoint) Call(caller Caller) (*DebuggerSetInstrumentationBreakpointResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Debugger.setInstrumentationBreakpoint", m)
	if err != nil {
		return nil, err
	}

	var res DebuggerSetInstrumentationBreakpointResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DebuggerSetInstrumentationBreakpointResult Sets instrumentation breakpoint.
type DebuggerSetInstrumentationBreakpointResult struct {

	// BreakpointID Id of the created breakpoint for further reference.
	BreakpointID DebuggerBreakpointID `json:"breakpointId"`
}

// DebuggerSetBreakpointByURL Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
// command is issued, all existing parsed scripts will have breakpoints resolved and returned in
// `locations` property. Further matching script parsing will result in subsequent
// `breakpointResolved` events issued. This logical breakpoint will survive page reloads.
type DebuggerSetBreakpointByURL struct {

	// LineNumber Line number to set breakpoint at.
	LineNumber int64 `json:"lineNumber"`

	// URL (optional) URL of the resources to set breakpoint on.
	URL string `json:"url,omitempty"`

	// URLRegex (optional) Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or
	// `urlRegex` must be specified.
	URLRegex string `json:"urlRegex,omitempty"`

	// ScriptHash (optional) Script hash of the resources to set breakpoint on.
	ScriptHash string `json:"scriptHash,omitempty"`

	// ColumnNumber (optional) Offset in the line to set breakpoint at.
	ColumnNumber int64 `json:"columnNumber,omitempty"`

	// Condition (optional) Expression to use as a breakpoint condition. When specified, debugger will only stop on the
	// breakpoint if this expression evaluates to true.
	Condition string `json:"condition,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DebuggerSetBreakpointByURL) Call(caller Caller) (*DebuggerSetBreakpointByURLResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Debugger.setBreakpointByUrl", m)
	if err != nil {
		return nil, err
	}

	var res DebuggerSetBreakpointByURLResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DebuggerSetBreakpointByURLResult Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
// command is issued, all existing parsed scripts will have breakpoints resolved and returned in
// `locations` property. Further matching script parsing will result in subsequent
// `breakpointResolved` events issued. This logical breakpoint will survive page reloads.
type DebuggerSetBreakpointByURLResult struct {

	// BreakpointID Id of the created breakpoint for further reference.
	BreakpointID DebuggerBreakpointID `json:"breakpointId"`

	// Locations List of the locations this breakpoint resolved into upon addition.
	Locations []*DebuggerLocation `json:"locations"`
}

// DebuggerSetBreakpointOnFunctionCall (experimental) Sets JavaScript breakpoint before each call to the given function.
// If another function was created from the same source as a given one,
// calling it will also trigger the breakpoint.
type DebuggerSetBreakpointOnFunctionCall struct {

	// ObjectID Function object id.
	ObjectID RuntimeRemoteObjectID `json:"objectId"`

	// Condition (optional) Expression to use as a breakpoint condition. When specified, debugger will
	// stop on the breakpoint if this expression evaluates to true.
	Condition string `json:"condition,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DebuggerSetBreakpointOnFunctionCall) Call(caller Caller) (*DebuggerSetBreakpointOnFunctionCallResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Debugger.setBreakpointOnFunctionCall", m)
	if err != nil {
		return nil, err
	}

	var res DebuggerSetBreakpointOnFunctionCallResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DebuggerSetBreakpointOnFunctionCallResult (experimental) Sets JavaScript breakpoint before each call to the given function.
// If another function was created from the same source as a given one,
// calling it will also trigger the breakpoint.
type DebuggerSetBreakpointOnFunctionCallResult struct {

	// BreakpointID Id of the created breakpoint for further reference.
	BreakpointID DebuggerBreakpointID `json:"breakpointId"`
}

// DebuggerSetBreakpointsActive Activates / deactivates all breakpoints on the page.
type DebuggerSetBreakpointsActive struct {

	// Active New value for breakpoints active state.
	Active bool `json:"active"`
}

// Call of the command, sessionID is optional.
func (m DebuggerSetBreakpointsActive) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.setBreakpointsActive", m)
	return err
}

// DebuggerSetPauseOnExceptionsState enum
type DebuggerSetPauseOnExceptionsState string

const (
	// DebuggerSetPauseOnExceptionsStateNone enum const
	DebuggerSetPauseOnExceptionsStateNone DebuggerSetPauseOnExceptionsState = "none"

	// DebuggerSetPauseOnExceptionsStateUncaught enum const
	DebuggerSetPauseOnExceptionsStateUncaught DebuggerSetPauseOnExceptionsState = "uncaught"

	// DebuggerSetPauseOnExceptionsStateAll enum const
	DebuggerSetPauseOnExceptionsStateAll DebuggerSetPauseOnExceptionsState = "all"
)

// DebuggerSetPauseOnExceptions Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or
// no exceptions. Initial pause on exceptions state is `none`.
type DebuggerSetPauseOnExceptions struct {

	// State Pause on exceptions mode.
	State DebuggerSetPauseOnExceptionsState `json:"state"`
}

// Call of the command, sessionID is optional.
func (m DebuggerSetPauseOnExceptions) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.setPauseOnExceptions", m)
	return err
}

// DebuggerSetReturnValue (experimental) Changes return value in top frame. Available only at return break position.
type DebuggerSetReturnValue struct {

	// NewValue New return value.
	NewValue *RuntimeCallArgument `json:"newValue"`
}

// Call of the command, sessionID is optional.
func (m DebuggerSetReturnValue) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.setReturnValue", m)
	return err
}

// DebuggerSetScriptSource Edits JavaScript source live.
type DebuggerSetScriptSource struct {

	// ScriptID Id of the script to edit.
	ScriptID RuntimeScriptID `json:"scriptId"`

	// ScriptSource New content of the script.
	ScriptSource string `json:"scriptSource"`

	// DryRun (optional) If true the change will not actually be applied. Dry run may be used to get result
	// description without actually modifying the code.
	DryRun bool `json:"dryRun,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DebuggerSetScriptSource) Call(caller Caller) (*DebuggerSetScriptSourceResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Debugger.setScriptSource", m)
	if err != nil {
		return nil, err
	}

	var res DebuggerSetScriptSourceResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// DebuggerSetScriptSourceResult Edits JavaScript source live.
type DebuggerSetScriptSourceResult struct {

	// CallFrames (optional) New stack trace in case editing has happened while VM was stopped.
	CallFrames []*DebuggerCallFrame `json:"callFrames,omitempty"`

	// StackChanged (optional) Whether current call stack  was modified after applying the changes.
	StackChanged bool `json:"stackChanged,omitempty"`

	// AsyncStackTrace (optional) Async stack trace, if any.
	AsyncStackTrace *RuntimeStackTrace `json:"asyncStackTrace,omitempty"`

	// AsyncStackTraceID (experimental) (optional) Async stack trace, if any.
	AsyncStackTraceID *RuntimeStackTraceID `json:"asyncStackTraceId,omitempty"`

	// ExceptionDetails (optional) Exception details if any.
	ExceptionDetails *RuntimeExceptionDetails `json:"exceptionDetails,omitempty"`
}

// DebuggerSetSkipAllPauses Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
type DebuggerSetSkipAllPauses struct {

	// Skip New value for skip pauses state.
	Skip bool `json:"skip"`
}

// Call of the command, sessionID is optional.
func (m DebuggerSetSkipAllPauses) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.setSkipAllPauses", m)
	return err
}

// DebuggerSetVariableValue Changes value of variable in a callframe. Object-based scopes are not supported and must be
// mutated manually.
type DebuggerSetVariableValue struct {

	// ScopeNumber 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch'
	// scope types are allowed. Other scopes could be manipulated manually.
	ScopeNumber int64 `json:"scopeNumber"`

	// VariableName Variable name.
	VariableName string `json:"variableName"`

	// NewValue New variable value.
	NewValue *RuntimeCallArgument `json:"newValue"`

	// CallFrameID Id of callframe that holds variable.
	CallFrameID DebuggerCallFrameID `json:"callFrameId"`
}

// Call of the command, sessionID is optional.
func (m DebuggerSetVariableValue) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.setVariableValue", m)
	return err
}

// DebuggerStepInto Steps into the function call.
type DebuggerStepInto struct {

	// BreakOnAsyncCall (experimental) (optional) Debugger will pause on the execution of the first async task which was scheduled
	// before next pause.
	BreakOnAsyncCall bool `json:"breakOnAsyncCall,omitempty"`
}

// Call of the command, sessionID is optional.
func (m DebuggerStepInto) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.stepInto", m)
	return err
}

// DebuggerStepOut Steps out of the function call.
type DebuggerStepOut struct {
}

// Call of the command, sessionID is optional.
func (m DebuggerStepOut) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.stepOut", m)
	return err
}

// DebuggerStepOver Steps over the statement.
type DebuggerStepOver struct {
}

// Call of the command, sessionID is optional.
func (m DebuggerStepOver) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Debugger.stepOver", m)
	return err
}

// DebuggerBreakpointResolved Fired when breakpoint is resolved to an actual script and location.
type DebuggerBreakpointResolved struct {

	// BreakpointID Breakpoint unique identifier.
	BreakpointID DebuggerBreakpointID `json:"breakpointId"`

	// Location Actual breakpoint location.
	Location *DebuggerLocation `json:"location"`
}

// MethodName interface
func (evt DebuggerBreakpointResolved) MethodName() string {
	return "Debugger.breakpointResolved"
}

// DebuggerPausedReason enum
type DebuggerPausedReason string

const (
	// DebuggerPausedReasonAmbiguous enum const
	DebuggerPausedReasonAmbiguous DebuggerPausedReason = "ambiguous"

	// DebuggerPausedReasonAssert enum const
	DebuggerPausedReasonAssert DebuggerPausedReason = "assert"

	// DebuggerPausedReasonDebugCommand enum const
	DebuggerPausedReasonDebugCommand DebuggerPausedReason = "debugCommand"

	// DebuggerPausedReasonDOM enum const
	DebuggerPausedReasonDOM DebuggerPausedReason = "DOM"

	// DebuggerPausedReasonEventListener enum const
	DebuggerPausedReasonEventListener DebuggerPausedReason = "EventListener"

	// DebuggerPausedReasonException enum const
	DebuggerPausedReasonException DebuggerPausedReason = "exception"

	// DebuggerPausedReasonInstrumentation enum const
	DebuggerPausedReasonInstrumentation DebuggerPausedReason = "instrumentation"

	// DebuggerPausedReasonOOM enum const
	DebuggerPausedReasonOOM DebuggerPausedReason = "OOM"

	// DebuggerPausedReasonOther enum const
	DebuggerPausedReasonOther DebuggerPausedReason = "other"

	// DebuggerPausedReasonPromiseRejection enum const
	DebuggerPausedReasonPromiseRejection DebuggerPausedReason = "promiseRejection"

	// DebuggerPausedReasonXHR enum const
	DebuggerPausedReasonXHR DebuggerPausedReason = "XHR"
)

// DebuggerPaused Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
type DebuggerPaused struct {

	// CallFrames Call stack the virtual machine stopped on.
	CallFrames []*DebuggerCallFrame `json:"callFrames"`

	// Reason Pause reason.
	Reason DebuggerPausedReason `json:"reason"`

	// Data (optional) Object containing break-specific auxiliary properties.
	Data map[string]JSON `json:"data,omitempty"`

	// HitBreakpoints (optional) Hit breakpoints IDs
	HitBreakpoints []string `json:"hitBreakpoints,omitempty"`

	// AsyncStackTrace (optional) Async stack trace, if any.
	AsyncStackTrace *RuntimeStackTrace `json:"asyncStackTrace,omitempty"`

	// AsyncStackTraceID (experimental) (optional) Async stack trace, if any.
	AsyncStackTraceID *RuntimeStackTraceID `json:"asyncStackTraceId,omitempty"`

	// AsyncCallStackTraceID (deprecated) (experimental) (optional) Never present, will be removed.
	AsyncCallStackTraceID *RuntimeStackTraceID `json:"asyncCallStackTraceId,omitempty"`
}

// MethodName interface
func (evt DebuggerPaused) MethodName() string {
	return "Debugger.paused"
}

// DebuggerResumed Fired when the virtual machine resumed execution.
type DebuggerResumed struct {
}

// MethodName interface
func (evt DebuggerResumed) MethodName() string {
	return "Debugger.resumed"
}

// DebuggerScriptFailedToParse Fired when virtual machine fails to parse the script.
type DebuggerScriptFailedToParse struct {

	// ScriptID Identifier of the script parsed.
	ScriptID RuntimeScriptID `json:"scriptId"`

	// URL URL or name of the script parsed (if any).
	URL string `json:"url"`

	// StartLine Line offset of the script within the resource with given URL (for script tags).
	StartLine int64 `json:"startLine"`

	// StartColumn Column offset of the script within the resource with given URL.
	StartColumn int64 `json:"startColumn"`

	// EndLine Last line of the script.
	EndLine int64 `json:"endLine"`

	// EndColumn Length of the last line of the script.
	EndColumn int64 `json:"endColumn"`

	// ExecutionContextID Specifies script creation context.
	ExecutionContextID RuntimeExecutionContextID `json:"executionContextId"`

	// Hash Content hash of the script.
	Hash string `json:"hash"`

	// ExecutionContextAuxData (optional) Embedder-specific auxiliary data.
	ExecutionContextAuxData map[string]JSON `json:"executionContextAuxData,omitempty"`

	// SourceMapURL (optional) URL of source map associated with script (if any).
	SourceMapURL string `json:"sourceMapURL,omitempty"`

	// HasSourceURL (optional) True, if this script has sourceURL.
	HasSourceURL bool `json:"hasSourceURL,omitempty"`

	// IsModule (optional) True, if this script is ES6 module.
	IsModule bool `json:"isModule,omitempty"`

	// Length (optional) This script length.
	Length int64 `json:"length,omitempty"`

	// StackTrace (experimental) (optional) JavaScript top stack frame of where the script parsed event was triggered if available.
	StackTrace *RuntimeStackTrace `json:"stackTrace,omitempty"`
}

// MethodName interface
func (evt DebuggerScriptFailedToParse) MethodName() string {
	return "Debugger.scriptFailedToParse"
}

// DebuggerScriptParsed Fired when virtual machine parses script. This event is also fired for all known and uncollected
// scripts upon enabling debugger.
type DebuggerScriptParsed struct {

	// ScriptID Identifier of the script parsed.
	ScriptID RuntimeScriptID `json:"scriptId"`

	// URL URL or name of the script parsed (if any).
	URL string `json:"url"`

	// StartLine Line offset of the script within the resource with given URL (for script tags).
	StartLine int64 `json:"startLine"`

	// StartColumn Column offset of the script within the resource with given URL.
	StartColumn int64 `json:"startColumn"`

	// EndLine Last line of the script.
	EndLine int64 `json:"endLine"`

	// EndColumn Length of the last line of the script.
	EndColumn int64 `json:"endColumn"`

	// ExecutionContextID Specifies script creation context.
	ExecutionContextID RuntimeExecutionContextID `json:"executionContextId"`

	// Hash Content hash of the script.
	Hash string `json:"hash"`

	// ExecutionContextAuxData (optional) Embedder-specific auxiliary data.
	ExecutionContextAuxData map[string]JSON `json:"executionContextAuxData,omitempty"`

	// IsLiveEdit (experimental) (optional) True, if this script is generated as a result of the live edit operation.
	IsLiveEdit bool `json:"isLiveEdit,omitempty"`

	// SourceMapURL (optional) URL of source map associated with script (if any).
	SourceMapURL string `json:"sourceMapURL,omitempty"`

	// HasSourceURL (optional) True, if this script has sourceURL.
	HasSourceURL bool `json:"hasSourceURL,omitempty"`

	// IsModule (optional) True, if this script is ES6 module.
	IsModule bool `json:"isModule,omitempty"`

	// Length (optional) This script length.
	Length int64 `json:"length,omitempty"`

	// StackTrace (experimental) (optional) JavaScript top stack frame of where the script parsed event was triggered if available.
	StackTrace *RuntimeStackTrace `json:"stackTrace,omitempty"`
}

// MethodName interface
func (evt DebuggerScriptParsed) MethodName() string {
	return "Debugger.scriptParsed"
}

// HeapProfilerHeapSnapshotObjectID Heap snapshot object id.
type HeapProfilerHeapSnapshotObjectID string

// HeapProfilerSamplingHeapProfileNode Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.
type HeapProfilerSamplingHeapProfileNode struct {

	// CallFrame Function location.
	CallFrame *RuntimeCallFrame `json:"callFrame"`

	// SelfSize Allocations size in bytes for the node excluding children.
	SelfSize float64 `json:"selfSize"`

	// ID Node id. Ids are unique across all profiles collected between startSampling and stopSampling.
	ID int64 `json:"id"`

	// Children Child nodes.
	Children []*HeapProfilerSamplingHeapProfileNode `json:"children"`
}

// HeapProfilerSamplingHeapProfileSample A single sample from a sampling profile.
type HeapProfilerSamplingHeapProfileSample struct {

	// Size Allocation size in bytes attributed to the sample.
	Size float64 `json:"size"`

	// NodeID Id of the corresponding profile tree node.
	NodeID int64 `json:"nodeId"`

	// Ordinal Time-ordered sample ordinal number. It is unique across all profiles retrieved
	// between startSampling and stopSampling.
	Ordinal float64 `json:"ordinal"`
}

// HeapProfilerSamplingHeapProfile Sampling profile.
type HeapProfilerSamplingHeapProfile struct {

	// Head ...
	Head *HeapProfilerSamplingHeapProfileNode `json:"head"`

	// Samples ...
	Samples []*HeapProfilerSamplingHeapProfileSample `json:"samples"`
}

// HeapProfilerAddInspectedHeapObject Enables console to refer to the node with given id via $x (see Command Line API for more details
// $x functions).
type HeapProfilerAddInspectedHeapObject struct {

	// HeapObjectID Heap snapshot object id to be accessible by means of $x command line API.
	HeapObjectID HeapProfilerHeapSnapshotObjectID `json:"heapObjectId"`
}

// Call of the command, sessionID is optional.
func (m HeapProfilerAddInspectedHeapObject) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "HeapProfiler.addInspectedHeapObject", m)
	return err
}

// HeapProfilerCollectGarbage ...
type HeapProfilerCollectGarbage struct {
}

// Call of the command, sessionID is optional.
func (m HeapProfilerCollectGarbage) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "HeapProfiler.collectGarbage", m)
	return err
}

// HeapProfilerDisable ...
type HeapProfilerDisable struct {
}

// Call of the command, sessionID is optional.
func (m HeapProfilerDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "HeapProfiler.disable", m)
	return err
}

// HeapProfilerEnable ...
type HeapProfilerEnable struct {
}

// Call of the command, sessionID is optional.
func (m HeapProfilerEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "HeapProfiler.enable", m)
	return err
}

// HeapProfilerGetHeapObjectID ...
type HeapProfilerGetHeapObjectID struct {

	// ObjectID Identifier of the object to get heap object id for.
	ObjectID RuntimeRemoteObjectID `json:"objectId"`
}

// Call of the command, sessionID is optional.
func (m HeapProfilerGetHeapObjectID) Call(caller Caller) (*HeapProfilerGetHeapObjectIDResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "HeapProfiler.getHeapObjectId", m)
	if err != nil {
		return nil, err
	}

	var res HeapProfilerGetHeapObjectIDResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// HeapProfilerGetHeapObjectIDResult ...
type HeapProfilerGetHeapObjectIDResult struct {

	// HeapSnapshotObjectID Id of the heap snapshot object corresponding to the passed remote object id.
	HeapSnapshotObjectID HeapProfilerHeapSnapshotObjectID `json:"heapSnapshotObjectId"`
}

// HeapProfilerGetObjectByHeapObjectID ...
type HeapProfilerGetObjectByHeapObjectID struct {

	// ObjectID ...
	ObjectID HeapProfilerHeapSnapshotObjectID `json:"objectId"`

	// ObjectGroup (optional) Symbolic group name that can be used to release multiple objects.
	ObjectGroup string `json:"objectGroup,omitempty"`
}

// Call of the command, sessionID is optional.
func (m HeapProfilerGetObjectByHeapObjectID) Call(caller Caller) (*HeapProfilerGetObjectByHeapObjectIDResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "HeapProfiler.getObjectByHeapObjectId", m)
	if err != nil {
		return nil, err
	}

	var res HeapProfilerGetObjectByHeapObjectIDResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// HeapProfilerGetObjectByHeapObjectIDResult ...
type HeapProfilerGetObjectByHeapObjectIDResult struct {

	// Result Evaluation result.
	Result *RuntimeRemoteObject `json:"result"`
}

// HeapProfilerGetSamplingProfile ...
type HeapProfilerGetSamplingProfile struct {
}

// Call of the command, sessionID is optional.
func (m HeapProfilerGetSamplingProfile) Call(caller Caller) (*HeapProfilerGetSamplingProfileResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "HeapProfiler.getSamplingProfile", m)
	if err != nil {
		return nil, err
	}

	var res HeapProfilerGetSamplingProfileResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// HeapProfilerGetSamplingProfileResult ...
type HeapProfilerGetSamplingProfileResult struct {

	// Profile Return the sampling profile being collected.
	Profile *HeapProfilerSamplingHeapProfile `json:"profile"`
}

// HeapProfilerStartSampling ...
type HeapProfilerStartSampling struct {

	// SamplingInterval (optional) Average sample interval in bytes. Poisson distribution is used for the intervals. The
	// default value is 32768 bytes.
	SamplingInterval float64 `json:"samplingInterval,omitempty"`
}

// Call of the command, sessionID is optional.
func (m HeapProfilerStartSampling) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "HeapProfiler.startSampling", m)
	return err
}

// HeapProfilerStartTrackingHeapObjects ...
type HeapProfilerStartTrackingHeapObjects struct {

	// TrackAllocations (optional) ...
	TrackAllocations bool `json:"trackAllocations,omitempty"`
}

// Call of the command, sessionID is optional.
func (m HeapProfilerStartTrackingHeapObjects) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "HeapProfiler.startTrackingHeapObjects", m)
	return err
}

// HeapProfilerStopSampling ...
type HeapProfilerStopSampling struct {
}

// Call of the command, sessionID is optional.
func (m HeapProfilerStopSampling) Call(caller Caller) (*HeapProfilerStopSamplingResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "HeapProfiler.stopSampling", m)
	if err != nil {
		return nil, err
	}

	var res HeapProfilerStopSamplingResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// HeapProfilerStopSamplingResult ...
type HeapProfilerStopSamplingResult struct {

	// Profile Recorded sampling heap profile.
	Profile *HeapProfilerSamplingHeapProfile `json:"profile"`
}

// HeapProfilerStopTrackingHeapObjects ...
type HeapProfilerStopTrackingHeapObjects struct {

	// ReportProgress (optional) If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken
	// when the tracking is stopped.
	ReportProgress bool `json:"reportProgress,omitempty"`

	// TreatGlobalObjectsAsRoots (optional) ...
	TreatGlobalObjectsAsRoots bool `json:"treatGlobalObjectsAsRoots,omitempty"`
}

// Call of the command, sessionID is optional.
func (m HeapProfilerStopTrackingHeapObjects) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "HeapProfiler.stopTrackingHeapObjects", m)
	return err
}

// HeapProfilerTakeHeapSnapshot ...
type HeapProfilerTakeHeapSnapshot struct {

	// ReportProgress (optional) If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
	ReportProgress bool `json:"reportProgress,omitempty"`

	// TreatGlobalObjectsAsRoots (optional) If true, a raw snapshot without artifical roots will be generated
	TreatGlobalObjectsAsRoots bool `json:"treatGlobalObjectsAsRoots,omitempty"`
}

// Call of the command, sessionID is optional.
func (m HeapProfilerTakeHeapSnapshot) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "HeapProfiler.takeHeapSnapshot", m)
	return err
}

// HeapProfilerAddHeapSnapshotChunk ...
type HeapProfilerAddHeapSnapshotChunk struct {

	// Chunk ...
	Chunk string `json:"chunk"`
}

// MethodName interface
func (evt HeapProfilerAddHeapSnapshotChunk) MethodName() string {
	return "HeapProfiler.addHeapSnapshotChunk"
}

// HeapProfilerHeapStatsUpdate If heap objects tracking has been started then backend may send update for one or more fragments
type HeapProfilerHeapStatsUpdate struct {

	// StatsUpdate An array of triplets. Each triplet describes a fragment. The first integer is the fragment
	// index, the second integer is a total count of objects for the fragment, the third integer is
	// a total size of the objects for the fragment.
	StatsUpdate []int64 `json:"statsUpdate"`
}

// MethodName interface
func (evt HeapProfilerHeapStatsUpdate) MethodName() string {
	return "HeapProfiler.heapStatsUpdate"
}

// HeapProfilerLastSeenObjectID If heap objects tracking has been started then backend regularly sends a current value for last
// seen object id and corresponding timestamp. If the were changes in the heap since last event
// then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
type HeapProfilerLastSeenObjectID struct {

	// LastSeenObjectID ...
	LastSeenObjectID int64 `json:"lastSeenObjectId"`

	// Timestamp ...
	Timestamp float64 `json:"timestamp"`
}

// MethodName interface
func (evt HeapProfilerLastSeenObjectID) MethodName() string {
	return "HeapProfiler.lastSeenObjectId"
}

// HeapProfilerReportHeapSnapshotProgress ...
type HeapProfilerReportHeapSnapshotProgress struct {

	// Done ...
	Done int64 `json:"done"`

	// Total ...
	Total int64 `json:"total"`

	// Finished (optional) ...
	Finished bool `json:"finished,omitempty"`
}

// MethodName interface
func (evt HeapProfilerReportHeapSnapshotProgress) MethodName() string {
	return "HeapProfiler.reportHeapSnapshotProgress"
}

// HeapProfilerResetProfiles ...
type HeapProfilerResetProfiles struct {
}

// MethodName interface
func (evt HeapProfilerResetProfiles) MethodName() string {
	return "HeapProfiler.resetProfiles"
}

// ProfilerProfileNode Profile node. Holds callsite information, execution statistics and child nodes.
type ProfilerProfileNode struct {

	// ID Unique id of the node.
	ID int64 `json:"id"`

	// CallFrame Function location.
	CallFrame *RuntimeCallFrame `json:"callFrame"`

	// HitCount (optional) Number of samples where this node was on top of the call stack.
	HitCount int64 `json:"hitCount,omitempty"`

	// Children (optional) Child node ids.
	Children []int64 `json:"children,omitempty"`

	// DeoptReason (optional) The reason of being not optimized. The function may be deoptimized or marked as don't
	// optimize.
	DeoptReason string `json:"deoptReason,omitempty"`

	// PositionTicks (optional) An array of source position ticks.
	PositionTicks []*ProfilerPositionTickInfo `json:"positionTicks,omitempty"`
}

// ProfilerProfile Profile.
type ProfilerProfile struct {

	// Nodes The list of profile nodes. First item is the root node.
	Nodes []*ProfilerProfileNode `json:"nodes"`

	// StartTime Profiling start timestamp in microseconds.
	StartTime float64 `json:"startTime"`

	// EndTime Profiling end timestamp in microseconds.
	EndTime float64 `json:"endTime"`

	// Samples (optional) Ids of samples top nodes.
	Samples []int64 `json:"samples,omitempty"`

	// TimeDeltas (optional) Time intervals between adjacent samples in microseconds. The first delta is relative to the
	// profile startTime.
	TimeDeltas []int64 `json:"timeDeltas,omitempty"`
}

// ProfilerPositionTickInfo Specifies a number of samples attributed to a certain source position.
type ProfilerPositionTickInfo struct {

	// Line Source line number (1-based).
	Line int64 `json:"line"`

	// Ticks Number of samples attributed to the source line.
	Ticks int64 `json:"ticks"`
}

// ProfilerCoverageRange Coverage data for a source range.
type ProfilerCoverageRange struct {

	// StartOffset JavaScript script source offset for the range start.
	StartOffset int64 `json:"startOffset"`

	// EndOffset JavaScript script source offset for the range end.
	EndOffset int64 `json:"endOffset"`

	// Count Collected execution count of the source range.
	Count int64 `json:"count"`
}

// ProfilerFunctionCoverage Coverage data for a JavaScript function.
type ProfilerFunctionCoverage struct {

	// FunctionName JavaScript function name.
	FunctionName string `json:"functionName"`

	// Ranges Source ranges inside the function with coverage data.
	Ranges []*ProfilerCoverageRange `json:"ranges"`

	// IsBlockCoverage Whether coverage data for this function has block granularity.
	IsBlockCoverage bool `json:"isBlockCoverage"`
}

// ProfilerScriptCoverage Coverage data for a JavaScript script.
type ProfilerScriptCoverage struct {

	// ScriptID JavaScript script id.
	ScriptID RuntimeScriptID `json:"scriptId"`

	// URL JavaScript script name or url.
	URL string `json:"url"`

	// Functions Functions contained in the script that has coverage data.
	Functions []*ProfilerFunctionCoverage `json:"functions"`
}

// ProfilerTypeObject (experimental) Describes a type collected during runtime.
type ProfilerTypeObject struct {

	// Name Name of a type collected with type profiling.
	Name string `json:"name"`
}

// ProfilerTypeProfileEntry (experimental) Source offset and types for a parameter or return value.
type ProfilerTypeProfileEntry struct {

	// Offset Source offset of the parameter or end of function for return values.
	Offset int64 `json:"offset"`

	// Types The types for this parameter or return value.
	Types []*ProfilerTypeObject `json:"types"`
}

// ProfilerScriptTypeProfile (experimental) Type profile data collected during runtime for a JavaScript script.
type ProfilerScriptTypeProfile struct {

	// ScriptID JavaScript script id.
	ScriptID RuntimeScriptID `json:"scriptId"`

	// URL JavaScript script name or url.
	URL string `json:"url"`

	// Entries Type profile entries for parameters and return values of the functions in the script.
	Entries []*ProfilerTypeProfileEntry `json:"entries"`
}

// ProfilerCounterInfo (experimental) Collected counter information.
type ProfilerCounterInfo struct {

	// Name Counter name.
	Name string `json:"name"`

	// Value Counter value.
	Value int64 `json:"value"`
}

// ProfilerDisable ...
type ProfilerDisable struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Profiler.disable", m)
	return err
}

// ProfilerEnable ...
type ProfilerEnable struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Profiler.enable", m)
	return err
}

// ProfilerGetBestEffortCoverage Collect coverage data for the current isolate. The coverage data may be incomplete due to
// garbage collection.
type ProfilerGetBestEffortCoverage struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerGetBestEffortCoverage) Call(caller Caller) (*ProfilerGetBestEffortCoverageResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Profiler.getBestEffortCoverage", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerGetBestEffortCoverageResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerGetBestEffortCoverageResult Collect coverage data for the current isolate. The coverage data may be incomplete due to
// garbage collection.
type ProfilerGetBestEffortCoverageResult struct {

	// Result Coverage data for the current isolate.
	Result []*ProfilerScriptCoverage `json:"result"`
}

// ProfilerSetSamplingInterval Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
type ProfilerSetSamplingInterval struct {

	// Interval New sampling interval in microseconds.
	Interval int64 `json:"interval"`
}

// Call of the command, sessionID is optional.
func (m ProfilerSetSamplingInterval) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Profiler.setSamplingInterval", m)
	return err
}

// ProfilerStart ...
type ProfilerStart struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerStart) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Profiler.start", m)
	return err
}

// ProfilerStartPreciseCoverage Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
// coverage may be incomplete. Enabling prevents running optimized code and resets execution
// counters.
type ProfilerStartPreciseCoverage struct {

	// CallCount (optional) Collect accurate call counts beyond simple 'covered' or 'not covered'.
	CallCount bool `json:"callCount,omitempty"`

	// Detailed (optional) Collect block-based coverage.
	Detailed bool `json:"detailed,omitempty"`
}

// Call of the command, sessionID is optional.
func (m ProfilerStartPreciseCoverage) Call(caller Caller) (*ProfilerStartPreciseCoverageResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Profiler.startPreciseCoverage", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerStartPreciseCoverageResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerStartPreciseCoverageResult Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
// coverage may be incomplete. Enabling prevents running optimized code and resets execution
// counters.
type ProfilerStartPreciseCoverageResult struct {

	// Timestamp Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
	Timestamp float64 `json:"timestamp"`
}

// ProfilerStartTypeProfile (experimental) Enable type profile.
type ProfilerStartTypeProfile struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerStartTypeProfile) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Profiler.startTypeProfile", m)
	return err
}

// ProfilerStop ...
type ProfilerStop struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerStop) Call(caller Caller) (*ProfilerStopResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Profiler.stop", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerStopResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerStopResult ...
type ProfilerStopResult struct {

	// Profile Recorded profile.
	Profile *ProfilerProfile `json:"profile"`
}

// ProfilerStopPreciseCoverage Disable precise code coverage. Disabling releases unnecessary execution count records and allows
// executing optimized code.
type ProfilerStopPreciseCoverage struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerStopPreciseCoverage) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Profiler.stopPreciseCoverage", m)
	return err
}

// ProfilerStopTypeProfile (experimental) Disable type profile. Disabling releases type profile data collected so far.
type ProfilerStopTypeProfile struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerStopTypeProfile) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Profiler.stopTypeProfile", m)
	return err
}

// ProfilerTakePreciseCoverage Collect coverage data for the current isolate, and resets execution counters. Precise code
// coverage needs to have started.
type ProfilerTakePreciseCoverage struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerTakePreciseCoverage) Call(caller Caller) (*ProfilerTakePreciseCoverageResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Profiler.takePreciseCoverage", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerTakePreciseCoverageResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerTakePreciseCoverageResult Collect coverage data for the current isolate, and resets execution counters. Precise code
// coverage needs to have started.
type ProfilerTakePreciseCoverageResult struct {

	// Result Coverage data for the current isolate.
	Result []*ProfilerScriptCoverage `json:"result"`

	// Timestamp Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
	Timestamp float64 `json:"timestamp"`
}

// ProfilerTakeTypeProfile (experimental) Collect type profile.
type ProfilerTakeTypeProfile struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerTakeTypeProfile) Call(caller Caller) (*ProfilerTakeTypeProfileResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Profiler.takeTypeProfile", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerTakeTypeProfileResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerTakeTypeProfileResult (experimental) Collect type profile.
type ProfilerTakeTypeProfileResult struct {

	// Result Type profile for all scripts since startTypeProfile() was turned on.
	Result []*ProfilerScriptTypeProfile `json:"result"`
}

// ProfilerEnableRuntimeCallStats (experimental) Enable run time call stats collection.
type ProfilerEnableRuntimeCallStats struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerEnableRuntimeCallStats) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Profiler.enableRuntimeCallStats", m)
	return err
}

// ProfilerDisableRuntimeCallStats (experimental) Disable run time call stats collection.
type ProfilerDisableRuntimeCallStats struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerDisableRuntimeCallStats) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Profiler.disableRuntimeCallStats", m)
	return err
}

// ProfilerGetRuntimeCallStats (experimental) Retrieve run time call stats.
type ProfilerGetRuntimeCallStats struct {
}

// Call of the command, sessionID is optional.
func (m ProfilerGetRuntimeCallStats) Call(caller Caller) (*ProfilerGetRuntimeCallStatsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Profiler.getRuntimeCallStats", m)
	if err != nil {
		return nil, err
	}

	var res ProfilerGetRuntimeCallStatsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// ProfilerGetRuntimeCallStatsResult (experimental) Retrieve run time call stats.
type ProfilerGetRuntimeCallStatsResult struct {

	// Result Collected counter information.
	Result []*ProfilerCounterInfo `json:"result"`
}

// ProfilerConsoleProfileFinished ...
type ProfilerConsoleProfileFinished struct {

	// ID ...
	ID string `json:"id"`

	// Location Location of console.profileEnd().
	Location *DebuggerLocation `json:"location"`

	// Profile ...
	Profile *ProfilerProfile `json:"profile"`

	// Title (optional) Profile title passed as an argument to console.profile().
	Title string `json:"title,omitempty"`
}

// MethodName interface
func (evt ProfilerConsoleProfileFinished) MethodName() string {
	return "Profiler.consoleProfileFinished"
}

// ProfilerConsoleProfileStarted Sent when new profile recording is started using console.profile() call.
type ProfilerConsoleProfileStarted struct {

	// ID ...
	ID string `json:"id"`

	// Location Location of console.profile().
	Location *DebuggerLocation `json:"location"`

	// Title (optional) Profile title passed as an argument to console.profile().
	Title string `json:"title,omitempty"`
}

// MethodName interface
func (evt ProfilerConsoleProfileStarted) MethodName() string {
	return "Profiler.consoleProfileStarted"
}

// ProfilerPreciseCoverageDeltaUpdate (experimental) Reports coverage delta since the last poll (either from an event like this, or from
// `takePreciseCoverage` for the current isolate. May only be sent if precise code
// coverage has been started. This event can be trigged by the embedder to, for example,
// trigger collection of coverage data immediatelly at a certain point in time.
type ProfilerPreciseCoverageDeltaUpdate struct {

	// Timestamp Monotonically increasing time (in seconds) when the coverage update was taken in the backend.
	Timestamp float64 `json:"timestamp"`

	// Occassion Identifier for distinguishing coverage events.
	Occassion string `json:"occassion"`

	// Result Coverage data for the current isolate.
	Result []*ProfilerScriptCoverage `json:"result"`
}

// MethodName interface
func (evt ProfilerPreciseCoverageDeltaUpdate) MethodName() string {
	return "Profiler.preciseCoverageDeltaUpdate"
}

// RuntimeScriptID Unique script identifier.
type RuntimeScriptID string

// RuntimeRemoteObjectID Unique object identifier.
type RuntimeRemoteObjectID string

// RuntimeUnserializableValue Primitive value which cannot be JSON-stringified. Includes values `-0`, `NaN`, `Infinity`,
// `-Infinity`, and bigint literals.
type RuntimeUnserializableValue string

// RuntimeRemoteObjectType enum
type RuntimeRemoteObjectType string

const (
	// RuntimeRemoteObjectTypeObject enum const
	RuntimeRemoteObjectTypeObject RuntimeRemoteObjectType = "object"

	// RuntimeRemoteObjectTypeFunction enum const
	RuntimeRemoteObjectTypeFunction RuntimeRemoteObjectType = "function"

	// RuntimeRemoteObjectTypeUndefined enum const
	RuntimeRemoteObjectTypeUndefined RuntimeRemoteObjectType = "undefined"

	// RuntimeRemoteObjectTypeString enum const
	RuntimeRemoteObjectTypeString RuntimeRemoteObjectType = "string"

	// RuntimeRemoteObjectTypeNumber enum const
	RuntimeRemoteObjectTypeNumber RuntimeRemoteObjectType = "number"

	// RuntimeRemoteObjectTypeBoolean enum const
	RuntimeRemoteObjectTypeBoolean RuntimeRemoteObjectType = "boolean"

	// RuntimeRemoteObjectTypeSymbol enum const
	RuntimeRemoteObjectTypeSymbol RuntimeRemoteObjectType = "symbol"

	// RuntimeRemoteObjectTypeBigint enum const
	RuntimeRemoteObjectTypeBigint RuntimeRemoteObjectType = "bigint"
)

// RuntimeRemoteObjectSubtype enum
type RuntimeRemoteObjectSubtype string

const (
	// RuntimeRemoteObjectSubtypeArray enum const
	RuntimeRemoteObjectSubtypeArray RuntimeRemoteObjectSubtype = "array"

	// RuntimeRemoteObjectSubtypeNull enum const
	RuntimeRemoteObjectSubtypeNull RuntimeRemoteObjectSubtype = "null"

	// RuntimeRemoteObjectSubtypeNode enum const
	RuntimeRemoteObjectSubtypeNode RuntimeRemoteObjectSubtype = "node"

	// RuntimeRemoteObjectSubtypeRegexp enum const
	RuntimeRemoteObjectSubtypeRegexp RuntimeRemoteObjectSubtype = "regexp"

	// RuntimeRemoteObjectSubtypeDate enum const
	RuntimeRemoteObjectSubtypeDate RuntimeRemoteObjectSubtype = "date"

	// RuntimeRemoteObjectSubtypeMap enum const
	RuntimeRemoteObjectSubtypeMap RuntimeRemoteObjectSubtype = "map"

	// RuntimeRemoteObjectSubtypeSet enum const
	RuntimeRemoteObjectSubtypeSet RuntimeRemoteObjectSubtype = "set"

	// RuntimeRemoteObjectSubtypeWeakmap enum const
	RuntimeRemoteObjectSubtypeWeakmap RuntimeRemoteObjectSubtype = "weakmap"

	// RuntimeRemoteObjectSubtypeWeakset enum const
	RuntimeRemoteObjectSubtypeWeakset RuntimeRemoteObjectSubtype = "weakset"

	// RuntimeRemoteObjectSubtypeIterator enum const
	RuntimeRemoteObjectSubtypeIterator RuntimeRemoteObjectSubtype = "iterator"

	// RuntimeRemoteObjectSubtypeGenerator enum const
	RuntimeRemoteObjectSubtypeGenerator RuntimeRemoteObjectSubtype = "generator"

	// RuntimeRemoteObjectSubtypeError enum const
	RuntimeRemoteObjectSubtypeError RuntimeRemoteObjectSubtype = "error"

	// RuntimeRemoteObjectSubtypeProxy enum const
	RuntimeRemoteObjectSubtypeProxy RuntimeRemoteObjectSubtype = "proxy"

	// RuntimeRemoteObjectSubtypePromise enum const
	RuntimeRemoteObjectSubtypePromise RuntimeRemoteObjectSubtype = "promise"

	// RuntimeRemoteObjectSubtypeTypedarray enum const
	RuntimeRemoteObjectSubtypeTypedarray RuntimeRemoteObjectSubtype = "typedarray"

	// RuntimeRemoteObjectSubtypeArraybuffer enum const
	RuntimeRemoteObjectSubtypeArraybuffer RuntimeRemoteObjectSubtype = "arraybuffer"

	// RuntimeRemoteObjectSubtypeDataview enum const
	RuntimeRemoteObjectSubtypeDataview RuntimeRemoteObjectSubtype = "dataview"
)

// RuntimeRemoteObject Mirror object referencing original JavaScript object.
type RuntimeRemoteObject struct {

	// Type Object type.
	Type RuntimeRemoteObjectType `json:"type"`

	// Subtype (optional) Object subtype hint. Specified for `object` type values only.
	Subtype RuntimeRemoteObjectSubtype `json:"subtype,omitempty"`

	// ClassName (optional) Object class (constructor) name. Specified for `object` type values only.
	ClassName string `json:"className,omitempty"`

	// Value (optional) Remote object value in case of primitive values or JSON values (if it was requested).
	Value JSON `json:"value,omitempty"`

	// UnserializableValue (optional) Primitive value which can not be JSON-stringified does not have `value`, but gets this
	// property.
	UnserializableValue RuntimeUnserializableValue `json:"unserializableValue,omitempty"`

	// Description (optional) String representation of the object.
	Description string `json:"description,omitempty"`

	// ObjectID (optional) Unique object identifier (for non-primitive values).
	ObjectID RuntimeRemoteObjectID `json:"objectId,omitempty"`

	// Preview (experimental) (optional) Preview containing abbreviated property values. Specified for `object` type values only.
	Preview *RuntimeObjectPreview `json:"preview,omitempty"`

	// CustomPreview (experimental) (optional) ...
	CustomPreview *RuntimeCustomPreview `json:"customPreview,omitempty"`
}

// RuntimeCustomPreview (experimental) ...
type RuntimeCustomPreview struct {

	// Header The JSON-stringified result of formatter.header(object, config) call.
	// It contains json ML array that represents RemoteObject.
	Header string `json:"header"`

	// BodyGetterID (optional) If formatter returns true as a result of formatter.hasBody call then bodyGetterId will
	// contain RemoteObjectId for the function that returns result of formatter.body(object, config) call.
	// The result value is json ML array.
	BodyGetterID RuntimeRemoteObjectID `json:"bodyGetterId,omitempty"`
}

// RuntimeObjectPreviewType enum
type RuntimeObjectPreviewType string

const (
	// RuntimeObjectPreviewTypeObject enum const
	RuntimeObjectPreviewTypeObject RuntimeObjectPreviewType = "object"

	// RuntimeObjectPreviewTypeFunction enum const
	RuntimeObjectPreviewTypeFunction RuntimeObjectPreviewType = "function"

	// RuntimeObjectPreviewTypeUndefined enum const
	RuntimeObjectPreviewTypeUndefined RuntimeObjectPreviewType = "undefined"

	// RuntimeObjectPreviewTypeString enum const
	RuntimeObjectPreviewTypeString RuntimeObjectPreviewType = "string"

	// RuntimeObjectPreviewTypeNumber enum const
	RuntimeObjectPreviewTypeNumber RuntimeObjectPreviewType = "number"

	// RuntimeObjectPreviewTypeBoolean enum const
	RuntimeObjectPreviewTypeBoolean RuntimeObjectPreviewType = "boolean"

	// RuntimeObjectPreviewTypeSymbol enum const
	RuntimeObjectPreviewTypeSymbol RuntimeObjectPreviewType = "symbol"

	// RuntimeObjectPreviewTypeBigint enum const
	RuntimeObjectPreviewTypeBigint RuntimeObjectPreviewType = "bigint"
)

// RuntimeObjectPreviewSubtype enum
type RuntimeObjectPreviewSubtype string

const (
	// RuntimeObjectPreviewSubtypeArray enum const
	RuntimeObjectPreviewSubtypeArray RuntimeObjectPreviewSubtype = "array"

	// RuntimeObjectPreviewSubtypeNull enum const
	RuntimeObjectPreviewSubtypeNull RuntimeObjectPreviewSubtype = "null"

	// RuntimeObjectPreviewSubtypeNode enum const
	RuntimeObjectPreviewSubtypeNode RuntimeObjectPreviewSubtype = "node"

	// RuntimeObjectPreviewSubtypeRegexp enum const
	RuntimeObjectPreviewSubtypeRegexp RuntimeObjectPreviewSubtype = "regexp"

	// RuntimeObjectPreviewSubtypeDate enum const
	RuntimeObjectPreviewSubtypeDate RuntimeObjectPreviewSubtype = "date"

	// RuntimeObjectPreviewSubtypeMap enum const
	RuntimeObjectPreviewSubtypeMap RuntimeObjectPreviewSubtype = "map"

	// RuntimeObjectPreviewSubtypeSet enum const
	RuntimeObjectPreviewSubtypeSet RuntimeObjectPreviewSubtype = "set"

	// RuntimeObjectPreviewSubtypeWeakmap enum const
	RuntimeObjectPreviewSubtypeWeakmap RuntimeObjectPreviewSubtype = "weakmap"

	// RuntimeObjectPreviewSubtypeWeakset enum const
	RuntimeObjectPreviewSubtypeWeakset RuntimeObjectPreviewSubtype = "weakset"

	// RuntimeObjectPreviewSubtypeIterator enum const
	RuntimeObjectPreviewSubtypeIterator RuntimeObjectPreviewSubtype = "iterator"

	// RuntimeObjectPreviewSubtypeGenerator enum const
	RuntimeObjectPreviewSubtypeGenerator RuntimeObjectPreviewSubtype = "generator"

	// RuntimeObjectPreviewSubtypeError enum const
	RuntimeObjectPreviewSubtypeError RuntimeObjectPreviewSubtype = "error"
)

// RuntimeObjectPreview (experimental) Object containing abbreviated remote object value.
type RuntimeObjectPreview struct {

	// Type Object type.
	Type RuntimeObjectPreviewType `json:"type"`

	// Subtype (optional) Object subtype hint. Specified for `object` type values only.
	Subtype RuntimeObjectPreviewSubtype `json:"subtype,omitempty"`

	// Description (optional) String representation of the object.
	Description string `json:"description,omitempty"`

	// Overflow True iff some of the properties or entries of the original object did not fit.
	Overflow bool `json:"overflow"`

	// Properties List of the properties.
	Properties []*RuntimePropertyPreview `json:"properties"`

	// Entries (optional) List of the entries. Specified for `map` and `set` subtype values only.
	Entries []*RuntimeEntryPreview `json:"entries,omitempty"`
}

// RuntimePropertyPreviewType enum
type RuntimePropertyPreviewType string

const (
	// RuntimePropertyPreviewTypeObject enum const
	RuntimePropertyPreviewTypeObject RuntimePropertyPreviewType = "object"

	// RuntimePropertyPreviewTypeFunction enum const
	RuntimePropertyPreviewTypeFunction RuntimePropertyPreviewType = "function"

	// RuntimePropertyPreviewTypeUndefined enum const
	RuntimePropertyPreviewTypeUndefined RuntimePropertyPreviewType = "undefined"

	// RuntimePropertyPreviewTypeString enum const
	RuntimePropertyPreviewTypeString RuntimePropertyPreviewType = "string"

	// RuntimePropertyPreviewTypeNumber enum const
	RuntimePropertyPreviewTypeNumber RuntimePropertyPreviewType = "number"

	// RuntimePropertyPreviewTypeBoolean enum const
	RuntimePropertyPreviewTypeBoolean RuntimePropertyPreviewType = "boolean"

	// RuntimePropertyPreviewTypeSymbol enum const
	RuntimePropertyPreviewTypeSymbol RuntimePropertyPreviewType = "symbol"

	// RuntimePropertyPreviewTypeAccessor enum const
	RuntimePropertyPreviewTypeAccessor RuntimePropertyPreviewType = "accessor"

	// RuntimePropertyPreviewTypeBigint enum const
	RuntimePropertyPreviewTypeBigint RuntimePropertyPreviewType = "bigint"
)

// RuntimePropertyPreviewSubtype enum
type RuntimePropertyPreviewSubtype string

const (
	// RuntimePropertyPreviewSubtypeArray enum const
	RuntimePropertyPreviewSubtypeArray RuntimePropertyPreviewSubtype = "array"

	// RuntimePropertyPreviewSubtypeNull enum const
	RuntimePropertyPreviewSubtypeNull RuntimePropertyPreviewSubtype = "null"

	// RuntimePropertyPreviewSubtypeNode enum const
	RuntimePropertyPreviewSubtypeNode RuntimePropertyPreviewSubtype = "node"

	// RuntimePropertyPreviewSubtypeRegexp enum const
	RuntimePropertyPreviewSubtypeRegexp RuntimePropertyPreviewSubtype = "regexp"

	// RuntimePropertyPreviewSubtypeDate enum const
	RuntimePropertyPreviewSubtypeDate RuntimePropertyPreviewSubtype = "date"

	// RuntimePropertyPreviewSubtypeMap enum const
	RuntimePropertyPreviewSubtypeMap RuntimePropertyPreviewSubtype = "map"

	// RuntimePropertyPreviewSubtypeSet enum const
	RuntimePropertyPreviewSubtypeSet RuntimePropertyPreviewSubtype = "set"

	// RuntimePropertyPreviewSubtypeWeakmap enum const
	RuntimePropertyPreviewSubtypeWeakmap RuntimePropertyPreviewSubtype = "weakmap"

	// RuntimePropertyPreviewSubtypeWeakset enum const
	RuntimePropertyPreviewSubtypeWeakset RuntimePropertyPreviewSubtype = "weakset"

	// RuntimePropertyPreviewSubtypeIterator enum const
	RuntimePropertyPreviewSubtypeIterator RuntimePropertyPreviewSubtype = "iterator"

	// RuntimePropertyPreviewSubtypeGenerator enum const
	RuntimePropertyPreviewSubtypeGenerator RuntimePropertyPreviewSubtype = "generator"

	// RuntimePropertyPreviewSubtypeError enum const
	RuntimePropertyPreviewSubtypeError RuntimePropertyPreviewSubtype = "error"
)

// RuntimePropertyPreview (experimental) ...
type RuntimePropertyPreview struct {

	// Name Property name.
	Name string `json:"name"`

	// Type Object type. Accessor means that the property itself is an accessor property.
	Type RuntimePropertyPreviewType `json:"type"`

	// Value (optional) User-friendly property value string.
	Value string `json:"value,omitempty"`

	// ValuePreview (optional) Nested value preview.
	ValuePreview *RuntimeObjectPreview `json:"valuePreview,omitempty"`

	// Subtype (optional) Object subtype hint. Specified for `object` type values only.
	Subtype RuntimePropertyPreviewSubtype `json:"subtype,omitempty"`
}

// RuntimeEntryPreview (experimental) ...
type RuntimeEntryPreview struct {

	// Key (optional) Preview of the key. Specified for map-like collection entries.
	Key *RuntimeObjectPreview `json:"key,omitempty"`

	// Value Preview of the value.
	Value *RuntimeObjectPreview `json:"value"`
}

// RuntimePropertyDescriptor Object property descriptor.
type RuntimePropertyDescriptor struct {

	// Name Property name or symbol description.
	Name string `json:"name"`

	// Value (optional) The value associated with the property.
	Value *RuntimeRemoteObject `json:"value,omitempty"`

	// Writable (optional) True if the value associated with the property may be changed (data descriptors only).
	Writable bool `json:"writable,omitempty"`

	// Get (optional) A function which serves as a getter for the property, or `undefined` if there is no getter
	// (accessor descriptors only).
	Get *RuntimeRemoteObject `json:"get,omitempty"`

	// Set (optional) A function which serves as a setter for the property, or `undefined` if there is no setter
	// (accessor descriptors only).
	Set *RuntimeRemoteObject `json:"set,omitempty"`

	// Configurable True if the type of this property descriptor may be changed and if the property may be
	// deleted from the corresponding object.
	Configurable bool `json:"configurable"`

	// Enumerable True if this property shows up during enumeration of the properties on the corresponding
	// object.
	Enumerable bool `json:"enumerable"`

	// WasThrown (optional) True if the result was thrown during the evaluation.
	WasThrown bool `json:"wasThrown,omitempty"`

	// IsOwn (optional) True if the property is owned for the object.
	IsOwn bool `json:"isOwn,omitempty"`

	// Symbol (optional) Property symbol object, if the property is of the `symbol` type.
	Symbol *RuntimeRemoteObject `json:"symbol,omitempty"`
}

// RuntimeInternalPropertyDescriptor Object internal property descriptor. This property isn't normally visible in JavaScript code.
type RuntimeInternalPropertyDescriptor struct {

	// Name Conventional property name.
	Name string `json:"name"`

	// Value (optional) The value associated with the property.
	Value *RuntimeRemoteObject `json:"value,omitempty"`
}

// RuntimePrivatePropertyDescriptor (experimental) Object private field descriptor.
type RuntimePrivatePropertyDescriptor struct {

	// Name Private property name.
	Name string `json:"name"`

	// Value (optional) The value associated with the private property.
	Value *RuntimeRemoteObject `json:"value,omitempty"`

	// Get (optional) A function which serves as a getter for the private property,
	// or `undefined` if there is no getter (accessor descriptors only).
	Get *RuntimeRemoteObject `json:"get,omitempty"`

	// Set (optional) A function which serves as a setter for the private property,
	// or `undefined` if there is no setter (accessor descriptors only).
	Set *RuntimeRemoteObject `json:"set,omitempty"`
}

// RuntimeCallArgument Represents function call argument. Either remote object id `objectId`, primitive `value`,
// unserializable primitive value or neither of (for undefined) them should be specified.
type RuntimeCallArgument struct {

	// Value (optional) Primitive value or serializable javascript object.
	Value JSON `json:"value,omitempty"`

	// UnserializableValue (optional) Primitive value which can not be JSON-stringified.
	UnserializableValue RuntimeUnserializableValue `json:"unserializableValue,omitempty"`

	// ObjectID (optional) Remote object handle.
	ObjectID RuntimeRemoteObjectID `json:"objectId,omitempty"`
}

// RuntimeExecutionContextID Id of an execution context.
type RuntimeExecutionContextID int64

// RuntimeExecutionContextDescription Description of an isolated world.
type RuntimeExecutionContextDescription struct {

	// ID Unique id of the execution context. It can be used to specify in which execution context
	// script evaluation should be performed.
	ID RuntimeExecutionContextID `json:"id"`

	// Origin Execution context origin.
	Origin string `json:"origin"`

	// Name Human readable name describing given context.
	Name string `json:"name"`

	// AuxData (optional) Embedder-specific auxiliary data.
	AuxData map[string]JSON `json:"auxData,omitempty"`
}

// RuntimeExceptionDetails Detailed information about exception (or error) that was thrown during script compilation or
// execution.
type RuntimeExceptionDetails struct {

	// ExceptionID Exception id.
	ExceptionID int64 `json:"exceptionId"`

	// Text Exception text, which should be used together with exception object when available.
	Text string `json:"text"`

	// LineNumber Line number of the exception location (0-based).
	LineNumber int64 `json:"lineNumber"`

	// ColumnNumber Column number of the exception location (0-based).
	ColumnNumber int64 `json:"columnNumber"`

	// ScriptID (optional) Script ID of the exception location.
	ScriptID RuntimeScriptID `json:"scriptId,omitempty"`

	// URL (optional) URL of the exception location, to be used when the script was not reported.
	URL string `json:"url,omitempty"`

	// StackTrace (optional) JavaScript stack trace if available.
	StackTrace *RuntimeStackTrace `json:"stackTrace,omitempty"`

	// Exception (optional) Exception object if available.
	Exception *RuntimeRemoteObject `json:"exception,omitempty"`

	// ExecutionContextID (optional) Identifier of the context where exception happened.
	ExecutionContextID RuntimeExecutionContextID `json:"executionContextId,omitempty"`
}

// RuntimeTimestamp Number of milliseconds since epoch.
type RuntimeTimestamp float64

// RuntimeTimeDelta Number of milliseconds.
type RuntimeTimeDelta float64

// RuntimeCallFrame Stack entry for runtime errors and assertions.
type RuntimeCallFrame struct {

	// FunctionName JavaScript function name.
	FunctionName string `json:"functionName"`

	// ScriptID JavaScript script id.
	ScriptID RuntimeScriptID `json:"scriptId"`

	// URL JavaScript script name or url.
	URL string `json:"url"`

	// LineNumber JavaScript script line number (0-based).
	LineNumber int64 `json:"lineNumber"`

	// ColumnNumber JavaScript script column number (0-based).
	ColumnNumber int64 `json:"columnNumber"`
}

// RuntimeStackTrace Call frames for assertions or error messages.
type RuntimeStackTrace struct {

	// Description (optional) String label of this stack trace. For async traces this may be a name of the function that
	// initiated the async call.
	Description string `json:"description,omitempty"`

	// CallFrames JavaScript function name.
	CallFrames []*RuntimeCallFrame `json:"callFrames"`

	// Parent (optional) Asynchronous JavaScript stack trace that preceded this stack, if available.
	Parent *RuntimeStackTrace `json:"parent,omitempty"`

	// ParentID (experimental) (optional) Asynchronous JavaScript stack trace that preceded this stack, if available.
	ParentID *RuntimeStackTraceID `json:"parentId,omitempty"`
}

// RuntimeUniqueDebuggerID (experimental) Unique identifier of current debugger.
type RuntimeUniqueDebuggerID string

// RuntimeStackTraceID (experimental) If `debuggerId` is set stack trace comes from another debugger and can be resolved there. This
// allows to track cross-debugger calls. See `Runtime.StackTrace` and `Debugger.paused` for usages.
type RuntimeStackTraceID struct {

	// ID ...
	ID string `json:"id"`

	// DebuggerID (optional) ...
	DebuggerID RuntimeUniqueDebuggerID `json:"debuggerId,omitempty"`
}

// RuntimeAwaitPromise Add handler to promise with given promise object id.
type RuntimeAwaitPromise struct {

	// PromiseObjectID Identifier of the promise.
	PromiseObjectID RuntimeRemoteObjectID `json:"promiseObjectId"`

	// ReturnByValue (optional) Whether the result is expected to be a JSON object that should be sent by value.
	ReturnByValue bool `json:"returnByValue,omitempty"`

	// GeneratePreview (optional) Whether preview should be generated for the result.
	GeneratePreview bool `json:"generatePreview,omitempty"`
}

// Call of the command, sessionID is optional.
func (m RuntimeAwaitPromise) Call(caller Caller) (*RuntimeAwaitPromiseResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Runtime.awaitPromise", m)
	if err != nil {
		return nil, err
	}

	var res RuntimeAwaitPromiseResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// RuntimeAwaitPromiseResult Add handler to promise with given promise object id.
type RuntimeAwaitPromiseResult struct {

	// Result Promise result. Will contain rejected value if promise was rejected.
	Result *RuntimeRemoteObject `json:"result"`

	// ExceptionDetails (optional) Exception details if stack strace is available.
	ExceptionDetails *RuntimeExceptionDetails `json:"exceptionDetails,omitempty"`
}

// RuntimeCallFunctionOn Calls function with given declaration on the given object. Object group of the result is
// inherited from the target object.
type RuntimeCallFunctionOn struct {

	// FunctionDeclaration Declaration of the function to call.
	FunctionDeclaration string `json:"functionDeclaration"`

	// ObjectID (optional) Identifier of the object to call function on. Either objectId or executionContextId should
	// be specified.
	ObjectID RuntimeRemoteObjectID `json:"objectId,omitempty"`

	// Arguments (optional) Call arguments. All call arguments must belong to the same JavaScript world as the target
	// object.
	Arguments []*RuntimeCallArgument `json:"arguments,omitempty"`

	// Silent (optional) In silent mode exceptions thrown during evaluation are not reported and do not pause
	// execution. Overrides `setPauseOnException` state.
	Silent bool `json:"silent,omitempty"`

	// ReturnByValue (optional) Whether the result is expected to be a JSON object which should be sent by value.
	ReturnByValue bool `json:"returnByValue,omitempty"`

	// GeneratePreview (experimental) (optional) Whether preview should be generated for the result.
	GeneratePreview bool `json:"generatePreview,omitempty"`

	// UserGesture (optional) Whether execution should be treated as initiated by user in the UI.
	UserGesture bool `json:"userGesture,omitempty"`

	// AwaitPromise (optional) Whether execution should `await` for resulting value and return once awaited promise is
	// resolved.
	AwaitPromise bool `json:"awaitPromise,omitempty"`

	// ExecutionContextID (optional) Specifies execution context which global object will be used to call function on. Either
	// executionContextId or objectId should be specified.
	ExecutionContextID RuntimeExecutionContextID `json:"executionContextId,omitempty"`

	// ObjectGroup (optional) Symbolic group name that can be used to release multiple objects. If objectGroup is not
	// specified and objectId is, objectGroup will be inherited from object.
	ObjectGroup string `json:"objectGroup,omitempty"`
}

// Call of the command, sessionID is optional.
func (m RuntimeCallFunctionOn) Call(caller Caller) (*RuntimeCallFunctionOnResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Runtime.callFunctionOn", m)
	if err != nil {
		return nil, err
	}

	var res RuntimeCallFunctionOnResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// RuntimeCallFunctionOnResult Calls function with given declaration on the given object. Object group of the result is
// inherited from the target object.
type RuntimeCallFunctionOnResult struct {

	// Result Call result.
	Result *RuntimeRemoteObject `json:"result"`

	// ExceptionDetails (optional) Exception details.
	ExceptionDetails *RuntimeExceptionDetails `json:"exceptionDetails,omitempty"`
}

// RuntimeCompileScript Compiles expression.
type RuntimeCompileScript struct {

	// Expression Expression to compile.
	Expression string `json:"expression"`

	// SourceURL Source url to be set for the script.
	SourceURL string `json:"sourceURL"`

	// PersistScript Specifies whether the compiled script should be persisted.
	PersistScript bool `json:"persistScript"`

	// ExecutionContextID (optional) Specifies in which execution context to perform script run. If the parameter is omitted the
	// evaluation will be performed in the context of the inspected page.
	ExecutionContextID RuntimeExecutionContextID `json:"executionContextId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m RuntimeCompileScript) Call(caller Caller) (*RuntimeCompileScriptResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Runtime.compileScript", m)
	if err != nil {
		return nil, err
	}

	var res RuntimeCompileScriptResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// RuntimeCompileScriptResult Compiles expression.
type RuntimeCompileScriptResult struct {

	// ScriptID (optional) Id of the script.
	ScriptID RuntimeScriptID `json:"scriptId,omitempty"`

	// ExceptionDetails (optional) Exception details.
	ExceptionDetails *RuntimeExceptionDetails `json:"exceptionDetails,omitempty"`
}

// RuntimeDisable Disables reporting of execution contexts creation.
type RuntimeDisable struct {
}

// Call of the command, sessionID is optional.
func (m RuntimeDisable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Runtime.disable", m)
	return err
}

// RuntimeDiscardConsoleEntries Discards collected exceptions and console API calls.
type RuntimeDiscardConsoleEntries struct {
}

// Call of the command, sessionID is optional.
func (m RuntimeDiscardConsoleEntries) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Runtime.discardConsoleEntries", m)
	return err
}

// RuntimeEnable Enables reporting of execution contexts creation by means of `executionContextCreated` event.
// When the reporting gets enabled the event will be sent immediately for each existing execution
// context.
type RuntimeEnable struct {
}

// Call of the command, sessionID is optional.
func (m RuntimeEnable) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Runtime.enable", m)
	return err
}

// RuntimeEvaluate Evaluates expression on global object.
type RuntimeEvaluate struct {

	// Expression Expression to evaluate.
	Expression string `json:"expression"`

	// ObjectGroup (optional) Symbolic group name that can be used to release multiple objects.
	ObjectGroup string `json:"objectGroup,omitempty"`

	// IncludeCommandLineAPI (optional) Determines whether Command Line API should be available during the evaluation.
	IncludeCommandLineAPI bool `json:"includeCommandLineAPI,omitempty"`

	// Silent (optional) In silent mode exceptions thrown during evaluation are not reported and do not pause
	// execution. Overrides `setPauseOnException` state.
	Silent bool `json:"silent,omitempty"`

	// ContextID (optional) Specifies in which execution context to perform evaluation. If the parameter is omitted the
	// evaluation will be performed in the context of the inspected page.
	ContextID RuntimeExecutionContextID `json:"contextId,omitempty"`

	// ReturnByValue (optional) Whether the result is expected to be a JSON object that should be sent by value.
	ReturnByValue bool `json:"returnByValue,omitempty"`

	// GeneratePreview (experimental) (optional) Whether preview should be generated for the result.
	GeneratePreview bool `json:"generatePreview,omitempty"`

	// UserGesture (optional) Whether execution should be treated as initiated by user in the UI.
	UserGesture bool `json:"userGesture,omitempty"`

	// AwaitPromise (optional) Whether execution should `await` for resulting value and return once awaited promise is
	// resolved.
	AwaitPromise bool `json:"awaitPromise,omitempty"`

	// ThrowOnSideEffect (experimental) (optional) Whether to throw an exception if side effect cannot be ruled out during evaluation.
	// This implies `disableBreaks` below.
	ThrowOnSideEffect bool `json:"throwOnSideEffect,omitempty"`

	// Timeout (experimental) (optional) Terminate execution after timing out (number of milliseconds).
	Timeout RuntimeTimeDelta `json:"timeout,omitempty"`

	// DisableBreaks (experimental) (optional) Disable breakpoints during execution.
	DisableBreaks bool `json:"disableBreaks,omitempty"`

	// ReplMode (experimental) (optional) Reserved flag for future REPL mode support. Setting this flag has currently no effect.
	ReplMode bool `json:"replMode,omitempty"`
}

// Call of the command, sessionID is optional.
func (m RuntimeEvaluate) Call(caller Caller) (*RuntimeEvaluateResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Runtime.evaluate", m)
	if err != nil {
		return nil, err
	}

	var res RuntimeEvaluateResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// RuntimeEvaluateResult Evaluates expression on global object.
type RuntimeEvaluateResult struct {

	// Result Evaluation result.
	Result *RuntimeRemoteObject `json:"result"`

	// ExceptionDetails (optional) Exception details.
	ExceptionDetails *RuntimeExceptionDetails `json:"exceptionDetails,omitempty"`
}

// RuntimeGetIsolateID (experimental) Returns the isolate id.
type RuntimeGetIsolateID struct {
}

// Call of the command, sessionID is optional.
func (m RuntimeGetIsolateID) Call(caller Caller) (*RuntimeGetIsolateIDResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Runtime.getIsolateId", m)
	if err != nil {
		return nil, err
	}

	var res RuntimeGetIsolateIDResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// RuntimeGetIsolateIDResult (experimental) Returns the isolate id.
type RuntimeGetIsolateIDResult struct {

	// ID The isolate id.
	ID string `json:"id"`
}

// RuntimeGetHeapUsage (experimental) Returns the JavaScript heap usage.
// It is the total usage of the corresponding isolate not scoped to a particular Runtime.
type RuntimeGetHeapUsage struct {
}

// Call of the command, sessionID is optional.
func (m RuntimeGetHeapUsage) Call(caller Caller) (*RuntimeGetHeapUsageResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Runtime.getHeapUsage", m)
	if err != nil {
		return nil, err
	}

	var res RuntimeGetHeapUsageResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// RuntimeGetHeapUsageResult (experimental) Returns the JavaScript heap usage.
// It is the total usage of the corresponding isolate not scoped to a particular Runtime.
type RuntimeGetHeapUsageResult struct {

	// UsedSize Used heap size in bytes.
	UsedSize float64 `json:"usedSize"`

	// TotalSize Allocated heap size in bytes.
	TotalSize float64 `json:"totalSize"`
}

// RuntimeGetProperties Returns properties of a given object. Object group of the result is inherited from the target
// object.
type RuntimeGetProperties struct {

	// ObjectID Identifier of the object to return properties for.
	ObjectID RuntimeRemoteObjectID `json:"objectId"`

	// OwnProperties (optional) If true, returns properties belonging only to the element itself, not to its prototype
	// chain.
	OwnProperties bool `json:"ownProperties,omitempty"`

	// AccessorPropertiesOnly (experimental) (optional) If true, returns accessor properties (with getter/setter) only; internal properties are not
	// returned either.
	AccessorPropertiesOnly bool `json:"accessorPropertiesOnly,omitempty"`

	// GeneratePreview (experimental) (optional) Whether preview should be generated for the results.
	GeneratePreview bool `json:"generatePreview,omitempty"`
}

// Call of the command, sessionID is optional.
func (m RuntimeGetProperties) Call(caller Caller) (*RuntimeGetPropertiesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Runtime.getProperties", m)
	if err != nil {
		return nil, err
	}

	var res RuntimeGetPropertiesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// RuntimeGetPropertiesResult Returns properties of a given object. Object group of the result is inherited from the target
// object.
type RuntimeGetPropertiesResult struct {

	// Result Object properties.
	Result []*RuntimePropertyDescriptor `json:"result"`

	// InternalProperties (optional) Internal object properties (only of the element itself).
	InternalProperties []*RuntimeInternalPropertyDescriptor `json:"internalProperties,omitempty"`

	// PrivateProperties (experimental) (optional) Object private properties.
	PrivateProperties []*RuntimePrivatePropertyDescriptor `json:"privateProperties,omitempty"`

	// ExceptionDetails (optional) Exception details.
	ExceptionDetails *RuntimeExceptionDetails `json:"exceptionDetails,omitempty"`
}

// RuntimeGlobalLexicalScopeNames Returns all let, const and class variables from global scope.
type RuntimeGlobalLexicalScopeNames struct {

	// ExecutionContextID (optional) Specifies in which execution context to lookup global scope variables.
	ExecutionContextID RuntimeExecutionContextID `json:"executionContextId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m RuntimeGlobalLexicalScopeNames) Call(caller Caller) (*RuntimeGlobalLexicalScopeNamesResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Runtime.globalLexicalScopeNames", m)
	if err != nil {
		return nil, err
	}

	var res RuntimeGlobalLexicalScopeNamesResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// RuntimeGlobalLexicalScopeNamesResult Returns all let, const and class variables from global scope.
type RuntimeGlobalLexicalScopeNamesResult struct {

	// Names ...
	Names []string `json:"names"`
}

// RuntimeQueryObjects ...
type RuntimeQueryObjects struct {

	// PrototypeObjectID Identifier of the prototype to return objects for.
	PrototypeObjectID RuntimeRemoteObjectID `json:"prototypeObjectId"`

	// ObjectGroup (optional) Symbolic group name that can be used to release the results.
	ObjectGroup string `json:"objectGroup,omitempty"`
}

// Call of the command, sessionID is optional.
func (m RuntimeQueryObjects) Call(caller Caller) (*RuntimeQueryObjectsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Runtime.queryObjects", m)
	if err != nil {
		return nil, err
	}

	var res RuntimeQueryObjectsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// RuntimeQueryObjectsResult ...
type RuntimeQueryObjectsResult struct {

	// Objects Array with objects.
	Objects *RuntimeRemoteObject `json:"objects"`
}

// RuntimeReleaseObject Releases remote object with given id.
type RuntimeReleaseObject struct {

	// ObjectID Identifier of the object to release.
	ObjectID RuntimeRemoteObjectID `json:"objectId"`
}

// Call of the command, sessionID is optional.
func (m RuntimeReleaseObject) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Runtime.releaseObject", m)
	return err
}

// RuntimeReleaseObjectGroup Releases all remote objects that belong to a given group.
type RuntimeReleaseObjectGroup struct {

	// ObjectGroup Symbolic object group name.
	ObjectGroup string `json:"objectGroup"`
}

// Call of the command, sessionID is optional.
func (m RuntimeReleaseObjectGroup) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Runtime.releaseObjectGroup", m)
	return err
}

// RuntimeRunIfWaitingForDebugger Tells inspected instance to run if it was waiting for debugger to attach.
type RuntimeRunIfWaitingForDebugger struct {
}

// Call of the command, sessionID is optional.
func (m RuntimeRunIfWaitingForDebugger) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Runtime.runIfWaitingForDebugger", m)
	return err
}

// RuntimeRunScript Runs script with given id in a given context.
type RuntimeRunScript struct {

	// ScriptID Id of the script to run.
	ScriptID RuntimeScriptID `json:"scriptId"`

	// ExecutionContextID (optional) Specifies in which execution context to perform script run. If the parameter is omitted the
	// evaluation will be performed in the context of the inspected page.
	ExecutionContextID RuntimeExecutionContextID `json:"executionContextId,omitempty"`

	// ObjectGroup (optional) Symbolic group name that can be used to release multiple objects.
	ObjectGroup string `json:"objectGroup,omitempty"`

	// Silent (optional) In silent mode exceptions thrown during evaluation are not reported and do not pause
	// execution. Overrides `setPauseOnException` state.
	Silent bool `json:"silent,omitempty"`

	// IncludeCommandLineAPI (optional) Determines whether Command Line API should be available during the evaluation.
	IncludeCommandLineAPI bool `json:"includeCommandLineAPI,omitempty"`

	// ReturnByValue (optional) Whether the result is expected to be a JSON object which should be sent by value.
	ReturnByValue bool `json:"returnByValue,omitempty"`

	// GeneratePreview (optional) Whether preview should be generated for the result.
	GeneratePreview bool `json:"generatePreview,omitempty"`

	// AwaitPromise (optional) Whether execution should `await` for resulting value and return once awaited promise is
	// resolved.
	AwaitPromise bool `json:"awaitPromise,omitempty"`
}

// Call of the command, sessionID is optional.
func (m RuntimeRunScript) Call(caller Caller) (*RuntimeRunScriptResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Runtime.runScript", m)
	if err != nil {
		return nil, err
	}

	var res RuntimeRunScriptResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// RuntimeRunScriptResult Runs script with given id in a given context.
type RuntimeRunScriptResult struct {

	// Result Run result.
	Result *RuntimeRemoteObject `json:"result"`

	// ExceptionDetails (optional) Exception details.
	ExceptionDetails *RuntimeExceptionDetails `json:"exceptionDetails,omitempty"`
}

// RuntimeSetAsyncCallStackDepth Enables or disables async call stacks tracking.
type RuntimeSetAsyncCallStackDepth struct {

	// MaxDepth Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
	// call stacks (default).
	MaxDepth int64 `json:"maxDepth"`
}

// Call of the command, sessionID is optional.
func (m RuntimeSetAsyncCallStackDepth) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Runtime.setAsyncCallStackDepth", m)
	return err
}

// RuntimeSetCustomObjectFormatterEnabled (experimental) ...
type RuntimeSetCustomObjectFormatterEnabled struct {

	// Enabled ...
	Enabled bool `json:"enabled"`
}

// Call of the command, sessionID is optional.
func (m RuntimeSetCustomObjectFormatterEnabled) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Runtime.setCustomObjectFormatterEnabled", m)
	return err
}

// RuntimeSetMaxCallStackSizeToCapture (experimental) ...
type RuntimeSetMaxCallStackSizeToCapture struct {

	// Size ...
	Size int64 `json:"size"`
}

// Call of the command, sessionID is optional.
func (m RuntimeSetMaxCallStackSizeToCapture) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Runtime.setMaxCallStackSizeToCapture", m)
	return err
}

// RuntimeTerminateExecution (experimental) Terminate current or next JavaScript execution.
// Will cancel the termination when the outer-most script execution ends.
type RuntimeTerminateExecution struct {
}

// Call of the command, sessionID is optional.
func (m RuntimeTerminateExecution) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Runtime.terminateExecution", m)
	return err
}

// RuntimeAddBinding (experimental) If executionContextId is empty, adds binding with the given name on the
// global objects of all inspected contexts, including those created later,
// bindings survive reloads.
// If executionContextId is specified, adds binding only on global object of
// given execution context.
// Binding function takes exactly one argument, this argument should be string,
// in case of any other input, function throws an exception.
// Each binding function call produces Runtime.bindingCalled notification.
type RuntimeAddBinding struct {

	// Name ...
	Name string `json:"name"`

	// ExecutionContextID (optional) ...
	ExecutionContextID RuntimeExecutionContextID `json:"executionContextId,omitempty"`
}

// Call of the command, sessionID is optional.
func (m RuntimeAddBinding) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Runtime.addBinding", m)
	return err
}

// RuntimeRemoveBinding (experimental) This method does not remove binding function from global object but
// unsubscribes current runtime agent from Runtime.bindingCalled notifications.
type RuntimeRemoveBinding struct {

	// Name ...
	Name string `json:"name"`
}

// Call of the command, sessionID is optional.
func (m RuntimeRemoveBinding) Call(caller Caller) error {
	ctx, client, id := caller.CallContext()
	_, err := client.Call(ctx, id, "Runtime.removeBinding", m)
	return err
}

// RuntimeBindingCalled (experimental) Notification is issued every time when binding is called.
type RuntimeBindingCalled struct {

	// Name ...
	Name string `json:"name"`

	// Payload ...
	Payload string `json:"payload"`

	// ExecutionContextID Identifier of the context where the call was made.
	ExecutionContextID RuntimeExecutionContextID `json:"executionContextId"`
}

// MethodName interface
func (evt RuntimeBindingCalled) MethodName() string {
	return "Runtime.bindingCalled"
}

// RuntimeConsoleAPICalledType enum
type RuntimeConsoleAPICalledType string

const (
	// RuntimeConsoleAPICalledTypeLog enum const
	RuntimeConsoleAPICalledTypeLog RuntimeConsoleAPICalledType = "log"

	// RuntimeConsoleAPICalledTypeDebug enum const
	RuntimeConsoleAPICalledTypeDebug RuntimeConsoleAPICalledType = "debug"

	// RuntimeConsoleAPICalledTypeInfo enum const
	RuntimeConsoleAPICalledTypeInfo RuntimeConsoleAPICalledType = "info"

	// RuntimeConsoleAPICalledTypeError enum const
	RuntimeConsoleAPICalledTypeError RuntimeConsoleAPICalledType = "error"

	// RuntimeConsoleAPICalledTypeWarning enum const
	RuntimeConsoleAPICalledTypeWarning RuntimeConsoleAPICalledType = "warning"

	// RuntimeConsoleAPICalledTypeDir enum const
	RuntimeConsoleAPICalledTypeDir RuntimeConsoleAPICalledType = "dir"

	// RuntimeConsoleAPICalledTypeDirxml enum const
	RuntimeConsoleAPICalledTypeDirxml RuntimeConsoleAPICalledType = "dirxml"

	// RuntimeConsoleAPICalledTypeTable enum const
	RuntimeConsoleAPICalledTypeTable RuntimeConsoleAPICalledType = "table"

	// RuntimeConsoleAPICalledTypeTrace enum const
	RuntimeConsoleAPICalledTypeTrace RuntimeConsoleAPICalledType = "trace"

	// RuntimeConsoleAPICalledTypeClear enum const
	RuntimeConsoleAPICalledTypeClear RuntimeConsoleAPICalledType = "clear"

	// RuntimeConsoleAPICalledTypeStartGroup enum const
	RuntimeConsoleAPICalledTypeStartGroup RuntimeConsoleAPICalledType = "startGroup"

	// RuntimeConsoleAPICalledTypeStartGroupCollapsed enum const
	RuntimeConsoleAPICalledTypeStartGroupCollapsed RuntimeConsoleAPICalledType = "startGroupCollapsed"

	// RuntimeConsoleAPICalledTypeEndGroup enum const
	RuntimeConsoleAPICalledTypeEndGroup RuntimeConsoleAPICalledType = "endGroup"

	// RuntimeConsoleAPICalledTypeAssert enum const
	RuntimeConsoleAPICalledTypeAssert RuntimeConsoleAPICalledType = "assert"

	// RuntimeConsoleAPICalledTypeProfile enum const
	RuntimeConsoleAPICalledTypeProfile RuntimeConsoleAPICalledType = "profile"

	// RuntimeConsoleAPICalledTypeProfileEnd enum const
	RuntimeConsoleAPICalledTypeProfileEnd RuntimeConsoleAPICalledType = "profileEnd"

	// RuntimeConsoleAPICalledTypeCount enum const
	RuntimeConsoleAPICalledTypeCount RuntimeConsoleAPICalledType = "count"

	// RuntimeConsoleAPICalledTypeTimeEnd enum const
	RuntimeConsoleAPICalledTypeTimeEnd RuntimeConsoleAPICalledType = "timeEnd"
)

// RuntimeConsoleAPICalled Issued when console API was called.
type RuntimeConsoleAPICalled struct {

	// Type Type of the call.
	Type RuntimeConsoleAPICalledType `json:"type"`

	// Args Call arguments.
	Args []*RuntimeRemoteObject `json:"args"`

	// ExecutionContextID Identifier of the context where the call was made.
	ExecutionContextID RuntimeExecutionContextID `json:"executionContextId"`

	// Timestamp Call timestamp.
	Timestamp RuntimeTimestamp `json:"timestamp"`

	// StackTrace (optional) Stack trace captured when the call was made. The async stack chain is automatically reported for
	// the following call types: `assert`, `error`, `trace`, `warning`. For other types the async call
	// chain can be retrieved using `Debugger.getStackTrace` and `stackTrace.parentId` field.
	StackTrace *RuntimeStackTrace `json:"stackTrace,omitempty"`

	// Context (experimental) (optional) Console context descriptor for calls on non-default console context (not console.*):
	// 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call
	// on named context.
	Context string `json:"context,omitempty"`
}

// MethodName interface
func (evt RuntimeConsoleAPICalled) MethodName() string {
	return "Runtime.consoleAPICalled"
}

// RuntimeExceptionRevoked Issued when unhandled exception was revoked.
type RuntimeExceptionRevoked struct {

	// Reason Reason describing why exception was revoked.
	Reason string `json:"reason"`

	// ExceptionID The id of revoked exception, as reported in `exceptionThrown`.
	ExceptionID int64 `json:"exceptionId"`
}

// MethodName interface
func (evt RuntimeExceptionRevoked) MethodName() string {
	return "Runtime.exceptionRevoked"
}

// RuntimeExceptionThrown Issued when exception was thrown and unhandled.
type RuntimeExceptionThrown struct {

	// Timestamp Timestamp of the exception.
	Timestamp RuntimeTimestamp `json:"timestamp"`

	// ExceptionDetails ...
	ExceptionDetails *RuntimeExceptionDetails `json:"exceptionDetails"`
}

// MethodName interface
func (evt RuntimeExceptionThrown) MethodName() string {
	return "Runtime.exceptionThrown"
}

// RuntimeExecutionContextCreated Issued when new execution context is created.
type RuntimeExecutionContextCreated struct {

	// Context A newly created execution context.
	Context *RuntimeExecutionContextDescription `json:"context"`
}

// MethodName interface
func (evt RuntimeExecutionContextCreated) MethodName() string {
	return "Runtime.executionContextCreated"
}

// RuntimeExecutionContextDestroyed Issued when execution context is destroyed.
type RuntimeExecutionContextDestroyed struct {

	// ExecutionContextID Id of the destroyed context
	ExecutionContextID RuntimeExecutionContextID `json:"executionContextId"`
}

// MethodName interface
func (evt RuntimeExecutionContextDestroyed) MethodName() string {
	return "Runtime.executionContextDestroyed"
}

// RuntimeExecutionContextsCleared Issued when all executionContexts were cleared in browser
type RuntimeExecutionContextsCleared struct {
}

// MethodName interface
func (evt RuntimeExecutionContextsCleared) MethodName() string {
	return "Runtime.executionContextsCleared"
}

// RuntimeInspectRequested Issued when object should be inspected (for example, as a result of inspect() command line API
// call).
type RuntimeInspectRequested struct {

	// Object ...
	Object *RuntimeRemoteObject `json:"object"`

	// Hints ...
	Hints map[string]JSON `json:"hints"`
}

// MethodName interface
func (evt RuntimeInspectRequested) MethodName() string {
	return "Runtime.inspectRequested"
}

// SchemaDomain Description of the protocol domain.
type SchemaDomain struct {

	// Name Domain name.
	Name string `json:"name"`

	// Version Domain version.
	Version string `json:"version"`
}

// SchemaGetDomains Returns supported domains.
type SchemaGetDomains struct {
}

// Call of the command, sessionID is optional.
func (m SchemaGetDomains) Call(caller Caller) (*SchemaGetDomainsResult, error) {
	ctx, client, id := caller.CallContext()
	bin, err := client.Call(ctx, id, "Schema.getDomains", m)
	if err != nil {
		return nil, err
	}

	var res SchemaGetDomainsResult
	err = json.Unmarshal(bin, &res)
	if err != nil {
		return nil, err
	}

	return &res, nil
}

// SchemaGetDomainsResult Returns supported domains.
type SchemaGetDomainsResult struct {

	// Domains List of supported domains.
	Domains []*SchemaDomain `json:"domains"`
}
