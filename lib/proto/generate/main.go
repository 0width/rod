package main

import (
	"path/filepath"
	"regexp"

	"github.com/ysmood/kit"
)

func main() {
	comment := `// This file is generated by "./lib/proto/generate"`

	schema := getSchema()

	code := comment + kit.S(`

		package proto

		import "encoding/json"

		// Version of cdp protocol
		const Version = "v{{.major}}.{{.minor}}"
	`, "major", schema.Get("version.major").String(), "minor", schema.Get("version.minor").String())

	testsCode := comment + `

		package proto_test

		import (
			"context"
			"errors"
			"testing"

			"github.com/stretchr/testify/assert"
			"github.com/ysmood/rod/lib/proto"
		)
	`

	for _, domain := range parse(schema) {
		for _, definition := range domain.definitions {
			code += definition.format()
			testsCode += definition.formatTests()
		}
	}

	kit.E(kit.OutputFile(filepath.FromSlash("lib/proto/definitions.go"), code, nil))
	kit.E(kit.OutputFile(filepath.FromSlash("lib/proto/definitions_test.go"), testsCode, nil))

	kit.Exec("gofmt", "-s", "-w", "./lib/proto").MustDo()
	kit.Exec("goimports", "-w", "./lib/proto").MustDo()
}

func (d *definition) comment() string {
	comment := d.description

	if comment == "" {
		comment = "..."
	}

	if d.optional {
		comment = "(optional) " + comment
	}
	if d.experimental {
		comment = "(experimental) " + comment
	}
	if d.deprecated {
		comment = "(deprecated) " + comment
	}

	comment = symbol(d.name) + " " + comment

	return regexp.MustCompile(`(?m)^`).ReplaceAllString(comment, "// ")
}

func (d *definition) format() (code string) {
	switch d.objType {
	case objTypePrimitive:
		code = kit.S(`
		{{.comment}}
		type {{.name}} {{.type}}
		`, "name", d.name, "type", d.typeName, "comment", d.comment())

		if d.enum != nil {
			code += "const ("
			for _, value := range d.enum {
				name := d.name + symbol(value)
				code += kit.S(`
				// {{.name}} enum const
				{{.name}} {{.type}} = "{{.value}}"
				`, "name", name, "type", d.name, "value", value)
			}
			code += ")\n"
		}

	case objTypeStruct:
		code = kit.S(`
		{{.comment}}
		type {{.name}} struct {
		`, "name", d.name, "comment", d.comment())

		for _, prop := range d.props {
			tag := jsonTag(prop.originName, prop.optional)

			code += kit.S(`
			{{.comment}}
			{{.name}} {{.type}} {{.tag}}
			`, "comment", prop.comment(), "name", prop.name, "type", prop.typeName, "tag", tag)
		}

		code += "}\n"

		if d.command {
			method := d.domain.name + "." + d.originName
			if d.returnValue {
				code += kit.S(`
				// Call of the command, sessionID is optional.
				func (m {{.name}}) Call(caller Caller) (*{{.name}}Result, error) {
					ctx, client, id := caller.CallContext()
					bin, err := client.Call(ctx, id, "{{.method}}", m)
					if err != nil {
						return nil, err
					}
		
					var res {{.name}}Result
					err = json.Unmarshal(bin, &res)
					if err != nil {
						return nil, err
					}
			
					return &res, nil
				}
				`, "name", d.name, "method", method)
			} else {
				code += kit.S(`
				// Call of the command, sessionID is optional.
				func (m {{.name}}) Call(caller Caller) error {
					ctx, client, id := caller.CallContext()
					_, err := client.Call(ctx, id, "{{.method}}", m)
					return err
				}
				`, "name", d.name, "method", method)
			}
		}

		if d.cdpType == cdpTypeEvents {
			code += kit.S(`
				// MethodName interface
				func (evt {{.name}}) MethodName() string {
					return "{{.event}}"
				}

				// Load json
				func (evt {{.name}}) Load(b []byte) *{{.name}} {
					E(json.Unmarshal(b, &evt))
					return &evt
				}
			`, "name", d.name, "event", d.domain.name+"."+d.originName)
		}
	}

	return
}

func (d *definition) formatTests() (code string) {
	switch d.cdpType {
	case cdpTypeCommands:
		if !d.command {
			return ""
		}

		if d.returnValue {
			return kit.S(`
				func Test{{.name}}(t *testing.T) {
					c := &Client{}
					_, err := proto.{{.name}}{}.Call(&Caller{c})
					assert.Nil(t, err)
					
					c = &Client{err: errors.New("err")}
					_, err = proto.{{.name}}{}.Call(&Caller{c})
					assert.Error(t, err)
			
					c = &Client{ret: "err"}
					_, err = proto.{{.name}}{}.Call(&Caller{c})
					assert.Error(t, err)
				}
				`, "name", d.name)
		}

		return kit.S(`
			func Test{{.name}}(t *testing.T) {
				c := &Client{}
				err := proto.{{.name}}{}.Call(&Caller{c})
				assert.Nil(t, err)
				
				c = &Client{err: errors.New("err")}
				err = proto.{{.name}}{}.Call(&Caller{c})
				assert.Error(t, err)
			}
			`, "name", d.name)

	case cdpTypeEvents:
		return kit.S(`
		func Test{{.name}}(t *testing.T) {
			e := proto.{{.name}}{}
			e.MethodName()
			e.Load([]byte("null"))
		}
		`, "name", d.name)
	}

	return ""
}
